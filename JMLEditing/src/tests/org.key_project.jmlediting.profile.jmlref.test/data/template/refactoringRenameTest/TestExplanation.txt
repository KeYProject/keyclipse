Basic idea: 
Run a renaming and compare the editor content to a given oracle, i.e. the result which should be achieved.


1) Each test in its own folder. Separated in src and oracle.
2) First, files are copied and oracle string is generated.
3) Renaming is done (usually of the field named balance).
4) Comparison of editor after renaming to oracle.


What is tested:

***** Testing Field Renaming *****

Tested in file FieldRenameRefactoringTest:

Test1: one occurrence in a simple assignable clause
Test2: additional occurrences in requires and ensures clauses
Test3: local variable with the same name (balance) and use of this qualifier
Test4: a field from another class is accessed which has the same name as the field to be renamed (balance).
Test5: the other class accesses and returns the balance field of the main class and thus need to change the name.
Test6: the other class is additionally in another package and instead of returning the balance field of the main class
      it sets the field with the local parameter called balance too.
Test7: more complex usage of balance. More than one member access.
Test8: Changes to the JML code in the other class but no changes to the java code. Other class accesses the balance field
      from the main class by using getBalance() but refers to the field in the JML code.
Test9: Like 8 but with 2 files without java changes.
(Resolver problem) Test10: change within an invariant.
Test11: combination of this qualifier and method with same name as the field.
Test12: test11 plus a nested field call: TestClass balance; this.balance.balance()
Test13: test12 with changed order: this.balance().balance
Test14: test11/12 with more nesting: this.balance.balance == test.balance.balance().balance
Test15: field reference after a MethodCall: get("someClass").balance
(Resolver problem) Test16: test15 with another call afterwards: (classes.get(0)).balance.equals("5")
(Resolver problem) Test17: test16 without the parentheses
Test18: many MemberAccesses and MethodCalls plus distinguishing between String and field: 
         project.getClass().getDeclaredField("balance").equals(balance)

Tests with several projects: Run in file FieldRenameRefactoringTestSeveralProjects:

Test19: Test with 2 Projects. One Project (referencingProject) references the balance-field of another project (referencedProject)
Test20: Additional to test19, the referencingProject has an own field called balance.


****** Testing Parameter Renaming *****
Test1: One method, one parameter.
Test2: One method, two parameters, renamed parameter is first.
Test3: One method, two parameters, renamed parameter is second.
Test4: Field with same name. Other method (constructor) using parameter with same name.

****** Testing Class Renaming *****
Test1: One class, one method which uses the class in java code and JML.
Test2: One class, one method which only references the class in JML (twice!), i.e. no java text changes recorded for that class
Test3: Two classes, same package. OtherClass initializes TestClass.
Test4: like Test3 but without any reference to TestClass in OtherClass, thus no java changes in that class.
(Resolver problem) Test5: Two classes, different package.

****** Testing Package Renaming *****
Test1: One class, one package reference in JML.
Test2: Two classes, in same package. Each with one package reference in JML.
Test3: Two classes, in same package. Each with two package references in JML.
Test4: Two classes in the package which will be renamed. One class in otherPackage which references both classes in the renamed package.
- Tests with sub folders:
Test5: Like test4 but package to be renamed is a sub folder.
Test6: One references class is in parent package and one referenced class is in sub package, which is to be renamed. 
Test7: Like test6 but parent package is renamed with "rename subpackages" option activated.
Test8: Like test7 but option is not activated.