// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2015 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

package de.uka.ilkd.key.proof.io;

import static de.uka.ilkd.key.util.joinrule.JoinRuleUtils.sequentToSETriple;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.key_project.util.collection.DefaultImmutableSet;
import org.key_project.util.collection.ImmutableList;
import org.key_project.util.collection.ImmutableSLList;
import org.key_project.util.collection.ImmutableSet;

import de.uka.ilkd.key.java.ProgramElement;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Namespace;
import de.uka.ilkd.key.logic.PosInOccurrence;
import de.uka.ilkd.key.logic.PosInTerm;
import de.uka.ilkd.key.logic.Sequent;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.ProgramSV;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.op.SchemaVariable;
import de.uka.ilkd.key.logic.op.SkolemTermSV;
import de.uka.ilkd.key.logic.op.VariableSV;
import de.uka.ilkd.key.parser.DefaultTermParser;
import de.uka.ilkd.key.parser.ParserException;
import de.uka.ilkd.key.pp.AbbrevMap;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Node;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.io.intermediate.AppNodeIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.BranchNodeIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.BuiltInAppIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.JoinAppIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.JoinPartnerAppIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.NodeIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.TacletAppIntermediate;
import de.uka.ilkd.key.rule.AbstractContractRuleApp;
import de.uka.ilkd.key.rule.BuiltInRule;
import de.uka.ilkd.key.rule.IBuiltInRuleApp;
import de.uka.ilkd.key.rule.IfFormulaInstDirect;
import de.uka.ilkd.key.rule.IfFormulaInstSeq;
import de.uka.ilkd.key.rule.IfFormulaInstantiation;
import de.uka.ilkd.key.rule.NoPosTacletApp;
import de.uka.ilkd.key.rule.Taclet;
import de.uka.ilkd.key.rule.TacletApp;
import de.uka.ilkd.key.rule.UseDependencyContractRule;
import de.uka.ilkd.key.rule.UseOperationContractRule;
import de.uka.ilkd.key.rule.join.JoinProcedure;
import de.uka.ilkd.key.rule.join.JoinRuleBuiltInRuleApp;
import de.uka.ilkd.key.settings.ProofIndependentSettings;
import de.uka.ilkd.key.settings.SMTSettings;
import de.uka.ilkd.key.smt.RuleAppSMT;
import de.uka.ilkd.key.smt.SMTProblem;
import de.uka.ilkd.key.smt.SolverLauncher;
import de.uka.ilkd.key.smt.SolverTypeCollection;
import de.uka.ilkd.key.smt.SMTSolverResult.ThreeValuedTruth;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.OperationContract;
import de.uka.ilkd.key.util.Pair;
import de.uka.ilkd.key.util.Triple;
import de.uka.ilkd.key.util.joinrule.JoinRuleUtils;
import de.uka.ilkd.key.util.joinrule.ProgramVariablesMatchVisitor;

/**
 * This class is responsible for generating a KeY proof from an intermediate
 * representation generated by {@link IntermediatePresentationProofFileParser}.
 * <p>
 * 
 * Replay is started using {@link #replay()}. In the course of replaying, new
 * nodes are added to the supplied proof object. The last goal touched during
 * replay can be obtained by {@link #getLastSelectedGoal()}.
 * 
 * TODO: Check if joining with more than one partner works out of the box.
 * Potential problem: Different order may result in syntactically different
 * nodes.
 *
 * @see IntermediatePresentationProofFileParser
 *
 * @author Dominic Scheurer
 */
public class IntermediateProofReplayer {

    private static final String ERROR_LOADING_PROOF_LINE = "Error loading proof.\n";
    private static final String NOT_APPLICABLE = " not available or not applicable in this context.";

    /** The problem loader, for reporting errors */
    private final AbstractProblemLoader loader;
    /** The proof object into which to load the replayed proof */
    private Proof proof = null;

    /** Encountered errors */
    private List<Throwable> errors = new LinkedList<Throwable>();
    /** Error status */
    private String status = "";

    /** Stores open branches */
    private LinkedList<Pair<Node, NodeIntermediate>> queue = new LinkedList<Pair<Node, NodeIntermediate>>();

    /** Maps join node IDs to previously seen join partners */
    private HashMap<Integer, HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>>> joinPartnerNodes = new HashMap<Integer, HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>>>();

    /** The current open goal */
    private Goal currGoal = null;

    /**
     * Constructs a new {@link IntermediateProofReplayer}.
     *
     * @param loader
     *            The problem loader, for reporting errors.
     * @param proof
     *            The proof object into which to load the replayed proof.
     * @param intermediate
     */
    public IntermediateProofReplayer(AbstractProblemLoader loader, Proof proof,
            IntermediatePresentationProofFileParser.Result parserResult) {
        this.proof = proof;
        this.loader = loader;

        queue.addFirst(new Pair<Node, NodeIntermediate>(proof.root(),
                parserResult.getParsedResult()));
    }

    /**
     * @return the lastSelectedGoal
     */
    public Goal getLastSelectedGoal() {
        return currGoal;
    }

    /**
     * Starts the actual replay process. Results are stored in the supplied
     * proof object; the last selected goal may be obtained by
     * {@link #getLastSelectedGoal()}.
     */
    public Result replay() {
        while (!queue.isEmpty()) {
            final Pair<Node, NodeIntermediate> currentP = queue.pollFirst();
            final Node currNode = currentP.first;
            final NodeIntermediate currNodeInterm = currentP.second;
            currGoal = proof.getGoal(currNode);

            try {
                if (currNodeInterm instanceof BranchNodeIntermediate) {
                    assert currNodeInterm.getChildren().size() <= 1 : "Branch node should have exactly one child.";
                    if (currNodeInterm.getChildren().size() == 1) {
                        queue.addFirst(new Pair<Node, NodeIntermediate>(currNode,
                                currNodeInterm.getChildren().get(0)));
                    }
                    continue;
                }
                else if (currNodeInterm instanceof AppNodeIntermediate) {
                    AppNodeIntermediate currInterm = (AppNodeIntermediate) currNodeInterm;
                    currNode.getNodeInfo().setInteractiveRuleApplication(
                            currInterm.isInteractiveRuleApplication());
    
                    // Register name proposals
                    proof.getServices()
                            .getNameRecorder()
                            .setProposals(
                                    currInterm.getIntermediateRuleApp()
                                            .getNewNames());
    
                    if (currInterm.getIntermediateRuleApp() instanceof TacletAppIntermediate) {
                        TacletAppIntermediate appInterm = (TacletAppIntermediate) currInterm
                                .getIntermediateRuleApp();
    
                        try {
                            currGoal.apply(constructTacletApp(appInterm, currGoal));
    
                            final Iterator<Node> children = currNode.childrenIterator();
                            final LinkedList<NodeIntermediate> intermChildren = currInterm
                                    .getChildren();
    
                            addChildren(children, intermChildren);
                            
                            // Children are no longer needed, set them to null
                            // to free memory.
                            currInterm.setChildren(null);
                        }
                        catch (Exception e) {
                            reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                    + appInterm.getLineNr() + ", goal "
                                    + currGoal.node().serialNr() + ", rule "
                                    + appInterm.getRuleName() + NOT_APPLICABLE, e);
                        }
                        catch (AssertionError e) {
                            reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                    + appInterm.getLineNr() + ", goal "
                                    + currGoal.node().serialNr() + ", rule "
                                    + appInterm.getRuleName() + NOT_APPLICABLE, e);
                        }
    
                    }
                    else if (currInterm.getIntermediateRuleApp() instanceof BuiltInAppIntermediate) {
                        BuiltInAppIntermediate appInterm = (BuiltInAppIntermediate) currInterm
                                .getIntermediateRuleApp();
    
                        if (appInterm instanceof JoinAppIntermediate) {
                            JoinAppIntermediate joinAppInterm = (JoinAppIntermediate) appInterm;
                            HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>> partnerNodesInfo = joinPartnerNodes
                                    .get(((JoinAppIntermediate) appInterm).getId());
    
                            if (partnerNodesInfo == null
                                    || partnerNodesInfo.size() < joinAppInterm
                                            .getNrPartners()) {
                                // In case of an exception happening during the replay
                                // process, it can happen that the queue is empty when
                                // reaching this point. Then, we may not add the join
                                // node to the end of the queue since this will result
                                // in non-termination.
                                
                                if (queue.isEmpty()) {
                                    continue;
                                }
                                
                                // Wait until all partners are found: Add node
                                // at the end of the queue. NOTE: DO NOT CHANGE
                                // THIS to adding the node to the front! This will
                                // result in non-termination!
                                queue.addLast(new Pair<Node, NodeIntermediate>(
                                        currNode, currNodeInterm));
                            }
                            else {
                                try {
                                    JoinRuleBuiltInRuleApp joinApp =
                                            (JoinRuleBuiltInRuleApp) constructBuiltinApp(
                                                    joinAppInterm, currGoal);
                                    joinApp.setConcreteRule(JoinProcedure
                                            .getProcedureByName(joinAppInterm
                                                    .getJoinProc()));
                                    joinApp.setDistinguishingFormula(JoinRuleUtils.translateToFormula(
                                            proof.getServices(), joinAppInterm
                                                    .getDistinguishingFormula()));
    
                                    ImmutableList<Triple<Goal, PosInOccurrence, HashMap<ProgramVariable, ProgramVariable>>> joinPartners =
                                            ImmutableSLList.nil();
                                    for (Triple<Node, PosInOccurrence, NodeIntermediate> partnerNodeInfo : partnerNodesInfo) {
                                        final Services services = currGoal.proof().getServices();
                                        
                                        Triple<Term, Term, Term> ownSEState = sequentToSETriple(
                                                currNode, joinApp.posInOccurrence(), services);
                                        Triple<Term, Term, Term> partnerSEState = sequentToSETriple(
                                                partnerNodeInfo.first, partnerNodeInfo.second, services);
                                        ProgramVariablesMatchVisitor matchVisitor = new ProgramVariablesMatchVisitor(
                                                partnerSEState.third.javaBlock().program(), ownSEState.third.javaBlock().program(), services);
                                        matchVisitor.start();
                                        
                                        assert !matchVisitor.isIncompatible() : "Cannot join incompatible program counters";
                                        
                                        joinPartners = joinPartners
                                                .append(new Triple<Goal, PosInOccurrence, HashMap<ProgramVariable, ProgramVariable>>(
                                                        proof.getGoal(partnerNodeInfo.first),
                                                        partnerNodeInfo.second,
                                                        matchVisitor.getMatches().getValue()));
                                    }
    
                                    joinApp.setJoinNode(currNode);
                                    joinApp.setJoinPartners(joinPartners);
    
                                    assert joinApp.complete() : "Join app should be automatically completed in replay";
    
                                    currGoal.apply(joinApp);
    
                                    // Join node has exactly one child in a closed proof, and
                                    // zero or one children in an open proof.
                                    if (currInterm.getChildren().size() > 0) {
                                        queue.addFirst(new Pair<Node, NodeIntermediate>(
                                                currNode.childrenIterator().next(),
                                                currInterm.getChildren().get(0)));
                                    }
    
                                    // Now add children of partner nodes
                                    for (Triple<Node, PosInOccurrence, NodeIntermediate> partnerNodeInfo : partnerNodesInfo) {
                                        Iterator<Node> children = partnerNodeInfo.first
                                                .childrenIterator();
                                        LinkedList<NodeIntermediate> intermChildren = partnerNodeInfo.third
                                                .getChildren();
    
                                        addChildren(children, intermChildren);
                                    }
                                }
                                catch (SkipSMTRuleException e) {
                                    reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                            + appInterm.getLineNr() + ", goal "
                                            + currGoal.node().serialNr() + ", rule "
                                            + appInterm.getRuleName() + NOT_APPLICABLE,
                                            e);
                                }
                                catch (BuiltInConstructionException e) {
                                    reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                            + appInterm.getLineNr() + ", goal "
                                            + currGoal.node().serialNr() + ", rule "
                                            + appInterm.getRuleName() + NOT_APPLICABLE,
                                            e);
                                }
                            }
                        }
                        else if (appInterm instanceof JoinPartnerAppIntermediate) {
                            // Register this partner node
                            JoinPartnerAppIntermediate joinPartnerApp = (JoinPartnerAppIntermediate) appInterm;
                            HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>> partnerNodeInfo = joinPartnerNodes
                                    .get(joinPartnerApp.getJoinNodeId());
    
                            if (partnerNodeInfo == null) {
                                partnerNodeInfo = new HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>>();
                                joinPartnerNodes.put(
                                        joinPartnerApp.getJoinNodeId(),
                                        partnerNodeInfo);
                            }
    
                            partnerNodeInfo
                                    .add(new Triple<Node, PosInOccurrence, NodeIntermediate>(
                                            currNode,
                                            PosInOccurrence.findInSequent(
                                                    currGoal.sequent(),
                                                    appInterm.getPosInfo().first,
                                                    appInterm.getPosInfo().second),
                                            currNodeInterm));
                        }
                        else {
                            try {
                                IBuiltInRuleApp app = constructBuiltinApp(
                                        appInterm, currGoal);
                                if (!app.complete()) {
                                    app = app.tryToInstantiate(currGoal);
                                }
                                currGoal.apply(app);
    
                                final Iterator<Node> children = currNode.childrenIterator();
                                LinkedList<NodeIntermediate> intermChildren = currInterm.getChildren();
    
                                addChildren(children, intermChildren);
                            }
                            catch (SkipSMTRuleException e) {
                                // silently continue; status will be reported via
                                // polling
                            }
                            catch (BuiltInConstructionException e) {
                                reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                        + appInterm.getLineNr() + ", goal "
                                        + currGoal.node().serialNr() + ", rule "
                                        + appInterm.getRuleName() + NOT_APPLICABLE,
                                        e);
                            }
                            catch (RuntimeException e) {
                                reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                        + appInterm.getLineNr() + ", goal "
                                        + currGoal.node().serialNr() + ", rule "
                                        + appInterm.getRuleName() + NOT_APPLICABLE,
                                        e);
                            }
                            catch (AssertionError e) {
                                reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                        + appInterm.getLineNr() + ", goal "
                                        + currGoal.node().serialNr() + ", rule "
                                        + appInterm.getRuleName() + NOT_APPLICABLE,
                                        e);
                            }
                        }
                    }
                }
            } catch (Throwable throwable) {
                // Default exception catcher -- proof should not stop loading
                // if anything goes wrong, but instead continue with the next
                // node in the queue.
                reportError(ERROR_LOADING_PROOF_LINE, throwable);
            }
        }

        return new Result(status, errors, currGoal);
    }

    /**
     * Adds the pairs of proof node children and intermediate children to the
     * queue. At the moment, they are added in the order they were parsed. For
     * the future, it may be sensible to choose a different procedure, for
     * instance one that minimizes the number of open goals per time interval to
     * save memory. Note that in this case, some test cases might be adapted
     * which depend on fixed node serial numbers.
     *
     * @param children
     *            Iterator of proof node children.
     * @param intermChildren
     *            List of corresponding intermediate children.
     */
    private void addChildren(Iterator<Node> children,
            LinkedList<NodeIntermediate> intermChildren) {
        int i = 0;
        while (!currGoal.node().isClosed() && children.hasNext()
                && intermChildren.size() > 0) {

            // NOTE: In the case of an unfinished proof, there
            // is another node after the last application which
            // is not represented by an intermediate
            // application. Therefore, we have to add the last
            // check in the above conjunction.

            Node child = children.next();
            if (!proof.getGoal(child).isLinked()) {
                queue.add(i, new Pair<Node, NodeIntermediate>(child,
                        intermChildren.get(i++)));
            }
        }
    }

    /**
     * Communicates a non-fatal condition to the caller. Empty string means
     * everything is OK. The message will be displayed to the user in the GUI
     * after the proof has been parsed.
     */
    public String getStatus() {
        return status;
    }

    /**
     * @return errors encountered during replay.
     */
    public Collection<Throwable> getErrors() {
        return errors;
    }

    /**
     * Constructs a taclet application from an intermediate one.
     *
     * @param currInterm
     *            The intermediate taclet application to create a "real"
     *            application for.
     * @param currGoal
     *            The goal on which to apply the taclet app.
     * @return The taclet application corresponding to the supplied intermediate
     *         representation.
     * @throws TacletConstructionException
     *             In case of an error during construction.
     */
    private TacletApp constructTacletApp(TacletAppIntermediate currInterm,
            Goal currGoal) throws TacletConstructionException {

        final String tacletName = currInterm.getRuleName();
        final int currFormula = currInterm.getPosInfo().first;
        final PosInTerm currPosInTerm = currInterm.getPosInfo().second;
        final Sequent seq = currGoal.sequent();
        
        TacletApp ourApp = null;
        PosInOccurrence pos = null;

        Taclet t = proof.getInitConfig().lookupActiveTaclet(
                new Name(tacletName));
        if (t == null) {
            ourApp = currGoal.indexOfTaclets().lookup(tacletName);
        }
        else {
            ourApp = NoPosTacletApp.createNoPosTacletApp(t);
        }
        Services services = proof.getServices();

        if (currFormula != 0) { // otherwise we have no pos
            try {
                pos = PosInOccurrence.findInSequent(currGoal.sequent(),
                        currFormula, currPosInTerm);
                ourApp = ((NoPosTacletApp) ourApp).matchFind(pos, services);
                ourApp = ourApp.setPosInOccurrence(pos, services);
            }
            catch (Exception e) {
                throw new TacletConstructionException(
                        "Wrong position information.");
            }
        }

        ourApp = constructInsts(ourApp, currGoal, currInterm.getInsts(), services);

        ImmutableList<IfFormulaInstantiation> ifFormulaList = 
                ImmutableSLList.<IfFormulaInstantiation>nil();
        for (String ifFormulaStr : currInterm.getIfSeqFormulaList()) {
            ifFormulaList = ifFormulaList.append(new IfFormulaInstSeq(seq,
                    Integer.parseInt(ifFormulaStr)));
        }
        for (String ifFormulaStr : currInterm.getIfDirectFormulaList()) {
            ifFormulaList = ifFormulaList.append(new IfFormulaInstDirect(
                    new SequentFormula(parseTerm(ifFormulaStr, proof))));
        }

        //TODO: In certain cases, the below method call returns null and
        // induces follow-up NullPointerExceptions. This was encountered
        // in a proof of the TimSort method binarySort with several joins.
        ourApp = ourApp.setIfFormulaInstantiations(ifFormulaList, services);

        if (!ourApp.complete()) {
            ourApp = ourApp.tryToInstantiate(proof.getServices());
        }

        return ourApp;
    }

    /**
     * Constructs a built-in rule application from an intermediate one.
     *
     * @param currInterm
     *            The intermediate built-in application to create a "real"
     *            application for.
     * @param currGoal
     *            The goal on which to apply the built-in app.
     * @return The built-in application corresponding to the supplied
     *         intermediate representation.
     * @throws SkipSMTRuleException
     *             If the proof has been loaded, but the SMT solvers have not
     *             been run.
     * @throws BuiltInConstructionException
     *             In case of an error during construction.
     */
    private IBuiltInRuleApp constructBuiltinApp(
            BuiltInAppIntermediate currInterm, Goal currGoal)
            throws SkipSMTRuleException, BuiltInConstructionException {

        final String ruleName = currInterm.getRuleName();
        final int currFormula = currInterm.getPosInfo().first;
        final PosInTerm currPosInTerm = currInterm.getPosInfo().second;

        Contract currContract = null;
        ImmutableList<PosInOccurrence> builtinIfInsts = null;

        // Load contracts, if applicable
        if (currInterm.getContract() != null) {
            currContract = proof.getServices().getSpecificationRepository()
                    .getContractByName(currInterm.getContract());
            if (currContract == null) {
                final ProblemLoaderException e = new ProblemLoaderException(
                        loader, "Error loading proof: contract \""
                                + currInterm.getContract() + "\" not found.");
                reportError(ERROR_LOADING_PROOF_LINE + ", goal "
                        + currGoal.node().serialNr() + ", rule " + ruleName
                        + NOT_APPLICABLE, e);
            }
        }

        // Load ifInsts, if applicable
        if (currInterm.getBuiltInIfInsts() != null) {
            builtinIfInsts = ImmutableSLList.nil();
            for (final Pair<Integer, PosInTerm> ifInstP : currInterm.getBuiltInIfInsts()) {
                final int currIfInstFormula         = ifInstP.first;
                final PosInTerm currIfInstPosInTerm = ifInstP.second;

                try {
                    final PosInOccurrence ifInst = PosInOccurrence
                            .findInSequent(currGoal.sequent(),
                                    currIfInstFormula, currIfInstPosInTerm);
                    builtinIfInsts = builtinIfInsts.append(ifInst);
                }
                catch (RuntimeException e) {
                    reportError(
                            ERROR_LOADING_PROOF_LINE + "Line "
                                    + currInterm.getLineNr() + ", goal "
                                    + currGoal.node().serialNr() + ", rule "
                                    + ruleName + NOT_APPLICABLE, e);
                }
                catch (AssertionError e) {
                    reportError(
                            ERROR_LOADING_PROOF_LINE + "Line "
                                    + currInterm.getLineNr() + ", goal "
                                    + currGoal.node().serialNr() + ", rule "
                                    + ruleName + NOT_APPLICABLE, e);
                }
            }
        }

        if (RuleAppSMT.rule.name().toString().equals(ruleName)) {
            boolean error = false;
            final SMTProblem smtProblem = new SMTProblem(currGoal);
            try {
                SMTSettings settings = new SMTSettings(proof.getSettings()
                        .getSMTSettings(),
                        ProofIndependentSettings.DEFAULT_INSTANCE
                                .getSMTSettings(), proof);
                SolverLauncher launcher = new SolverLauncher(settings);
                // launcher.addListener(new SolverListener(settings, proof));
                SolverTypeCollection active = ProofIndependentSettings.DEFAULT_INSTANCE
                        .getSMTSettings().computeActiveSolverUnion();
                ArrayList<SMTProblem> problems = new ArrayList<SMTProblem>();
                problems.add(smtProblem);
                launcher.launch(active.getTypes(), problems,
                        proof.getServices());
            }
            catch (Exception e) {
                error = true;
            }
            if (error
                    || smtProblem.getFinalResult().isValid() != ThreeValuedTruth.VALID) {
                status = "Your proof has been loaded, but SMT solvers have not been run";
                throw new SkipSMTRuleException();
            }
            else {
                return RuleAppSMT.rule.createApp(null, proof.getServices());
            }
        }

        IBuiltInRuleApp ourApp = null;
        PosInOccurrence pos = null;

        if (currFormula != 0) { // otherwise we have no pos
            try {
                pos = PosInOccurrence.findInSequent(currGoal.sequent(),
                        currFormula, currPosInTerm);
            }
            catch (RuntimeException e) {
                throw new BuiltInConstructionException(
                        "Wrong position information.", e);
            }
        }

        if (currContract != null) {
            AbstractContractRuleApp contractApp = null;

            BuiltInRule useContractRule;
            if (currContract instanceof OperationContract) {
                useContractRule = UseOperationContractRule.INSTANCE;
                contractApp = (((UseOperationContractRule) useContractRule)
                        .createApp(pos)).setContract(currContract);
            }
            else {
                useContractRule = UseDependencyContractRule.INSTANCE;
                contractApp = (((UseDependencyContractRule) useContractRule)
                        .createApp(pos)).setContract(currContract);
            }

            if (contractApp.check(currGoal.proof().getServices()) == null) {
                throw new BuiltInConstructionException(
                        "Cannot apply contract: " + currContract);
            }
            else {
                ourApp = contractApp;
            }

            currContract = null;
            if (builtinIfInsts != null) {
                ourApp = ourApp.setIfInsts(builtinIfInsts);
                builtinIfInsts = null;
            }
            return ourApp;
        }

        final ImmutableSet<IBuiltInRuleApp> ruleApps = collectAppsForRule(
                ruleName, currGoal, pos);
        if (ruleApps.size() != 1) {
            if (ruleApps.size() < 1) {
                throw new BuiltInConstructionException(ruleName
                        + " is missing. Most probably the binary "
                        + "for this built-in rule is not in your path or "
                        + "you do not have the permission to execute it.");
            }
            else {
                throw new BuiltInConstructionException(ruleName + ": found "
                        + ruleApps.size()
                        + " applications. Don't know what to do !\n" + "@ "
                        + pos);
            }
        }
        ourApp = ruleApps.iterator().next();
        builtinIfInsts = null;
        return ourApp;
    }

    // ######## Below: Methods previously listed in DefaultProofFileParser

    /**
     * Stores an error in the list.
     *
     * @param string
     *            Description text.
     * @param e
     *            Error encountered.
     */
    private void reportError(String string, Throwable e) {
        status = "Errors while reading the proof. Not all branches could be load successfully.";
        errors.add(new ProblemLoaderException(loader, string, e));
    }

    /**
     * Retrieves all registered applications at the given goal and position for
     * the rule corresponding to the given ruleName.
     *
     * @param ruleName
     *            Name of the rule to find applications for.
     * @param g
     *            Goal to search.
     * @param pos
     *            Position of interest in the given goal.
     * @return All matching rule applications at pos in g.
     */
    private static ImmutableSet<IBuiltInRuleApp> collectAppsForRule(
            String ruleName, Goal g, PosInOccurrence pos) {
        
        ImmutableSet<IBuiltInRuleApp> result = 
                DefaultImmutableSet.<IBuiltInRuleApp> nil();

        for (final IBuiltInRuleApp app : g.ruleAppIndex().getBuiltInRules(g, pos)) {
            if (app.rule().name().toString().equals(ruleName)) {
                result = result.add(app);
            }
        }

        return result;
    }

    /**
     * Instantiates schema variables in the given taclet application.
     *
     * @param app
     *            The taclet application to instantiate.
     * @param currGoal
     *            The corresponding goal.
     * @param loadedInsts
     *            Loaded schema variable instantiations.
     * @param services
     *            The services object.
     * @return The instantiated taclet.
     */
    private static TacletApp constructInsts(TacletApp app, Goal currGoal,
            LinkedList<String> loadedInsts, Services services) {
        if (loadedInsts == null)
            return app;
        ImmutableSet<SchemaVariable> uninsts = app.uninstantiatedVars();

        // first pass: add variables
        for (final String s: loadedInsts) {
            int eq = s.indexOf('=');
            final String varname = s.substring(0, eq);

            SchemaVariable sv = lookupName(uninsts, varname);
            if (sv == null) {
                // throw new IllegalStateException(
                // varname+" from \n"+loadedInsts+"\n is not in\n"+uninsts);
                System.err.println(varname + " from " + app.rule().name()
                        + " is not in uninsts");
                continue;
            }
            final String value = s.substring(eq + 1, s.length());
            if (sv instanceof VariableSV) {
                app = parseSV1(app, sv, value, services);
            }
        }

        // second pass: add everything else
        uninsts = app.uninstantiatedVars();
        for (final String s : loadedInsts) {
            int eq = s.indexOf('=');
            final String varname = s.substring(0, eq);
            final SchemaVariable sv = lookupName(uninsts, varname);
            if (sv == null) {
                continue;
            }

            String value = s.substring(eq + 1, s.length());
            app = parseSV2(app, sv, value, currGoal);
        }

        return app;
    }

    /**
     * Finds a schema variable in the given set.
     *
     * @param set
     *            The set to search.
     * @param name
     *            The name to search for.
     * @return The found schema variable, or null if it is not present in the
     *         set.
     */
    private static SchemaVariable lookupName(ImmutableSet<SchemaVariable> set,
            String name) {
        for (SchemaVariable v : set) {
            if (v.name().toString().equals(name))
                return v;
        }
        return null; // handle this better!
    }

    /**
     * Parses a given term in String representation.
     *
     * @param value
     *            String to parse.
     * @param proof
     *            Proof object (for namespaces and Services object).
     * @param varNS
     *            Variable namespace.
     * @param progVar_ns
     *            Program variable namespace.
     * @return The parsed term.
     * @throws ParserException
     *             In case of an error.
     */
    public static Term parseTerm(String value, Proof proof, Namespace varNS,
            Namespace progVar_ns) {
        try {
            return new DefaultTermParser().parse(new StringReader(value), null,
                    proof.getServices(), varNS, proof.getNamespaces()
                            .functions(), proof.getNamespaces().sorts(),
                    progVar_ns, new AbbrevMap());
        }
        catch (ParserException e) {
            throw new RuntimeException("Error while parsing value " + value
                    + "\nVar namespace is: " + varNS + "\n", e);
        }
    }

    /**
     * Parses a given term in String representation.
     *
     * @param value
     *            String to parse.
     * @param proof
     *            Proof object (for namespaces and Services object).
     * @return The parsed term.
     */
    public static Term parseTerm(String value, Proof proof) {
        return parseTerm(value, proof, proof.getNamespaces().variables(), proof
                .getNamespaces().programVariables());
    }

    /**
     * Instantiates a schema variable in the given taclet application. 1st pass:
     * only VariableSV.
     *
     * @param app
     *            Application to instantiate.
     * @param sv
     *            Schema variable (VariableSV) to instantiate.
     * @param value
     *            Name for the instantiated logic variable.
     * @param services
     *            The services object.
     * @return An instantiated taclet application, where the schema variable has
     *         been instantiated by a logic variable of the given name.
     */
    public static TacletApp parseSV1(TacletApp app, SchemaVariable sv,
            String value, Services services) {
        LogicVariable lv = new LogicVariable(new Name(value), app.getRealSort(
                sv, services));
        Term instance = services.getTermFactory().createTerm(lv);
        return app.addCheckedInstantiation(sv, instance, services, true);
    }

    /**
     * Instantiates a schema variable in the given taclet application. 2nd pass:
     * All other schema variables.
     *
     * @param app
     *            Application to instantiate.
     * @param sv
     *            Schema variable to instantiate.
     * @param value
     *            Name for the instantiated Skolem constant, program element or
     *            term..
     * @param targetGoal
     *            The goal corresponding to the given application.
     * @return An instantiated taclet application, where the schema variable has
     *         been instantiated, depending on its type, by a Skolem constant,
     *         program element, or term of the given name.
     * @see #parseSV1(TacletApp, SchemaVariable, String, Services)
     */
    public static TacletApp parseSV2(TacletApp app, SchemaVariable sv,
            String value, Goal targetGoal) {
        final Proof p = targetGoal.proof();
        final Services services = p.getServices();
        TacletApp result;
        if (sv instanceof VariableSV) {
            // ignore -- already done
            result = app;
        }
        else if (sv instanceof ProgramSV) {
            final ProgramElement pe = app
                    .getProgramElement(value, sv, services);
            result = app.addCheckedInstantiation(sv, pe, services, true);
        }
        else if (sv instanceof SkolemTermSV) {
            result = app.createSkolemConstant(value, sv, true, services);
        }
        else {
            Namespace varNS = p.getNamespaces().variables();
            varNS = app.extendVarNamespaceForSV(varNS, sv);
            Term instance = parseTerm(value, p, varNS,
                   varNS.extended(targetGoal.getGlobalProgVars()));
            result = app.addCheckedInstantiation(sv, instance, services, true);
        }
        return result;
    }
    
    /**
     * Signals an error during construction of a taclet app.
     */
    static class TacletConstructionException extends Exception {
        private static final long serialVersionUID = 7859543482157633999L;

        TacletConstructionException(String s) {
            super(s);
        }

        TacletConstructionException(Throwable cause) {
            super(cause);
        }
    }

    /**
     * Signals an error during construction of a built-in rule app.
     */
    static class BuiltInConstructionException extends Exception {
        private static final long serialVersionUID = -735474220502290816L;

        BuiltInConstructionException(String s) {
            super(s);
        }

        BuiltInConstructionException(Throwable cause) {
            super(cause);
        }

        public BuiltInConstructionException(String s, Throwable cause) {
            super(s, cause);
        }
    }

    /**
     * Signals that the execution of an SMT solver, that has been used before
     * the now loaded proof was saved, has been skipped.
     */
    static class SkipSMTRuleException extends Exception {
        private static final long serialVersionUID = -2932282883810135168L;
    }

    /**
     * Simple structure containing the results of the replay procedure.
     *
     * @author Dominic Scheurer
     */
    static class Result {
        private String status;
        private List<Throwable> errors;
        private Goal lastSelectedGoal = null;

        public Result(String status, List<Throwable> errors,
                Goal lastSelectedGoal) {
            this.status = status;
            this.errors = errors;
            this.lastSelectedGoal = lastSelectedGoal;
        }

        public String getStatus() {
            return status;
        }

        public List<Throwable> getErrors() {
            return errors;
        }

        public Goal getLastSelectedGoal() {
            return lastSelectedGoal;
        }
    }
}
