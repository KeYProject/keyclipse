package de.uka.ilkd.key.rule;

import java.util.ArrayList;

import org.key_project.util.collection.ImmutableList;

import de.uka.ilkd.key.java.KeYJavaASTFactory;
import de.uka.ilkd.key.java.ProgramElement;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.Statement;
import de.uka.ilkd.key.java.StatementBlock;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.statement.LoopScopeBlock;
import de.uka.ilkd.key.java.statement.While;
import de.uka.ilkd.key.logic.JavaBlock;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.label.TermLabelManager;
import de.uka.ilkd.key.logic.label.TermLabelState;
import de.uka.ilkd.key.logic.op.Modality;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.rule.metaconstruct.ReplaceWhileLoop;

/**
 * <p>
 * Implementation of the "<strong>loop scope invariant</strong>" rule as
 * proposed in the PhD thesis by <em>Nathan Wasser</em>.
 * </p>
 * <p>
 * Basically, the preserves and use case part are combined in one formula; the
 * loop is transformed to an if statement including a trailing continue, and
 * wrapped in an "indexed loop scope". The index of the loop scope, a
 * {@link ProgramVariable}, will be set to TRUE if the loop is left and to FALSE
 * if it isn't.
 * </p>
 * <p>
 * Thus, all cases of loop exit, as breaks, returns, "pure" leaving and
 * exceptional behavior, are handled (with some very simple additional taclets
 * setting the index variable according to the situation, thereby eliminating
 * the loop scope).
 * </p>
 * 
 * <pre>
 * \Gamma ==> {U}Inv, \Delta
 * \Gamma, {U'}Inv ==> \Delta, {U'}[\pi
 *    boolean x = false;
 *    loop-scope(x){
 *      if(nse) l1: ... ln:  { p continue; }
 *    } \omega]
 *    ((x = TRUE -> \phi) & (x = FALSE -> Inv))
 * ------------------------------------------------------------------- loopInvariant
 * \Gamma ==> {U}[\pi l1: ... ln: while (nse) { p } \omega]\phi, Delta
 * </pre>
 *
 * @author Dominic Scheurer
 */
public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
    /**
     * The number of goals generated by the {@link LoopScopeInvariantRule}.
     */
    private static final int NR_GOALS = 2;

    /**
     * The Singleton instance of {@link LoopScopeInvariantRule}.
     */
    public static final LoopScopeInvariantRule INSTANCE = new LoopScopeInvariantRule();

    /**
     * The hint used to refactor the initial invariant.
     */
    public static final String INITIAL_INVARIANT_ONLY_HINT = "onlyInitialInvariant";

    /**
     * The hint used to refactor the full invariant.
     */
    public static final String FULL_INVARIANT_TERM_HINT = "fullInvariant";

    private static final Name NAME = new Name("Loop (Scope) Invariant");

    @Override
    public Name name() {
        return NAME;
    }

    @Override
    public int getNrOfGoals() {
        return NR_GOALS;
    }

    @Override
    public ImmutableList<Goal> apply(Goal goal, Services services,
            RuleApp ruleApp) throws RuleAbortException {
        // Initial assertions
        assert ruleApp instanceof LoopInvariantBuiltInRuleApp;

        LoopInvariantInformation loopInvInfo = doPreparations(goal, services,
                ruleApp);

        ImmutableList<Goal> goals = loopInvInfo.goals;
        Goal initiallyGoal = goals.tail().head();
        Goal preservesGoal = goals.head();

        // Create the "Initially" goal
        constructInitiallyGoal(loopInvInfo.services, loopInvInfo.ruleApp,
                loopInvInfo.termLabelState, initiallyGoal, loopInvInfo.inst,
                loopInvInfo.invTerm, loopInvInfo.reachableState);

        // Create the "Invariant Preserved and Use Case" goal
        constructPresrvAndUCGoal(loopInvInfo.services, loopInvInfo.ruleApp,
                preservesGoal, loopInvInfo.inst, loopInvInfo.anonUpdate,
                loopInvInfo.wellFormedAnon, loopInvInfo.uAnonInv,
                loopInvInfo.frameCondition, loopInvInfo.variantPO,
                loopInvInfo.termLabelState, loopInvInfo.invTerm,
                loopInvInfo.uBeforeLoopDefAnonVariant);

        return goals;
    }

    // -------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------

    /**
     * Singleton constructor.
     */
    private LoopScopeInvariantRule() {
    }

    // -------------------------------------------------------------------------
    // helper methods for apply()
    // -------------------------------------------------------------------------

    /**
     * Sets the content of the "initially valid" goal.
     * 
     * @param services
     *            The {@link Services} object.
     * @param ruleApp
     *            The {@link RuleApp} for this {@link LoopScopeInvariantRule}
     *            application.
     * @param termLabelState
     *            The {@link TermLabelState}.
     * @param initiallyGoal
     *            The {@link Goal} containing the "initially valid" PO.
     * @param inst
     *            The {@link Instantiation} of parameters for the
     *            {@link LoopScopeInvariantRule} app.
     * @param invTerm
     *            The loop invariant formula.
     * @param reachableState
     *            The reachable state formula.
     */
    private void constructInitiallyGoal(Services services, RuleApp ruleApp,
            final TermLabelState termLabelState, Goal initiallyGoal,
            final Instantiation inst, final Term invTerm, Term reachableState) {
        initiallyGoal.setBranchLabel("Invariant Initially Valid");
        initiallyGoal
                .changeFormula(
                        initFormula(termLabelState, inst, invTerm,
                                reachableState, services, initiallyGoal),
                        ruleApp.posInOccurrence());
    }

    /**
     * Creates the "Invariant Preserved and Used" goal subsuming the former
     * preserved and use case goals.
     * 
     * @param services
     *            The {@link Services} object.
     * @param ruleApp
     *            The {@link LoopInvariantBuiltInRuleApp} object for the current
     *            rule application.
     * @param presrvAndUCGoal
     *            The {@link Goal} to serve as container for the new sequent.
     * @param inst
     *            The {@link Instantiation} of parameters for the
     *            {@link LoopScopeInvariantRule} app.
     * @param anonUpdate
     *            The anonymized update {@link Term}.
     * @param wellFormedAnon
     *            The wellformed formula.
     * @param uAnonInv
     *            A formula containing the anonymized update and the loop
     *            invariant.
     * @param frameCondition
     *            The frame condition.
     * @param variantPO
     *            The proof obligation for the variant.
     * @param termLabelState
     *            The {@link TermLabelState}.
     * @param invTerm
     *            The loop invariant formula.
     * @param uBeforeLoopDefAnonVariant
     *            An array containing the original update, the "before the loop"
     *            update for reasoning about the variant, the anonymized update,
     *            and the variant update.
     */
    private void constructPresrvAndUCGoal(Services services, RuleApp ruleApp,
            Goal presrvAndUCGoal, final Instantiation inst, Term anonUpdate,
            Term wellFormedAnon, final Term uAnonInv, Term frameCondition,
            Term variantPO, TermLabelState termLabelState, Term invTerm,
            Term[] uBeforeLoopDefAnonVariant) {
        final While loop = inst.loop;

        final Term newFormula = formulaWithLoopScope(services, inst, anonUpdate,
                loop, frameCondition, variantPO, termLabelState,
                presrvAndUCGoal, uBeforeLoopDefAnonVariant, invTerm);

        presrvAndUCGoal.setBranchLabel("Invariant Preserved and Used");
        presrvAndUCGoal.addFormula(new SequentFormula(uAnonInv), true, false);
        presrvAndUCGoal.addFormula(new SequentFormula(wellFormedAnon), true,
                false);
        presrvAndUCGoal.changeFormula(new SequentFormula(newFormula),
                ruleApp.posInOccurrence());
    }

    // -------------------------------------------------------------------------
    // internal methods
    // -------------------------------------------------------------------------

    /**
     * Creates the variable used as a loop scope index.
     * 
     * @param services
     *            The {@link Services} object.
     * @return The variable used as a loop scope index.
     */
    private ProgramVariable loopScopeIdxVar(Services services) {
        final KeYJavaType booleanType = services.getJavaInfo()
                .getKeYJavaType("boolean");

        final ProgramVariable loopScopeIdxVar = //
                KeYJavaASTFactory
                        .localVariable( //
                                services.getVariableNamer()
                                        .getTemporaryNameProposal("x"),
                                booleanType);

        return loopScopeIdxVar;
    }

    /**
     * Creates the new program with the loop scope.
     * 
     * @param services
     *            The {@link Services} object.
     * @param loop
     *            The original {@link While} loop that is going to be replaced.
     * @param origProg
     *            The whole original program, starting with the {@link While}
     *            loop.
     * @param loopScopeIdxVar
     *            The variable used as a loop scope index.
     * @return The new program with the loop scope.
     */
    private ProgramElement newProgram(Services services, final While loop,
            final JavaBlock origProg, final ProgramVariable loopScopeIdxVar) {
        final ArrayList<ProgramElement> stmnt = new ArrayList<ProgramElement>();

        ((StatementBlock) loop.getBody()).getBody()
                .forEach(elem -> stmnt.add(elem));
        stmnt.add(KeYJavaASTFactory.continueStatement(null));

        final Statement newIf = KeYJavaASTFactory.ifThen(
                loop.getGuardExpression(),
                new StatementBlock(stmnt.toArray(new Statement[stmnt.size()])));

        LoopScopeBlock loopScope = new LoopScopeBlock(loopScopeIdxVar,
                KeYJavaASTFactory.block(newIf));

        final ReplaceWhileLoop rplLoopVisitor = new ReplaceWhileLoop(
                origProg.program(),
                KeYJavaASTFactory.block(KeYJavaASTFactory.declare(
                        loopScopeIdxVar, KeYJavaASTFactory.falseLiteral()),
                        loopScope),
                services);
        rplLoopVisitor.start();

        return rplLoopVisitor.result();
    }

    /**
     * Creates the {@link SequentFormula} for the "initially valid" goal.
     * 
     * @param termLabelState
     *            The {@link TermLabelState}.
     * @param inst
     *            The {@link Instantiation} for this rule application.
     * @param invTerm
     *            The invariant formula.
     * @param reachableState
     *            The reachable state formula.
     * @param services
     *            The {@link Services} object.
     * @param initGoal
     *            The goal containing the "initially valid" PO.
     * @return The {@link SequentFormula} for the "initially valid" goal.
     */
    private SequentFormula initFormula(TermLabelState termLabelState,
            Instantiation inst, final Term invTerm, Term reachableState,
            Services services, Goal initGoal) {
        final TermBuilder tb = services.getTermBuilder();

        Term sfTerm = tb.apply(inst.u, tb.and(invTerm, reachableState), null);
        sfTerm = TermLabelManager.refactorTerm(termLabelState, services, null,
                sfTerm, this, initGoal, INITIAL_INVARIANT_ONLY_HINT, null);

        return new SequentFormula(sfTerm);
    }

    /**
     * Creates the actual formula by which the original formula containing the
     * loop is replaced in the "preserves and use case" branch.
     * 
     * @param services
     *            The {@link Services} object.
     * @param inst
     *            The {@link Instantiation} of parameters for the
     *            {@link LoopScopeInvariantRule} app.
     * @param anonUpdate
     *            The anonymized update {@link Term}.
     * @param loop
     *            The original {@link While} loop that is going to be replaced.
     * @param frameCondition
     *            The frame condition formula.
     * @param variantPO
     *            The proof obligation for the variant.
     * @param termLabelState
     *            The {@link TermLabelState}.
     * @param presrvAndUCGoal
     *            The {@link Goal} starting the new "preserves and use case"
     *            branch.
     * @param uBeforeLoopDefAnonVariant
     *            An array containing the original update, the "before the loop"
     *            update for reasoning about the variant, the anonymized update,
     *            and the variant update.
     * @param invTerm
     *            The loop invariant formula {@link Term}.
     * @return The formula by which the original formula containing the loop is
     *         replaced in the "preserves and use case" branch.
     */
    private Term formulaWithLoopScope(Services services,
            final Instantiation inst, Term anonUpdate, final While loop,
            Term frameCondition, Term variantPO, TermLabelState termLabelState,
            Goal presrvAndUCGoal, final Term[] uBeforeLoopDefAnonVariant,
            Term invTerm) {
        final TermBuilder tb = services.getTermBuilder();
        final Term progPost = splitUpdates(inst.progPost, services).second;

        Term fullInvariant = tb.and(invTerm, frameCondition, variantPO);
        fullInvariant = TermLabelManager.refactorTerm(termLabelState, services,
                null, fullInvariant, this, presrvAndUCGoal,
                FULL_INVARIANT_TERM_HINT, null);

        final Term post = progPost.sub(0);
        final Modality modality = (Modality) progPost.op();
        final JavaBlock origJavaBlock = progPost.javaBlock();

        final ProgramVariable loopScopeIdxVar = loopScopeIdxVar(services);

        final ProgramElement newProg = newProgram(services, loop, origJavaBlock,
                loopScopeIdxVar);

        final Term newPost = tb.and(
                tb.imp(tb.equals(tb.var(loopScopeIdxVar), tb.TRUE()), post),
                tb.imp(tb.equals(tb.var(loopScopeIdxVar), tb.FALSE()),
                        fullInvariant));

        final Term newFormula = tb.applySequential(uBeforeLoopDefAnonVariant,
                tb.prog(modality,
                        JavaBlock.createJavaBlock((StatementBlock) newProg),
                        newPost));
        return newFormula;
    }

}
