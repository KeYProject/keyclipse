parser grammar KeYParser options {tokenVocab=KeYLexer; k=1; } ;
top : a= formula ;
decls : ( one_include_statement )* ( options_choice )? ({...}? => option_decls |{...}? => sort_decls |{...}? => prog_var_decls |{...}? => schema_var_decls | pred_decls | func_decls | transform_decls |{...}? => ruleset_decls )* ;
one_include_statement : ( INCLUDE | ( INCLUDELDTS ) ) one_include[ldts] ( COMMA one_include[ldts] )* SEMI ;
one_include[boolean ldt] : (absfile= IDENT |relfile= string_literal ) ;
options_choice : ( WITHOPTIONS activated_choice ( COMMA activated_choice )* SEMI ) ;
activated_choice : cat= IDENT COLON choice_= IDENT ;
option_decls : OPTIONSDECL LBRACE ( choice SEMI )* RBRACE ;
choice : category= IDENT ( COLON LBRACE choice_option[cat] ( COMMA choice_option[cat] )* RBRACE )? ;
choice_option[String cat] : choice_= IDENT ;
sort_decls : SORTS LBRACE (multipleSorts= one_sort_decl )* RBRACE ;
one_sort_decl returns [ImmutableList<Sort> createdSorts = ImmutableSLList.<Sort>nil()] : ( GENERIC sortIds= simple_ident_comma_list ( ONEOF sortOneOf= oneof_sorts )? ( EXTENDS sortExt= extends_sorts )? | PROXY sortIds= simple_ident_comma_list ( EXTENDS sortExt= extends_sorts )? | ( ABSTRACT )? firstSort= simple_ident_dots ( ( EXTENDS sortExt= extends_sorts ) | ( ( COMMA ) sortIds= simple_ident_comma_list ) )? ) SEMI ;
simple_ident_dots returns [ String ident = ""; ] : id= simple_ident ( DOT (id= simple_ident |num= NUM_LITERAL ) )* ;
extends_sorts returns [Sort[] extendsSorts = null] : s= any_sortId_check[!skip_sorts] ( COMMA s= any_sortId_check[!skip_sorts] )* ;
oneof_sorts returns [Sort[] oneOfSorts = null] : LBRACE s= sortId_check[true] ( COMMA s= sortId_check[true] )* RBRACE ;
keyjavatype returns [KeYJavaType kjt=null] : type= simple_ident_dots ( EMPTYBRACKETS )* ;
prog_var_decls : PROGRAMVARIABLES LBRACE (kjt= keyjavatype var_names= simple_ident_comma_list SEMI )* RBRACE ;
string_literal returns [String lit = null] : id= STRING_LITERAL ;
simple_ident returns [String ident = null] : id= IDENT ;
simple_ident_comma_list returns [ImmutableList<String> ids = ImmutableSLList.<String>nil()] : id= simple_ident ( COMMA id= simple_ident )* ;
schema_var_decls : SCHEMAVARIABLES LBRACE ( one_schema_var_decl )* RBRACE ;
one_schema_var_decl : ( ( MODALOPERATOR one_schema_modal_op_decl SEMI ) | ( ( PROGRAM ( schema_modifiers[mods] )? id= simple_ident ( LBRACKET nameString= simple_ident EQUALS parameter= simple_ident_dots RBRACKET )? ids= simple_ident_comma_list | FORMULA ( schema_modifiers[mods] )? ids= simple_ident_comma_list | TERMLABEL ( schema_modifiers[mods] )? ids= simple_ident_comma_list | UPDATE ( schema_modifiers[mods] )? ids= simple_ident_comma_list | SKOLEMFORMULA ( schema_modifiers[mods] )? ids= simple_ident_comma_list | ( TERM ( schema_modifiers[mods] )? | ( ( VARIABLES | VARIABLE ) ( schema_modifiers[mods] )? ) | ( SKOLEMTERM ( schema_modifiers[mods] )? ) ) s= any_sortId_check[true] ids= simple_ident_comma_list ) SEMI ) );
schema_modifiers[SchemaVariableModifierSet mods] : LBRACKET opts= simple_ident_comma_list RBRACKET ;
one_schema_modal_op_decl : ( LPAREN sort= any_sortId_check[true] RPAREN )? LBRACE ids= simple_ident_comma_list RBRACE id= simple_ident ;
pred_decl : pred_name= funcpred_name (whereToBind= where_to_bind )? argSorts= arg_sorts[!skip_predicates] SEMI ;
pred_decls : PREDICATES LBRACE ( pred_decl )* RBRACE ;
location_ident returns [int kind = NORMAL_NONRIGID] : id= simple_ident ;
func_decl : ( UNIQUE )? retSort= any_sortId_check[!skip_functions] func_name= funcpred_name (whereToBind= where_to_bind )? argSorts= arg_sorts[!skip_functions] SEMI ;
func_decls : FUNCTIONS LBRACE ( func_decl )* RBRACE ;
arg_sorts_or_formula[boolean checkSort] returns [Sort[] argSorts = null] : ( LPAREN (s= sortId_check[checkSort] | FORMULA ) ( COMMA (s= sortId_check[checkSort] | FORMULA ) )* RPAREN )? ;
transform_decl : (retSort= any_sortId_check[!skip_transformers] | FORMULA ) trans_name= funcpred_name argSorts= arg_sorts_or_formula[!skip_transformers] SEMI ;
transform_decls : TRANSFORMERS LBRACE ( transform_decl )* RBRACE ;
arrayopid returns [KeYJavaType _array_op_id = null] : EMPTYBRACKETS LPAREN componentType= keyjavatype RPAREN ;
arg_sorts[boolean checkSort] returns [Sort[] argSorts = null] : ( LPAREN s= sortId_check[checkSort] ( COMMA s= sortId_check[checkSort] )* RPAREN )? ;
where_to_bind returns [Boolean[] result = null] : LBRACE ( TRUE | FALSE ) ( COMMA ( TRUE | FALSE ) )* RBRACE ;
ruleset_decls : HEURISTICSDECL LBRACE (id= simple_ident SEMI )* RBRACE ;
sortId returns [Sort _sort_id = null] : s= sortId_check[true] ;
sortId_check[boolean checkSort] returns [Sort _sort_id_check = null] : p= sortId_check_help[checkSort] s= array_decls[p, checkSort] ;
any_sortId_check[boolean checkSort] returns [Sort _any_sort_id_check = null] : p= any_sortId_check_help[checkSort] s= array_decls[p, checkSort] ;
sortId_check_help[boolean checkSort] returns [Pair<Sort,Type> _sort_id_check_help = null] : result= any_sortId_check_help[checkSort] ;
any_sortId_check_help[boolean checkSort] returns [Pair<Sort,Type> result = null] : name= simple_sort_name ;
array_decls[Pair<Sort,Type> p, boolean checksort] returns [Sort s = null] : ( EMPTYBRACKETS )* ;
id_declaration returns [ IdDeclaration idd = null ] : id= IDENT ( COLON s= sortId_check[true] )? ;
funcpred_name returns [String result = null] : ( ( sort_name DOUBLECOLON LESS )=> (prefix= sort_name DOUBLECOLON LESS name= simple_ident GREATER ) | ( sort_name DOUBLECOLON )=> (prefix= sort_name DOUBLECOLON name= simple_ident ) | (prefix= simple_ident ) );
simple_sort_name returns [String name = ""] : id= simple_ident_dots ;
sort_name returns [String _sort_name = null] : name= simple_sort_name (brackets= EMPTYBRACKETS )* ;
formula returns [Term _formula = null] : a= term ;
term returns [Term _term = null] : result= elementary_update_term ( PARALLEL a= elementary_update_term )* ;
termEOF returns [Term _term = null] : result= term EOF ;
elementary_update_term returns [Term _elementary_update_term=null] : result= equivalence_term ( ASSIGN a= equivalence_term )? ;
equivalence_term returns [Term _equivalence_term = null] : a= implication_term ( EQV a1= implication_term )* ;
implication_term returns [Term _implication_term = null] : a= disjunction_term ( IMP a1= implication_term )? ;
disjunction_term returns [Term _disjunction_term = null] : a= conjunction_term ( OR a1= conjunction_term )* ;
conjunction_term returns [Term _conjunction_term = null] : a= term60 ( AND a1= term60 )* ;
term60 returns [Term _term_60 = null] : (a= unary_formula |a= equality_term );
unary_formula returns [Term _unary_formula = null] : ( NOT a1= term60 |a= quantifierterm |a= modality_dl_term );
equality_term returns [Term _equality_term = null] : a= logicTermReEntry ( ( EQUALS | NOT_EQUALS )=> ( EQUALS | NOT_EQUALS ) a1= logicTermReEntry )? ;
relation_op returns [Function op = null] : ( LESS | LESSEQUAL | GREATER | GREATEREQUAL ) ;
weak_arith_op returns [Function op = null] : ( PLUS | MINUS ) ;
strong_arith_op returns [Function op = null] : ( STAR | SLASH | PERCENT ) ;
logicTermReEntry returns [Term _logic_term_re_entry = null] : a= weak_arith_op_term ( ( relation_op )=>op= relation_op a1= weak_arith_op_term )? ;
weak_arith_op_term returns [Term _weak_arith_op_term = null] : a= strong_arith_op_term ( ( weak_arith_op )=>op= weak_arith_op a1= strong_arith_op_term )* ;
strong_arith_op_term returns [Term _strong_arith_op_term = null] : a= term110 ( ( strong_arith_op )=>op= strong_arith_op a1= term110 )* ;
term110 returns [Term _term110 = null] : (result= braces_term |result= accessterm ) ;
staticAttributeOrQueryReference returns [String attrReference = ""] : id= IDENT ( EMPTYBRACKETS )* ;
static_attribute_suffix returns [Term result = null] : attributeName= staticAttributeOrQueryReference ;
attribute_or_query_suffix[Term prefix] returns [Term _attribute_or_query_suffix = null] : DOT ( STAR | (memberName= attrid (result= query_suffix[prefix, memberName] )? ) ) ;
attrid returns [String attr = "";] : (id= simple_ident | LPAREN clss= sort_name DOUBLECOLON id2= simple_ident RPAREN );
query_suffix[Term prefix, String memberName] returns [Term result = null] : args= argument_list ;
accessterm returns [Term _accessterm = null] : ( ( MINUS ~ NUM_LITERAL )=> MINUS result= term110 | ( LPAREN any_sortId_check[false] RPAREN term110 )=> LPAREN s= any_sortId_check[true] RPAREN result= term110 | ({...}?result= static_query |{...}?result= static_attribute_suffix |result= atom ) (abs= accessterm_bracket_suffix[result] |result= attribute_or_query_suffix[result] )* (result= heap_selection_suffix[result] )? );
heap_selection_suffix[Term term] returns [Term result] : AT heap= accessterm ;
accessterm_bracket_suffix[Term reference] returns [Term result, boolean increaseHeapSuffixCounter] : ({...}?tmp= heap_update_suffix[reference] |{...}?tmp= seq_get_suffix[reference] |tmp= array_access_suffix[reference] );
seq_get_suffix[Term reference] returns [Term result] : LBRACKET indexTerm= logicTermReEntry RBRACKET ;
static_query returns [Term result = null] : queryRef= staticAttributeOrQueryReference args= argument_list ;
heap_update_suffix[Term heap] returns [Term result=heap] : LBRACKET ( ( equivalence_term ASSIGN )=>target= equivalence_term ASSIGN val= equivalence_term |id= simple_ident args= argument_list ) RBRACKET ;
array_access_suffix[Term arrayReference] returns [Term _array_access_suffix = null] : LBRACKET ( STAR |indexTerm= logicTermReEntry ( ( DOTRANGE )=> DOTRANGE rangeTo= logicTermReEntry )? ) RBRACKET ;
atom returns [Term _atom = null] : ({...}?a= specialTerm |a= funcpredvarterm | LPAREN a= term RPAREN | TRUE | FALSE |a= ifThenElseTerm |a= ifExThenElseTerm |literal= STRING_LITERAL ) ( LGUILLEMETS labels= label RGUILLEMETS )? ;
label returns [ImmutableArray<TermLabel> labels = new ImmutableArray<TermLabel>()] : l= single_label ( COMMA l= single_label )* ;
single_label returns [TermLabel label=null] : (name= IDENT |star= STAR ) ( LPAREN param1= STRING_LITERAL ( COMMA param2= STRING_LITERAL )* RPAREN )? ;
abbreviation returns [Term _abbreviation=null] : (sc= simple_ident ) ;
ifThenElseTerm returns [Term _if_then_else_term = null] : IF LPAREN condF= term RPAREN THEN LPAREN thenT= term RPAREN ELSE LPAREN elseT= term RPAREN ;
ifExThenElseTerm returns [Term _if_ex_then_else_term = null] : IFEX exVars= bound_variables LPAREN condF= term RPAREN THEN LPAREN thenT= term RPAREN ELSE LPAREN elseT= term RPAREN ;
argument returns [Term _argument = null] : ({...}?result= term |result= term60 ) ;
quantifierterm returns [Term _quantifier_term = null] : ( FORALL | EXISTS ) vs= bound_variables a1= term60 ;
braces_term returns [Term _update_or_substitution = null] : ( ( LBRACE SUBST )=>result= substitutionterm | ( LBRACE ( LPAREN | RBRACE ) )=>result= locset_term |result= updateterm );
locset_term returns [Term result = getServices().getTermBuilder().empty()] : LBRACE (l= location_term ( COMMA l= location_term )* )? RBRACE ;
location_term returns [Term result] : LPAREN obj= equivalence_term COMMA field= equivalence_term RPAREN ;
substitutionterm returns [Term _substitution_term = null] : LBRACE SUBST v= one_bound_variable SEMI a1= logicTermReEntry RBRACE (a2= term110 |a2= unary_formula ) ;
updateterm returns [Term _update_term = null] : LBRACE u= term RBRACE (a2= term110 |a2= unary_formula ) ;
bound_variables returns [ImmutableList<QuantifiableVariable> list = ImmutableSLList.<QuantifiableVariable>nil()] : var= one_bound_variable ( COMMA var= one_bound_variable )* SEMI ;
one_bound_variable returns [QuantifiableVariable _one_bound_variable=null] : ({...}?v= one_logic_bound_variable_nosort |{...}?v= one_schema_bound_variable |{...}?v= one_logic_bound_variable );
one_schema_bound_variable returns [QuantifiableVariable v=null] : id= simple_ident ;
one_logic_bound_variable returns [QuantifiableVariable v=null] : s= sortId id= simple_ident ;
one_logic_bound_variable_nosort returns [QuantifiableVariable v=null] : id= simple_ident ;
modality_dl_term returns [Term _modality_dl_term = null] : modality= MODALITY ({...}?a1= term60 ) ;
argument_list returns [Term[] _argument_list = null] : LPAREN (p1= argument ( COMMA p2= argument )* )? RPAREN ;
funcpredvarterm returns [Term _func_pred_var_term = null] : (ch= CHAR_LITERAL | ( ( MINUS )? NUM_LITERAL )=> ( MINUS )? number= NUM_LITERAL | AT a= abbreviation |varfuncid= funcpred_name ( (~ LBRACE | LBRACE bound_variables )=> ( LBRACE boundVars= bound_variables RBRACE )? args= argument_list )? );
specialTerm returns [Term _special_term = null] :{...}?result= metaTerm ;
arith_op returns [String op = null] : ( PERCENT | STAR | MINUS | SLASH | PLUS );
varId returns [ParsableVariable v = null] : id= IDENT ;
varIds returns [LinkedList list = new LinkedList()] : ids= simple_ident_comma_list ;
triggers[TacletBuilder b] : TRIGGER LBRACE id= simple_ident RBRACE t= term ( AVOID avoidCond= term ( COMMA avoidCond= term )* )? SEMI ;
taclet[ImmutableSet<Choice> choices, boolean axiomMode] returns [Taclet r] : ( LEMMA )? name= IDENT (choices_= option_list[choices_] )? LBRACE ( ( formula RBRACE )=>form= formula | ( SCHEMAVAR one_schema_var_decl )* ( ASSUMES LPAREN ifSeq= seq RPAREN )? ( FIND LPAREN find= termorseq RPAREN ( SAMEUPDATELEVEL | INSEQUENTSTATE | ANTECEDENTPOLARITY | SUCCEDENTPOLARITY )* )? ( VARCOND LPAREN varexplist[b] RPAREN )? goalspecs[b, find != null] modifiers[b] ) RBRACE ;
modifiers[TacletBuilder b] : (rs= rulesets | NONINTERACTIVE | DISPLAYNAME dname= string_literal | HELPTEXT htext= string_literal | triggers[b] )* ;
seq returns [Sequent s] : ant= semisequent SEQARROW suc= semisequent ;
seqEOF returns [Sequent s] : ss= seq EOF ;
termorseq returns [Object o] : (head= term ( COMMA s= seq | SEQARROW ss= semisequent )? | SEQARROW ss= semisequent );
semisequent returns [Semisequent _semi_sequent] : (|head= term ( COMMA ss= semisequent )? );
varexplist[TacletBuilder b] : varexp[b] ( COMMA varexp[b] )* ;
varexp[TacletBuilder b] : ( ( varcond_applyUpdateOnRigid[b] | varcond_dropEffectlessElementaries[b] | varcond_dropEffectlessStores[b] | varcond_enum_const[b] | varcond_free[b] | varcond_hassort[b] | varcond_fieldtype[b] | varcond_equalUnique[b] | varcond_new[b] | varcond_newlabel[b] | varcond_observer[b] | varcond_different[b] | varcond_metadisjoint[b] | varcond_simplifyIfThenElseUpdate[b] | varcond_differentFields[b] | varcond_sameObserver[b] ) | ( ( NOT_ )? ( varcond_abstractOrInterface[b, negated] | varcond_array[b, negated] | varcond_array_length[b, negated] | varcond_enumtype[b, negated] | varcond_freeLabelIn[b,negated] | varcond_localvariable[b, negated] | varcond_thisreference[b, negated] | varcond_reference[b, negated] | varcond_referencearray[b, negated] | varcond_static[b,negated] | varcond_staticmethod[b,negated] | varcond_mayexpandmethod[b,negated] | varcond_final[b,negated] | varcond_typecheck[b, negated] | varcond_constant[b, negated] | varcond_label[b, negated] | varcond_static_field[b, negated] | varcond_subFormulas[b, negated] | varcond_containsAssignment[b, negated] ) ) );
varcond_sameObserver[TacletBuilder b] : SAME_OBSERVER LPAREN t1= varId COMMA t2= varId RPAREN ;
varcond_applyUpdateOnRigid[TacletBuilder b] : APPLY_UPDATE_ON_RIGID LPAREN u= varId COMMA x= varId COMMA x2= varId RPAREN ;
varcond_dropEffectlessElementaries[TacletBuilder b] : DROP_EFFECTLESS_ELEMENTARIES LPAREN u= varId COMMA x= varId COMMA result= varId RPAREN ;
varcond_dropEffectlessStores[TacletBuilder b] : DROP_EFFECTLESS_STORES LPAREN h= varId COMMA o= varId COMMA f= varId COMMA x= varId COMMA result= varId RPAREN ;
varcond_differentFields[TacletBuilder b] : DIFFERENTFIELDS LPAREN x= varId COMMA y= varId RPAREN ;
varcond_simplifyIfThenElseUpdate[TacletBuilder b] : SIMPLIFY_IF_THEN_ELSE_UPDATE LPAREN phi= varId COMMA u1= varId COMMA u2= varId COMMA commonFormula= varId COMMA result= varId RPAREN ;
type_resolver returns [TypeResolver tr = null] : ( (s= any_sortId_check[true] ) | ( TYPEOF LPAREN y= varId RPAREN ) | ( CONTAINERTYPE LPAREN y= varId RPAREN ) );
varcond_new[TacletBuilder b] : NEW LPAREN x= varId COMMA ( TYPEOF LPAREN y= varId RPAREN | DEPENDINGON LPAREN y= varId RPAREN |kjt= keyjavatype ) RPAREN ;
varcond_newlabel[TacletBuilder b] : NEWLABEL LPAREN x= varId RPAREN ;
varcond_typecheck[TacletBuilder b, boolean negated] : ( SAME | ISSUBTYPE | STRICT ISSUBTYPE | DISJOINTMODULONULL ) LPAREN fst= type_resolver COMMA snd= type_resolver RPAREN ;
varcond_free[TacletBuilder b] : NOTFREEIN LPAREN x= varId COMMA ys= varIds RPAREN ;
varcond_hassort[TacletBuilder b] : HASSORT LPAREN (x= varId | ELEMSORT LPAREN x= varId RPAREN ) COMMA s= any_sortId_check[true] RPAREN ;
varcond_fieldtype[TacletBuilder b] : FIELDTYPE LPAREN x= varId COMMA s= any_sortId_check[true] RPAREN ;
varcond_containsAssignment[TacletBuilder b, boolean negated] : CONTAINS_ASSIGNMENT LPAREN x= varId RPAREN ;
varcond_enumtype[TacletBuilder b, boolean negated] : ISENUMTYPE LPAREN tr= type_resolver RPAREN ;
varcond_reference[TacletBuilder b, boolean isPrimitive] : ISREFERENCE ( LBRACKET id= simple_ident RBRACKET )? LPAREN tr= type_resolver RPAREN ;
varcond_thisreference[TacletBuilder b, boolean negated] : ISTHISREFERENCE LPAREN x= varId RPAREN ;
varcond_staticmethod[TacletBuilder b, boolean negated] : STATICMETHODREFERENCE LPAREN x= varId COMMA y= varId COMMA z= varId RPAREN ;
varcond_mayexpandmethod[TacletBuilder b, boolean negated] : MAXEXPANDMETHOD LPAREN x= varId COMMA y= varId ( COMMA z= varId RPAREN | RPAREN ) ;
varcond_referencearray[TacletBuilder b, boolean primitiveElementType] : ISREFERENCEARRAY LPAREN x= varId RPAREN ;
varcond_array[TacletBuilder b, boolean negated] : ISARRAY LPAREN x= varId RPAREN ;
varcond_array_length[TacletBuilder b, boolean negated] : ISARRAYLENGTH LPAREN x= varId RPAREN ;
varcond_abstractOrInterface[TacletBuilder b, boolean negated] : IS_ABSTRACT_OR_INTERFACE LPAREN tr= type_resolver RPAREN ;
varcond_enum_const[TacletBuilder b] : ENUM_CONST LPAREN x= varId RPAREN ;
varcond_final[TacletBuilder b, boolean negated] : FINAL LPAREN x= varId RPAREN ;
varcond_static[TacletBuilder b, boolean negated] : STATIC LPAREN x= varId RPAREN ;
varcond_localvariable[TacletBuilder b, boolean negated] : ISLOCALVARIABLE LPAREN x= varId RPAREN ;
varcond_observer[TacletBuilder b] : ISOBSERVER LPAREN obs= varId COMMA heap= varId RPAREN ;
varcond_different[TacletBuilder b] : DIFFERENT LPAREN var1= varId COMMA var2= varId RPAREN ;
varcond_metadisjoint[TacletBuilder b] : METADISJOINT LPAREN var1= varId COMMA var2= varId RPAREN ;
varcond_equalUnique[TacletBuilder b] : EQUAL_UNIQUE LPAREN t= varId COMMA t2= varId COMMA phi= varId RPAREN ;
varcond_freeLabelIn[TacletBuilder b, boolean negated] : FREELABELIN LPAREN l= varId COMMA statement= varId RPAREN ;
varcond_constant[TacletBuilder b, boolean negated] : ISCONSTANT LPAREN x= varId RPAREN ;
varcond_label[TacletBuilder b, boolean negated] : HASLABEL LPAREN l= varId COMMA name= simple_ident RPAREN ;
varcond_static_field[TacletBuilder b, boolean negated] : ISSTATICFIELD LPAREN field= varId RPAREN ;
varcond_subFormulas[TacletBuilder b, boolean negated] : HASSUBFORMULAS LPAREN x= varId RPAREN ;
goalspecs[TacletBuilder b, boolean ruleWithFind] : ( CLOSEGOAL | goalspecwithoption[b, ruleWithFind] ( SEMI goalspecwithoption[b, ruleWithFind] )* );
goalspecwithoption[TacletBuilder b, boolean ruleWithFind] : ( (soc= option_list[soc] LBRACE goalspec[b,soc,ruleWithFind] RBRACE ) | goalspec[b,null,ruleWithFind] ) ;
option returns [Choice c=null] : cat= IDENT COLON choice_= IDENT ;
option_list[ImmutableSet<Choice> soc] returns [ImmutableSet<Choice> result = null] : LPAREN c= option ( COMMA c= option )* RPAREN ;
goalspec[TacletBuilder b, ImmutableSet<Choice> soc, boolean ruleWithFind] : (name= string_literal COLON )? ( (rwObj= replacewith (addSeq= add )? (addRList= addrules )? (addpv= addprogvar )? ) | (addSeq= add (addRList= addrules )? ) | (addRList= addrules ) ) ;
replacewith returns [Object _replace_with] : REPLACEWITH LPAREN o= termorseq RPAREN ;
add returns [Sequent _add] : ADD LPAREN s= seq RPAREN ;
addrules returns [ImmutableList<Taclet> _add_rules] : ADDRULES LPAREN lor= tacletlist RPAREN ;
addprogvar returns [ImmutableSet<SchemaVariable> _add_prog_var] : ADDPROGVARS LPAREN pvs= pvset RPAREN ;
tacletlist returns [ImmutableList<Taclet> _taclet_list] : head= taclet[DefaultImmutableSet.<Choice>nil(), false] (| COMMA lor= tacletlist ) ;
pvset returns [ImmutableSet<SchemaVariable> _pv_set] : pv= varId (| COMMA pvs= pvset ) ;
rulesets returns [Vector rs = new Vector()] : HEURISTICS LPAREN ruleset[rs] ( COMMA ruleset[rs] )* RPAREN ;
ruleset[Vector rs] : id= IDENT ;
metaId returns [TermTransformer v = null] : id= simple_ident ;
metaTerm returns [Term result = null] : (vf= metaId ( LPAREN t= term ( COMMA t= term )* RPAREN )? ) ;
contracts : CONTRACTS LBRACE ( one_contract )* RBRACE ;
invariants : INVARIANTS LPAREN selfVar= one_logic_bound_variable RPAREN LBRACE ( one_invariant[(ParsableVariable)selfVar] )* RBRACE ;
one_contract : contractName= simple_ident LBRACE ( prog_var_decls )? fma= formula MODIFIES modifiesClause= term RBRACE SEMI ;
one_invariant[ParsableVariable selfVar] : invName= simple_ident LBRACE fma= formula ( DISPLAYNAME displayName= string_literal )? RBRACE SEMI ;
skipBracedBlock : LBRACE RBRACE ;
problem returns [ Term _problem = null ] : profile (pref= preferences ) string= bootClassPath stlist= classPaths string= javaSource decls ( contracts )* ( invariants )* ( ( RULES | AXIOMS ) (choices= option_list[choices] )? ({...}? => skipBracedBlock | LBRACE (s= taclet[choices, axiomMode] SEMI )* RBRACE ) )* ( ( PROBLEM LBRACE a= formula RBRACE ) | CHOOSECONTRACT (chooseContract= string_literal SEMI )? | PROOFOBLIGATION (proofObligation= string_literal SEMI )? )? ;
bootClassPath returns [String _boot_class_path = null] : ( BOOTCLASSPATH id= string_literal SEMI )? ;
classPaths returns [ImmutableList<String> ids = ImmutableSLList.<String>nil()] : ( ( CLASSPATH s= string_literal ( COMMA s= string_literal )* SEMI ) | ( NODEFAULTCLASSES SEMI ) )* ;
javaSource returns [String _java_source = null] : ( JAVASOURCE result= oneJavaSource SEMI )? ;
oneJavaSource returns [String s = null] : (l= string_literal | SLASH | COLON | BACKSLASH )+ ;
profile : ( PROFILE profileName= string_literal SEMI )? ;
preferences returns [String _preferences = null] : ( KEYSETTINGS LBRACE (s= string_literal )? RBRACE )? ;
proofScript returns [ Triple<String, Integer, Integer> locatedString = null ] : PROOFSCRIPT ps= STRING_LITERAL ;
proof[IProofFileParser prl] : ( PROOF proofBody[prl] )? ;
proofBody[IProofFileParser prl] : LBRACE ( pseudosexpr[prl] )+ RBRACE ;
pseudosexpr[IProofFileParser prl] : LPAREN (proofElementId= expreid (str= string_literal )? ( pseudosexpr[prl] )* )? RPAREN ;
expreid returns [ IProofFileParser.ProofElementID proofElementId = null ] : id= simple_ident ;
synpred1_KeYParser : sort_name DOUBLECOLON LESS ;
synpred2_KeYParser : sort_name DOUBLECOLON ;
synpred3_KeYParser : ( EQUALS | NOT_EQUALS );
synpred4_KeYParser : relation_op ;
synpred5_KeYParser : weak_arith_op ;
synpred6_KeYParser : strong_arith_op ;
synpred7_KeYParser : MINUS ~ NUM_LITERAL ;
synpred8_KeYParser : LPAREN any_sortId_check[false] RPAREN term110 ;
synpred9_KeYParser : equivalence_term ASSIGN ;
synpred10_KeYParser : DOTRANGE ;
synpred11_KeYParser : LBRACE SUBST ;
synpred12_KeYParser : LBRACE ( LPAREN | RBRACE ) ;
synpred13_KeYParser : ( MINUS )? NUM_LITERAL ;
synpred14_KeYParser : (~ LBRACE | LBRACE bound_variables );
synpred15_KeYParser : formula RBRACE ;
