<html>
   <head>
      <title>JML</title>
      <link rel="stylesheet" href="css/book.css" type="text/css">
   </head>
   <body>
      <h1>JML</h1>
      <p>
         The <a href="http://www.jmlspecs.org" target="_blank">Java Modeling Language (JML)</a> is a specification language used to specify the expected behavior of Java modules.
      </p>
      <p>
         The relevant knowledge for this evaluation about JML is explained in the following sections.
         <b>Please read them carefully before you continue.</b>
         If you are familiar with JML, you can skip sections you know well.
         <ul>
            <li><a href="#comments">1 JML Comments</a></li>
            <li><a href="#mc">2 Method Contracts</a></li>
            <li><a href="#invariants">3 Class Invariants</a></li>
            <li><a href="#loop">4 Loop Invariants</a></li>
            <li><a href="#aliasing">5 Aliasing and Assignable</a></li>
            <li><a href="#JMLtoJavaDL">6 From JML to Java Dynamic Logic</a></li>
         </ul>
      </p>
      
      <h2><a name="comments">1 JML Comments</a></h2>
      <p>
         JML specifications are placed as special comments within the Java source code.
         Such comments have to start with the <code>@</code> character.
         JML comments used in this evaluation look as follows:
         <code>
         <pre>
/*@ ...
  @ ... 
  @*/</pre></code>
      </p>

      <h2><a name="mc">2 Method Contracts</a></h2>
      <p>
         A method contract specifies the expected behavior of a method in terms of pre- and postconditions.
         Assuming that the precondition is fulfilled when the method is called, the method guarantees that the postcondition is established when it returns.
         In JML the keywords <code>normal_behavior</code> and <code>exceptional_behavior</code> are used to specify that a method should terminate normally without a thrown exception or exceptionally otherwise.
         Keyword <code>requires</code> followed by a boolean expression defines a precondition while <code>ensures</code> also followed by a boolean expression defines a postcondition.
         An expression is basically a normal Java expression as used for instance in <code>if</code> statements.
         But additionally the implication operator <code>==></code> and quantifiers (e.g. <code>\forall</code>) can be used.
      </p>
      <p>
         The ensures clause makes a statement about the final state after method execution.
         To express changes relative to the prestate before method invocation, the keyword <code>\old</code> can be used.
         Keyword <code>\result</code> is used to refer to the method return value.
      </p>
      <p>
         The last part of a method contract is the assignable clause.
         It lists all locations the method is allowed to change. 
         Keyword <code>\nothing</code> expresses that the method is not allowed to change any location.
      </p>
      <p>
         Consider the following example. 
         The method contract of <code>addCredits</code> says that the method should be called in a state in which <code>credits</code> is greater than zero (<code>requires</code>).
         Then the method will guarantee that no exception is thrown (<code>normal_behavior</code>) and that the value of <code>acquiredCredits</code> is increased by <code>credits</code> (first <code>ensures</code>).
         It also guarantees that the returned value is the new value of <code>acquiredCredits</code> (second <code>ensures</code>).
         At last, the <code>assignable</code> clause says that only <code>acquiredCredits</code> and no other locations like <code>firstname</code> or <code>surname</code> are allowed to be changed by the method.
         <code>
         <pre>
public class Student {
   private /*@ nullable @*/ String firstname;
   
   private /*@ non_null @*/ String surname;

   private int acquiredCredits = 0;
   
   /*@ normal_behavior
     @ requires credits > 0;
     @ ensures acquiredCredits == \old(acquiredCredits) + credits;
     @ ensures \result == acquiredCredits;
     @ assignable acquiredCredits;
     @*/
   public int addCredits(int credits) {
      acquiredCredits += credits;
      return acquiredCredits;
   }
}</pre></code>
      </p>
      <p>
         For method parameters as well as for instance and class fields with a reference type its ability to be <code>null</code> needs to be specified.
         Keyword <code>nullable</code> allows the <code>null</code> value while <code>non_null</code> forbids it.
         In the example above, <code>firstname</code> might be <code>null</code> while <code>surname</code> will be never <code>null</code>.
      </p>

      <h2><a name="invariants">3 Class Invariants</a></h2>
      <p>
         An invariant is a property used to limit the possible state space of instances.
         All Constructors of a class have to establish the invariant while all methods have to preserve it.
         It can only be broken temporary within a method execution.
         Technically, an invariant can be seen as pre and postcondition added to all method contracts.
      </p>
      <p>
         Let us add the following invariant to class <code>Student</code>.
         It says that the value of <code>acquiredCredits</code> is never negative.
         <code>
         <pre>
/*@ invariant acquiredCredits >= 0;
  @*/
private int acquiredCredits = 0;</pre></code>
      </p>

      <h2><a name="loop">4 Loop Invariants</a></h2>
      <p>
         A loop invariant is a property which needs to hold before a loop is entered
         and which is preserved by each loop iteration (loop guard and loop body). 
         Thus it also holds after the loop. 
      </p>
      <p>
         A loop invariant in JML consists of three parts:
         <ul>
            <li>Keyword <code>loop_invariant</code> is used to specify a loop invariant.</li>
            <li>Keyword <code>decreasing</code> specifies a value which is always positive and strictly decreased in each loop iteration. It is used to prove termination of the loop.</li>
            <li>Keyword <code>assignable</code> limits the locations may changed by the loop.</li>
         </ul> 
      </p>
      <p>
         The following example restricts with the first loop invariant the range of index variable <code>i</code>.
         The second loop invariant ensures that all already visited array elements are assigned with the array index.
         Termination can be proven with help of the array length and the index variable (<code>decreasing</code> term).
         Finally, the loop can change all fields of <code>array</code> (but not <code>array</code> itself) and <code>i</code>.
         <code>
         <pre>
public static void fillArray(int[] array) {
   /*@ loop_invariant i >= 0 && i <= array.length;
     @ loop_invariant (\forall int j; j >= 0 && j < i; array[j] == j);
     @ decreasing array.length - i;
     @ assignable array[*], i;
     @*/      
   for (int i = 0; i < array.length; i++) {
      array[i] = i;
   }
}</pre></code>
      </p>

      <h2><a name="aliasing">5 Aliasing and Assignable</a></h2>
      <p>
         Listed instance fields in the assignable clause give the right to change its values independent from the way how the object is accessed.
      </p>
      <p>
         Consider for instance the following example. The parameters <code>a</code> and <code>b</code> are aliased (they point to the same object)
         as expressed by the precondition <code>a == b</code>. The implementation fulfills the specification, 
         although the specification allows only to change instance field <code>acquiredCredits</code> on <code>b</code> while the implementation
         changes it on <code>a</code>.
      </p>
          <pre>
/*@ normal_behavior
  @ requires a == b;
  @ assignable b.acquiredCredits;
  @*/
public static void doNothing(Student a, Student b) {
   a.acquiredCredits = b.acquiredCredits;
}</pre></code>

      <h2><a name="JMLtoJavaDL">6 From JML to Java Dynamic Logic</a></h2>
      <p>
         To verify if a Java program adheres to its JML specification, KeY translates both into a formula in <i>Java Dynamic Logic</i>.
         Java Dynamic Logic is also used by the Symbolic Execution Debugger (SED) to present results.
      </p>
      <p>
         This section gives a short introduction about how to read Java Dynamic Logic.
      </p>
      <p>
         For the actual verification, KeY uses a Gentzen-style sequent calculus. 
         The main data structure of such a calculus is a sequent like the following:
         <pre><code>
         A, B ==> C, D
         </code></pre>
         It can be read as:
         Assuming that all formulas on the left side (<code>A</code> and <code>B</code>) of the sequent arrow <code>==></code> hold, at least one formula on the right side (<code>C</code> or <code>D</code>) needs to hold.
         The left side contains typically preconditions to assume while the right side contains postconditions to be proven.
      </p>      
      <p>      
         The following figure shows on the left the source code from <a href="#mc">Section 2</a> and on the right the initial sequent generated by KeY to verify the correctness of method <code>addCredits</code>.
         Boxes are used to map the Java/JML constructs to their representation in Java Dynamic Logic. 
      </p>      
      <img src="JML/KeY_PO.png">
   </body>
</html>