// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2009 Universitaet Karlsruhe Germany
//                         Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//


// This file contains rules for handling java programs


\include assertions;


\optionsDecl{
  initialisation:{disableStaticInitialisation, enableStaticInitialisation};
}

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
  \generic GOS \extends Object;
  \generic alphaObj \extends Object;
  \generic betaObj \extends Object;
}

\schemaVariables {
 \modalOperator { diamond, box } #allmodal;

 \formula post, inv, post1;
 \program Type #t, #t2 ;
 \program NonPrimitiveType #npit ;  

 \term G q ;
 \skolemTerm G queryValue, sk ;

 \program ArrayLength #length ;
 
 \program MultipleVariableDeclaration #multvardecl ;
 \program ArrayPostDeclaration #arraypost ;
 \program SimpleExpression #se, #se0, #se1 ;
 \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;

 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program Variable #loc ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1 ;

 \program ConstantVariable #cv ;   // variables that are compile-time constants
 \program Variable #b0, #ar1 ;
 \program VariableInitializer #vi ;
 \program SimpleExpression #seBool,#seBool0,#seBool1,#seBool2 ;
 \program JavaBooleanExpression #exBool,#exBool0,#exBool1,#exBool2 ;

 \program NonSimpleExpression #nseBool,#nseBool0,#nseBool1,#nseBool2 ;
 \program Statement #s, #s0, #s1 ;
 \program LoopInit #loopInit ;
 \program Guard #guard ;
 \program ForUpdates #forupdates ;
 \program ForLoop #forloop ;
 \program Expression #e, #e0, #e1, #e2 ;
 \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;

 \program[list] Statement #slist, #slist1, #slist2, #slist3 ;
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 \program[list] Catch #cs ;

 \program Switch #sw ;
 \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
 \program NonSimpleMethodReference #nsmr ;
 \program NonModelMethodBody #mb;
 \program MethodName #mn;
 \program PureMethodBody #pmb;

 \program ExecutionContext #ex, #ex1 ; 

 \formula anon1, anon2, anon3;
 
 \formula for1,for2;

 \program Literal #lit ;

 \variables int iv, iv2, iv3 ;
 \term int idx;

 // generic sorts
 \term G variant ;
 \term GOS array;
 \term H obj ;

 \variables G x ;
 \term H then, else ;
 
 \term G updatedTerm1, updatedTerm2;

 \formula inReachableStateSV;
}


\predicates{   
   arrayStoreValid(any, any);
}


\rules(programRules:Java) {

  inReachableStatePO { \find (==> inReachableStateSV) 
                   \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
                   \replacewith (==> inReachableState & 
                          #createInReachableStatePO(inReachableStateSV) ) 
                   \addrules ( insert_hidden { \add (==> inReachableStateSV) } )
//                   \heuristics ( simplify )
  };  
  
  inReachableStateExpand { \find (inReachableStateSV ==>) 
  		    \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
  		    \replacewith( inReachableState -> 
                              #createInReachableStatePO(inReachableStateSV) ==> ) 
                    \addrules (insert_hidden { \add (inReachableStateSV ==>) })
                    \heuristics ( inReachableStateExpandAntec )
  };  
  
  inReachableStateRewrite { \assumes (inReachableState ==>)
                    \find (inReachableStateSV) \sameUpdateLevel
  		    \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
  		    \replacewith( inReachableStateSV |
                                  #createInReachableStatePO(inReachableStateSV))
                    \heuristics ( inReachableStateExpandRewrite )
  };  
  
  emptyModality { \find (\modality{#allmodal}{}\endmodality(post)) 
                  \replacewith(post) 
                  \heuristics(simplify_prog) 
                  \oldname "empty_modality"
                };

  returnUnfold { \find (\modality{#allmodal}{.. return #nse; ...}\endmodality(post)) 
       \varcond(\new(#v0, \typeof(#nse))) 	
       \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; return #v0; ...}\endmodality(post)) 
       \heuristics(simplify_prog)
       \displayname "returnUnfold"
       \oldname "eval_return_not_simple"}; 


//-----------------------------------------------------------------------------------------
//                        some common assignment rules 
//-----------------------------------------------------------------------------------------

  assignment_local  { \find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
                      \varcond(\isLocalVariable(#loc))
                      \replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post)) 
	              \heuristics(simplify_prog, simplify_prog_subset)};
		      
  assignment_this { \find (\modality{#allmodal}{.#t(#v).. this.#loc = #se; ...}\endmodality(post))
                           \varcond(\not \isLocalVariable(#loc), \not \static(#loc))
                           \replacewith ({heap:=store(heap,#v,#memberPVToField(#loc),#se)}\modality{#allmodal}{.. ...}\endmodality(post)) 
	                   \heuristics(simplify_prog, simplify_prog_subset)};
	                   
  assignment_static { \find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
                             \varcond(\static(#loc))
                             \replacewith ({heap:=store(heap,null,#memberPVToField(#loc),#se)}\modality{#allmodal}{.. ...}\endmodality(post)) 
	                     \heuristics(simplify_prog, simplify_prog_subset)};	                   

	
  // skip index check as the case below can only happen in an implicit method
  assignment_write_array_this_access_normalassign{
		\find (\modality{#allmodal}{.#t(#v).. this[#se]=#se0; ...}\endmodality(post))
		"Normal Execution":
			\replacewith(( lt(#se,int::select(heap,#v,Array::length)) & lt(-1,#se)) ->   
			{heap:=store(heap, #v, arr(#se), #se0)}\modality{#allmodal}{.. ...}\endmodality(post))
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};


  // skip index check as the case below can only happen in an implicit method
  eval_array_this_access{
		\find (\modality{#allmodal}{.. this[#nse]=#se0; ...}\endmodality(post))
                \varcond(\new(#v0, \typeof(#nse))) 
  		\replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; this[#v0]=#se0; ...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "eval_array_access"};


//---------- rules for array store ---------------//


   array_self_reference {	 
        \assumes (inReachableState ==> array = null)
	\find (arrayStoreValid(array, G::select(heap, array, arr(idx)))) 
	\sameUpdateLevel
	\replacewith(true)
	\heuristics(simplify)
   };

   null_can_always_be_stored_in_a_reference_type_array {
        \assumes (==> array = null)
	\find (arrayStoreValid(array, null)) \sameUpdateLevel
	\varcond(\isReferenceArray(array))
	\replacewith(true)
	\heuristics(simplify)
   };

   array_store_known_dynamic_array_type {
        // no guard necessary as <get> always not null	
	\find (arrayStoreValid(G::<get>(idx), obj))	
	\varcond (\isReference(G))
	\replacewith(#arrayBaseInstanceOf(G::<get>(idx), obj) = TRUE | obj = null)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };
   
   
/*   array_store_known_dynamic_array_type_prim {
	\find (arrayStoreValid(G::<get>(idx), vint_val))	
        \varcond(\isReference(G))
	\replacewith(#arrayBaseInstanceOf(G::<get>(idx), vint_val) = TRUE)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };
  */ 
   
   array_store_known_dynamic_array_type_2 {
	\assumes (J::exactInstance(array) = TRUE ==>)
	\find (arrayStoreValid(array, obj)) \sameUpdateLevel
	\varcond (\isReference[non_null](J))
	\replacewith(obj = null | 
	    #arrayBaseInstanceOf(J::exactInstance(array), obj) = TRUE)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };

// ------------ dynamic types ------------------ //

  /*  // will be uncommented soon 
       dynamic_type_for_null {
	  \find (G::exactInstance(null) = TRUE ==>)
	  \varcond(G not Null) // Woj: parser doesn't allow this at the moment
	  \replacewith(false)
	};

        dynamic_type_definition {
	\find (J::exactInstance(array) = TRUE) \sameUpdateLevel
	\varcond (\isReferenceArray(array), \notFreeIn(k, array))
	\replacewith(\exists k; (geq(k,0) & reach[#t.#nextToCreate](#t.#nextFirst, array, k)))
   };*/


//--------------- variable declarations --------------------------------------//

// local_variable_rename   { \find (\<{.. {#t #v0; #s} ...}\>post) 
//              \varcond (#v1 \new)
//              \replacewith( {#v1 #v0}\<{.. {#v0 #v1}{#s} ...}\>post) };

  //reviewed 04/19/2004, St.S.
  variableDeclaration { \find (\modality{#allmodal}{.. #t #v0; ...}\endmodality(post)) 
		        \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                        \addprogvars(#v0) 
                        \heuristics(simplify_prog, simplify_prog_subset)
                        \displayname "variableDeclaration"
			\oldname "eliminate_variable_declaration"
  };

  variableDeclarationFinal { \find (\modality{#allmodal}{.. final #t #v0; ...}\endmodality(post)) 
		             \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                             \addprogvars(#v0) 
                             \heuristics(simplify_prog, simplify_prog_subset)
                             \displayname "variableDeclaration"
			     \oldname "eliminate_variable_declaration_final"
  };
  
  variableDeclarationGhost { \find (\modality{#allmodal}{.. ghost #t #v0; ...}\endmodality(post)) 
		             \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                             \addprogvars(#v0) 
                             \heuristics(simplify_prog, simplify_prog_subset)
                             \displayname "ghostDeclaration"
  };
  

 variableDeclarationAssign  { \find (\modality{#allmodal}{.. #t #v0 = #vi; ...}\endmodality(post))
                              \replacewith (\modality{#allmodal}{.. #t #v0; #v0 = #vi; ...}\endmodality(post))
                              \heuristics(simplify_prog, simplify_prog_subset)
                              \displayname "variableDeclaration"
			      \oldname "variable_declaration_allmodal"};

 variableDeclarationFinalAssign { \find (\modality{#allmodal}{.. final #t #v0 = #vi; ...}\endmodality(post))
                                  \replacewith (\modality{#allmodal}{.. final #t #v0; #v0 = #vi; ...}\endmodality(post))
                                  \heuristics(simplify_prog, simplify_prog_subset)
                                  \displayname "variableDeclaration"
				  \oldname "variable_declaration_allmodal_final"};
				  
 variableDeclarationGhostAssign { \find (\modality{#allmodal}{.. ghost #t #v0 = #vi; ...}\endmodality(post))
                                  \replacewith (\modality{#allmodal}{.. ghost #t #v0; #set #v0 = #vi; ...}\endmodality(post))
                                  \heuristics(simplify_prog, simplify_prog_subset)
                                  \displayname "ghostDeclaration"};
				  

 variableDeclarationMult { \find (\modality{#allmodal}{.. #multvardecl ...}\endmodality(post)) 
			   \replacewith (\modality{#allmodal}{.. #resolve-multiple-var-decl(#multvardecl); ...}\endmodality(post)) 
			   \heuristics(simplify_prog, simplify_prog_subset)
                           \displayname "variableDeclaration"
			   \oldname "multiple_variable_declaration"};

 array_post_declaration { \find (\modality{#allmodal}{.. #arraypost ...}\endmodality(post)) 
				\replacewith (\modality{#allmodal}{.. 
				                         #array-post-declaration(#arraypost);
                                                       ...}\endmodality(post)) 
				\heuristics(simplify_prog,
				simplify_prog_subset)};

//--------------- try-statement ----------------------------------------------//

 throwNull
	   { \find (\modality{#allmodal}{.. throw null; ...}\endmodality(post))
             \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
             \displayname "throwNull"
	     \oldname "throw_evaluate_null"};

 throwUnfold   { \find (\modality{#allmodal}{.. throw #nse; ...}\endmodality(post))
	            \varcond(\new(#v0, \typeof(#nse))) 
            	    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse; throw #v0; ...}\endmodality(post))
                    \heuristics(simplify_prog) \noninteractive
 		    \displayname "throwUnfold"
		    \oldname "throw_evaluate_non_simple"};

// VERIFY this rule:

throwLabel {
    \find (\modality{#allmodal}{.. #lb: throw #se; ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "throw_label"
};

throwLabelBlock {
    \find (\modality{#allmodal}{.. #lb: { throw #se; #slist } ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "throw_label_block"
};

throwBox { 
    \find (\modality{box}{ throw #se; #slist }\endmodality(post))
    \replacewith(true)
    \heuristics(simplify_prog)
    \oldname "throw_single_partial"
};

throwDiamond { 
    \find (\modality{diamond}{ throw #se; #slist }\endmodality(post))
    \replacewith(false)
    \heuristics(simplify_prog)
    \oldname "throw_single_total"
};


 tryCatchThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               catch ( #t #v0 ) { #slist1 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                            try { throw new java.lang.NullPointerException (); }
                            catch ( #t #v0 ) { #slist1 }
                      } else if ( #se instanceof #t ) {
                            #t #v0;
                            #v0 = #se;
                            #slist1
                      } else {
                            throw #se;
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchThrow"
    \oldname "try_throw_single_ignore_trail" };

 tryMultipleCatchThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               catch ( #t #v0 ) { #slist1 }
               catch ( #t2 #v1 ) { #slist3 }
               catch #cs ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           try { throw new java.lang.NullPointerException (); }
                           catch ( #t #v0 ) { #slist1 }
                           catch ( #t2 #v1 ) { #slist3 }
                           catch #cs
                      } else if ( #se instanceof #t ) {
                           #t #v0;
                           #v0 = #se;
                           #slist1
                      } else {
                           try { throw #se; }
                           catch ( #t2 #v1 ) { #slist3 }
                           catch #cs
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchThrow"
    \oldname "try_throw_multiple_ignore_trail" };

 tryCatchFinallyThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist}
               catch ( #t #v0 ) { #slist1 }
               catch #cs
               finally { #slist2 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           try { throw new java.lang.NullPointerException (); }
                           catch ( #t #v0 ) { #slist1 }
                           catch #cs
                           finally { #slist2 }
                      } else if ( #se instanceof #t ) {
                           try {
                              #t #v0;
                              #v0 = #se;
                              #slist1
                           } finally { #slist2 }
                      } else {
                           try { throw #se; }
                           catch #cs
                           finally { #slist2 }
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchFinallyThrow"
    \oldname "try_finally_throw_ignore_trail" };

// Should the NullPointerException be created before executing #slist2 ?
 tryFinallyThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               finally { #slist2 } ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#se)))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           { #slist2 }
                           throw new java.lang.NullPointerException ();
                      } else {
                           #typeof(#se) #v0 = #se;
                           { #slist2 }
                           throw #v0;
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryFinallyThrow"
    \oldname "try_only_finally_throw_ignore_trail" };

 tryEmpty   { \find (\modality{#allmodal}{.. try {} #cs ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "try_empty" };

 tryFinallyEmpty {
    \find (\modality{#allmodal}{.. try {}
               catch #cs
               finally { #slist2 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. { #slist2 }  ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryEmpty"
    \oldname "try_finally_empty" };

 tryBreakLabel {
    \find (\modality{#allmodal}{.. try { break #lb; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. break #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_break_1" };

 tryFinallyBreakLabel {
    \find (\modality{#allmodal}{.. try { break #lb; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } break #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_finally_break_1" };

 tryBreak {
    \find (\modality{#allmodal}{.. try { break; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. break; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_break_2" };

 tryFinallyBreak {
    \find (\modality{#allmodal}{.. try { break; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } break; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_finally_break_2" };

/*
 try_continue_1 {
    \find (\modality{#allmodal}{.. try { continue #lb; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. continue #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_finally_continue_1 {
    \find (\modality{#allmodal}{.. try { continue #lb; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } continue #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_continue_2 {
    \find (\modality{#allmodal}{.. try { continue; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. continue; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_finally_continue_2 {
    \find (\modality{#allmodal}{.. try { continue; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } continue; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };
*/

 tryReturn {
    \find (\modality{#allmodal}{.. try { return #se; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. return #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_return_1" };

 tryFinallyReturn {
    \find (\modality{#allmodal}{.. try { return #se; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#se)))
    \replacewith (\modality{#allmodal}{.. #typeof(#se) #v0 = #se;
                      { #slist2 }
                      return #v0; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_finally_return_1" };

 tryReturnNoValue {
    \find (\modality{#allmodal}{.. try { return; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. return; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_return_2" };

 tryFinallyReturnNoValue {
    \find (\modality{#allmodal}{.. try { return; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } return; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_finally_return_2" };


//------------------------------------------------------------------------
// ----------- Rules for prefix and postfix increment and decrement operators
//------------------------------------------------------------------------

  //reviewed 04/16/2004, St.S.
 preincrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = ++#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #lhs1; 
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = ++#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0=#v.#attribute;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //new 06/12/2008, BW
 preincrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = ++#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v[#v0];
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement     { \find (\modality{#allmodal}{.. ++#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement_attribute     { \find (\modality{#allmodal}{.. ++#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};
             
  //new 06/12/2008, BW
 preincrement_array     { \find (\modality{#allmodal}{.. ++#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
				#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};             

  //reviewed 04/16/2004, St.S.
 predecrement     { \find (\modality{#allmodal}{.. --#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement_attribute     { \find (\modality{#allmodal}{.. --#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};
             
  //new 06/12/2008, BW
 predecrement_array     { \find (\modality{#allmodal}{.. --#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
		#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};             
 
  //reviewed 04/16/2004, St.S.
 predecrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = --#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #lhs1; ...}\endmodality(post)) 
            \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs = --#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs = #v.#attribute;
             ...}\endmodality(post)) \heuristics(simplify_expression)};
             
  //new 06/12/2008, BW
 predecrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = --#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v[#v0];
             ...}\endmodality(post)) \heuristics(simplify_expression)};             

  //reviewed 06/23/2005, St.S.
 postincrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = #lhs1++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #v;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = #e.#attribute++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = #e[#e0]++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement     { \find (\modality{#allmodal}{.. #lhs1++; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement_attribute     { \find (\modality{#allmodal}{.. #e.#attribute++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement_array     { \find (\modality{#allmodal}{.. #e[#e0]++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
				#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement     { \find (\modality{#allmodal}{.. #lhs1--; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))#lhs1-1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement_attribute     { \find (\modality{#allmodal}{.. #e.#attribute--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement_array     { \find (\modality{#allmodal}{.. #e[#e0]--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
		#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = #lhs1--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #v; ...}\endmodality(post)) 
            \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = #e.#attribute--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = #e[#e0]--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

// boolean cast
 castToBoolean {
    \find(\modality{#allmodal}{.. #lhs = (boolean) #exBool; ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. #lhs = #exBool; ...}\endmodality(post))
    \heuristics(simplify_prog)
 };



//-----------------------------------------------------------------------------------------//
//--------------- reference type casts  ---------------------------------------------------//
//-----------------------------------------------------------------------------------------//


 // implementation of the rules for type casts defined in the Java language 
 // specification, chapter 5.5. We assume that no compile-time error occurred.
 
 // null can be cast to any type

 compound_reference_cast_expression { \find (\modality{#allmodal}{.. #lhs = (#npit) #nse; ...}\endmodality(post))
                       \varcond (\new(#v, \typeof(#nse)))
                       \replacewith ( \modality{#allmodal}{.. #typeof(#nse) #v = #nse;
		                                   #lhs = (#npit) #v;
                                                ...}\endmodality(post) )
                       \heuristics(simplify_prog)
		       \displayname "cast" };

 // this is a bit fishy, as the assignment #lhs=#se is not a
 // correctly typed Java statement in general
 reference_type_cast { \find (\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality(post))
                       \replacewith ( \modality{#allmodal}{.. if (#se == null) #lhs = null;
                                                   else if (#se instanceof #npit) #lhs = #se;
				                   else throw new java.lang.ClassCastException();
                                                ...}\endmodality(post) )
                       \heuristics(simplify_prog) };

}

//--------------- methods ----------------------------------------------------//

\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  methodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
      \add (==> #se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException();
   	  	                  ...}\endmodality(post)) 
      \add (#se = null==>)
    \heuristics(simplify_autoname)
    };
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions){
  methodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
      \add (==> #se = null);
    "Null Reference (#se = null)":
      \replacewith (false) 
      \add (#se = null==>)
    \heuristics(simplify_autoname)
    };
}

\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  methodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException();
                                  ...}\endmodality(post))
      \add (#se = null  ==> )
    \heuristics(simplify_autoname)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions){
  methodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#se = null);
    "Null Reference (#se = null)":
      \replacewith (false)
      \add (#se = null  ==> )
    \heuristics(simplify_autoname)
  };
}




\rules(programRules:Java) {

//--------------- queries ----------------------------------------------------
  resolvequery { \find (q) \sameUpdateLevel
		 \varcond(\isQuery(q), \new(queryValue, \dependingOn(q))) 
                 \replacewith (queryValue)
	         \add (q = queryValue,
                       #ResolveQuery(q, queryValue) ==>)
                 \heuristics (queries)
                 \displayname "query" };

//----------------- normal methods -----------------------------------
  methodCallUnfoldArguments { 
    \find (\modality{#allmodal}{.. #nsmr ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#nsmr); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \oldname "method_call_eval"
  };

  methodCallUnfoldTarget { 
    \find (\modality{#allmodal}{.. #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \oldname "method_call_eval_prefix"
  };


  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallSuper { 
    \find (\modality{#allmodal}{.#ex.. super.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #method-call(#ex, super.#mn(#elist)); 
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \oldname "method_call_super"
  };

  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallWithAssignmentSuper {
    \find (\modality{#allmodal}{.#ex.. #lhs=super.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, super.#mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \displayname "methodCallSuper"
    \heuristics(simplify_autoname)
    \oldname "method_call_with_assignment_super"
  };

  methodCallWithAssignmentUnfoldArguments { 
    \find (\modality{#allmodal}{.. #lhs = #nsmr; ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsmr); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCallUnfoldArguments"
    \oldname "method_call_with_assignment_eval"
  };

  methodCallWithAssignmentUnfoldTarget { 
    \find (\modality{#allmodal}{.. #lhs = #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #lhs = #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCallUnfoldTarget"	
    \oldname "method_call_with_assignment_eval_prefix"
  };

  methodCallEmpty { 
    \find (\modality{#allmodal}{.. method-frame(#ex):{} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
    \oldname "method_call_empty"
  };

  methodCallEmptyReturn { 
     \find (\modality{#allmodal}{.. method-frame(#ex):{return; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
     \displayname "methodCallReturn"
     \oldname "method_call_return_void_ignore_trail"
  };

  methodCallReturn { 
     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{return #se; #slist} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. method-frame(#ex):{ #v0 = #se; } ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallReturn"
     \oldname "method_call_return_ignore_trail"
  };

  methodCallReturnIgnoreResult { 
    \find (\modality{#allmodal}{.. method-frame(#ex):{return #se; #slist} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post))
    \displayname "methodCallReturn"
    \heuristics(simplify_prog) 
    \oldname "method_call_return_ignore_result"
  };

  methodBodyExpand { 	
    \find (\modality{#allmodal}{.. #mb ...}\endmodality(post))
    \replacewith (#introAtPreDefs(\modality{#allmodal}{.. #expand-method-body(#mb); ...}\endmodality(post)))
    \heuristics(method_expand) 
    \oldname "method_body_expand"
  };

  blockReturnNoValue { 
     \find (\modality{#allmodal}{.. {return; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn"
     \oldname "return_in_block_ignore_trail"
  };

  blockReturn { 
     \find (\modality{#allmodal}{.. {return #se; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn"
     \oldname "return_in_block_simple_ignore_trail"
  };

  blockReturnLabel1 { 
     \find (\modality{#allmodal}{.. #lb: return #se; ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn (remove label)"
     \oldname "return_label_1"
  };

  blockReturnLabel2 { 
     \find (\modality{#allmodal}{.. #lb: { return #se; #slist } ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn (remove label)"
     \oldname "return_label_2"
  };

  
  methodCallThrow {
     \find (\modality{#allmodal}{.. method-frame(#ex):{throw #se; #slist} ...}\endmodality(post)) 
     \varcond(\isLocalVariable(#se))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallThrow"
     \oldname "method_call_throw_ignore_trail"
  };

  methodCallParamThrow { 
     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{throw #se; #slist} 
                      ...}\endmodality(post)) 
     \varcond(\isLocalVariable(#se))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallThrow"
     \oldname "method_call_throw_with_param_ignore_trail"
  };


  //throwEvaluate in the book, ignored for consistency reasons
  throwUnfoldMore {
     \find (\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \varcond(\not\isLocalVariable(#se), \new(#v0, \typeof(#se)))
     \replacewith (\modality{#allmodal}{.. #typeof(#se) #v0 = #se; throw #v0; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "throwUnfold"
     \oldname "throw_eval"
  };


  blockThrow { 
    \find (\modality{#allmodal}{.. {throw #e; #slist} ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. throw #e;  ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset) 
    \displayname "blockThrow"
    \oldname "throw_in_block_ignore_trail"
  };


  methodCallEmptyNoreturnBox { 
    \find (\[{.. method-frame(#v0, #ex):{} ...}\](post)) 
    \replacewith (\[{..  ...}\](post)) 
    \displayname "methodCallEmpty"
    \heuristics(simplify_prog) 
    \oldname "method_call_empty_noreturn_box"
  };

//--------------- loops ------------------------------------------------------//

 loopUnwind    { \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
		   \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
	           \replacewith (\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
	           					     while(#e) #s); ...}\endmodality(post))
		   \heuristics(loop_expand)
		   \oldname "unwind_while"};


/*XXX
 whileInvBox { \find (==> \[{.#ex..   while(#e) #s  ...}\]post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1, \dependingOnMod(#modifies)),
          	   \new(anon2, \dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==>  #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                #whileInvRule(\[{.. while (#e) #s ...}\]post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
         \replacewith (==> #introNewAnonUpdate(#modifies, inv -> 
                          (\[{ method-frame(#ex):{#typeof(#e)  #v1 = #e;} }\]
	                     (#v1=FALSE -> \[{..   ...}\]post)),anon2)) 
         \heuristics (loop_invariant, loop_invariant_proposal)
         \displayname "loopInvariant"
	 \oldname "while_inv_box"}; 


 whileInvDiamond { \find (==> \<{.#ex..   while(#e) #s  ...}\>post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==>  #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                #whileInvRule(\[{.. while (#e) #s ...}\]post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv -> 
                             (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]
	                      (#v1=FALSE -> \[{..   ...}\]post)),anon2));
    "Termination":
          \replacewith (==> \<{..   while(#e) #s  ...}\>true) 
    \heuristics (loop_invariant_proposal)
    \displayname "loopInvariant" 
    \oldname "while_inv_diamond"
  }; 

  // old invariant rule for ensuring loadability of old proofs
  whileInvDiamondDec { \find (==> \<{.#ex..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, int),
                  \new(#boolv, boolean),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon3,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)),
                  \new(anon3, \dependingOn(post)),
                  \new(anon3, \dependingOn(inv)),
                  \new(anon3, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );

     "Body Preserves Invariant":
         \replacewith (==> #atPreEqs(anon1) ->
	    #introNewAnonUpdate (#modifies, 
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) 
		& inv ->
               (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
               #whileInvRule(\[{.. while (#e) #s ...}\]post,
               #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),
	       anon1));

     "Use Case":
         \replacewith (==> #introNewAnonUpdate(#modifies, inv & variant >= 0 ->
                            (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2));
     "Termination":
         \replacewith (==>
                           #introNewAnonUpdate(#modifies,
                           (inv & variant >= 0 ->
                           ((\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                           {#v2:=variant} #whileInvRule(\<{.. while (#e) #s ...}\>true,
                                      variant < #v2 & variant >= 0) ))),anon3))
         \addprogvars(#v2)                                      
    \displayname "loopInvariant (with variant)"
    \oldname "while_inv_diamond_dec"
    };


  whileInvDiamondDec2 { \find (==> \<{.#ex..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, int),
                  \new(#boolv, boolean),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );

     "Body Preserves Invariant and Decreases Variant":
         \replacewith (==> #atPreEqs(anon1) ->
	    {#v2:=variant}#introNewAnonUpdate (#modifies, 
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) 
		& inv & variant >= 0 & variant <= #v2 ->
               (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
               {#v2:=variant}#whileInvRule(\<{.. while (#e) #s ...}\>post,
               #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv & variant < #v2 & variant >= 0)),
	       anon1))
	\addprogvars(#v2);

     "Use Case":
         \replacewith (==> #introNewAnonUpdate(#modifies, inv & variant >= 0 ->
                            (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2))
    \heuristics (loop_invariant, loop_invariant_proposal)
    \displayname "loopInvariant (with variant)"
    };
*/
  } 



\rules(programRules:Java) {


/* deprecated for-loop treatment 
 * (when/if deleting forInitUnfold, also delete meta construct #unpack)
 */
/*  
  forInitUnfold { 
	\find (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
	\replacewith 
	   (\modality{#allmodal}{.. 
		#unpack(for(#loopInit; #guard; #forupdates) #s);
            ...}\endmodality(post)) 
        \heuristics(simplify)
	\oldname "eval_for_init_for"
 };


forUnwindEmptyInit { 
     \find (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
              for(; #guard; #forupdates) #s); ...}\endmodality(post)) 
\heuristics(loop_expand)
     \oldname "unwind_for_empty_init"};

 
 forUnwindEmptyUpdate { 
     \find (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
	   for(#loopInit; #guard;) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand)
     \oldname "unwind_for_empty_update"}; 

 
 forUnwindEmptyInitUpdate { 
     \find (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
                   for(; #guard;) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand)
     \oldname "unwind_for_empty_init_and_update"}; 
*/
 
// for_inv      { \find (\[{.. for(#i; #e; #sel) {#s} ...}\]post) 
//           \varcond(#v new)
//          \replacewith (==> inv);
//          \replacewith (inv ==> \[{.. #unwind-loop (for(#i; #e; #sel)
//           {#s})  ...}\])
//          \replacewith (inv, \<{.. #v = #e; ...}\> #v = false ==>
//           \<{.. boolean #v = #e; ...}\>post) };


  doWhileUnwind {
	\find (\modality{#allmodal}{.. do #s while (#e); ...}\endmodality(post))
 	\varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
	\replacewith (\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel, do #s while(#e);); ...}\endmodality(post))
	\heuristics(loop_expand)
	\oldname "unwind_do_while"	
  };

  // Make a while loop out of a for loop
  for_to_while {
	\find (\modality{#allmodal}{.. #forloop ...}\endmodality(post))
	\varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
        \replacewith(\modality{#allmodal}{.. #for-to-while(#innerLabel, #outerLabel, #forloop) ...}\endmodality(post))
	\heuristics(simplify_prog)
  };


  arrayInitialisation {
	\find (\modality{#allmodal}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	        //{\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv] := #lit}
	\replacewith({heap:=changeHeapAtLocs2(heap,
	                                      setComprehension{iv;}(\if(geq(iv,#se) & lt(iv, int::select(heap,#a,Array::length)))
	                                                            \then(pair(#a, arr(iv)))
	                                                            \else(0),
	                                                            allLocs),
	                                      #lit)} \modality{#allmodal}{..  ...}\endmodality(post))
	\displayname "arrayInitialisation"
	\heuristics(simplify)
  };




//--------------- if-statements ----------------------------------------------//

  ifUnfold {  \find (\modality{#allmodal}{.. if(#nse) #s0 ...}\endmodality(post))
     \varcond (\new(#boolv, boolean))
     \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 ...}\endmodality(post))
     \heuristics(simplify_autoname)
     \displayname "ifElseUnfold"
     \oldname "if_eval"
  };

  ifElseUnfold { \find (\modality{#allmodal}{.. if(#nse) #s0 else #s1 ...}\endmodality(post)) 
     \varcond (\new(#boolv, boolean))
     \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 else{#s1}
                    ...}\endmodality(post) ) 
     \heuristics(simplify_autoname)
     \displayname "ifElseUnfold"
     \oldname "if_else_eval"
  };

  if  { \find (\modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post))
       \replacewith (\if (#se=TRUE) \then (\modality{#allmodal}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#allmodal}{.. ...}\endmodality(post))) 
       \heuristics(split_if) 
       \displayname "ifElse"
       \oldname "if_split_imp_new"
  };

  ifElse  { \find (\modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\if (#se=TRUE) \then (\modality{#allmodal}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#allmodal}{.. #s1 ...}\endmodality(post))) 
       \heuristics(split_if) 
       \displayname "ifElse"
       \oldname "if_else_split_imp_new"
  };

  ifElseSplit  { \find (==> \modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       "if #se true":  \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
       "if #se false": \replacewith (==> \modality{#allmodal}{.. #s1 ...}\endmodality(post)) \add (#se = FALSE ==>)
       \heuristics(split_if) 
       \displayname "ifElseSplit"
       \oldname "if_else_split"
  };

  ifSplit  { \find (==> \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post) )
	"if #se true":  \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
	"if #se false": \replacewith (==> \modality{#allmodal}{..  ...}\endmodality(post)) \add (#se = FALSE ==>)  
	\heuristics(split_if)
	\displayname "ifElseSplit"
	\oldname "if_split"
  };

  ifElseSplitLeft  { \find ( \modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allmodal}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allmodal}{.. #s1 ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if)
       \oldname "if_else_split_left" };

  ifSplitLeft  { \find ( \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allmodal}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allmodal}{..  ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if)
       \oldname "if_split_left" };

  ifTrue   { \assumes ( #se = TRUE ==>)
       \find (==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality(post)) 
       \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post))  
       \heuristics (simplify_prog)
       \oldname "if_true"
  };


  ifElseTrue { \assumes ( #se = TRUE ==>)
		 \find (==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality(post))
                 \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) 
		 \heuristics (simplify_prog)
		 \oldname "if_else_true"
  };

  ifFalse   { \assumes ( #se = FALSE ==>)
       \find (==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality(post))        
       \replacewith (==> \modality{#allmodal}{.. ...}\endmodality(post))  
       \heuristics (simplify_prog)
       \oldname "if_false"
  };

  ifElseFalse { \assumes ( #se = FALSE ==>)
		 \find (==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality(post)) 
                 \replacewith (==> \modality{#allmodal}{.. #s1 ...}\endmodality(post)) 
                 \heuristics (simplify_prog)
		 \oldname "if_else_false"
  };


  ifEnterThen { 
	\find (\modality{#allmodal}{.. #loc=true; if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality(post))
        \heuristics (simplify)
	\oldname "if_enter_then"
  };

  ifSkipThen { 
	\find (\modality{#allmodal}{.. #loc=false; if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=false; ...}\endmodality(post)) 
        \heuristics (simplify)
	\oldname "if_skip_then"
  };

  ifElseSkipElse { 
	\find (\modality{#allmodal}{.. #loc=true; if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality(post))
        \heuristics (simplify)
	\oldname "if_else_enter_then"
  };

  ifElseSkipThen { 
	\find (\modality{#allmodal}{.. #loc=false; if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=false; #s1 ...}\endmodality(post))
        \heuristics (simplify)
	\oldname "if_else_enter_else"
  };


  ifEnterThenConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=true; } if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=true; } #s0 ...}\endmodality(post))
        \heuristics (simplify)
 	\displayname "ifEnterThen"
	\oldname "if_enter_then_block"
  };

  ifSkipThenConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=false; } ...}\endmodality(post)) 
        \heuristics (simplify)
	\displayname "ifSkipThen"
	\oldname "if_skip_then_block"

  };

  ifElseSkipElseConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=true;} if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=true;} #s0 ...}\endmodality(post))
        \heuristics (simplify)
        \displayname "ifElseSkipElse"
	\oldname "if_else_enter_then_block"
  };

  ifElseSkipThenConditionInBlock { 
       \find (\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\modality{#allmodal}{.. { #loc=false; } #s1 ...}\endmodality(post))
       \heuristics (simplify)
       \displayname "ifElseSkipThen"
       \oldname "if_else_enter_else_block"
  };
 
 

//--------------- switch-statements ------------------------------------------//

 
switch { 
    \find (\modality{#allmodal}{.. #sw ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. #switch-to-if(#sw) ...}\endmodality(post)) 
    \heuristics (simplify_prog)
    \oldname "switch_if"};


//--------------- labels and blocks ------------------------------------------//

// label_matches     { \find (\modality{#allmodal}{.. #break-match(#lb:#s); ...}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. ...}\endmodality(post)) };

// label_not_match    { \find (\modality{#allmodal}{.. #break-no-match(#lb:#s); ..}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. #s ..}\endmodality(post)) };  

// label_abrupt     { \find (\modality{#allmodal}{.. #reason-abrupt(#lb:#s); ..}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. #reason(#s); ...}\endmodality(post)) };


 break { \find (\modality{#allmodal}{.. #lb0: break #lb1;  ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality(post))
	\heuristics (simplify_prog)};

 blockBreakNoLabel { \find (\modality{#allmodal}{.. { break #lb1; #slist} ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. break #lb1; ...}\endmodality(post))
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockBreakNoLabel"
	\oldname "break_in_block_ignore_trail"};

 blockBreakLabel { \find (\modality{#allmodal}{.. #lb0: {break #lb1; #slist } ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality(post))
	\heuristics (simplify_prog)
	\oldname "break_in_labelled_block_ignore_trail"};

 blockEmptyLabel      { \find (\modality{#allmodal}{.. #lb:{} ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. {}  ...}\endmodality(post)) 
	    \heuristics(simplify_prog, simplify_prog_subset)
            \displayname "blockEmpty"
	    \oldname "empty_label"};
 
                        
 blockEmpty { 
     \find (\modality{#allmodal}{.. {} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
     \oldname "empty_block"};


 unusedLabel {
	\find (\modality{#allmodal}{.. #lb: #s ...}\endmodality(post))
	\varcond(\not\freeLabelIn(#lb,#s))
	\replacewith(\modality{#allmodal}{.. #s ...}\endmodality(post))
	\heuristics(simplify_prog)
 };
 


 emptyStatement { 
     \find (\modality{#allmodal}{.. ; ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
     \oldname "empty_statement"};


//  block_abrupt     { \find (\modality{#allmodal}{.. #reason-abrupt(#s); ..}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. #reason(#s); ...}\endmodality(post)) };
            


 synchronizedBlockEmpty      {
     \find (\modality{#allmodal}{.. synchronized(#e){} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
     \oldname "empty_synchronized"};



//----------------------------------------------------------------------------
//-----------                  instanceof 			   -----------
//----------------------------------------------------------------------------

 instanceof_eval { \find (\modality{#allmodal}{.. #v = #nse instanceof #t; ...}\endmodality(post))
	           \varcond(\new(#v0, \typeof(#nse))) 
		   \replacewith ( \modality{#allmodal}{..#typeof(#nse) #v0=#nse; 
				#v=#v0 instanceof #t;...}\endmodality(post) )
	           \heuristics(simplify_autoname)
 };

 instanceof_to_exist_true { \find (G::instance(obj)=TRUE) 
	\varcond (\notFreeIn(x, obj)) 
	\replacewith (\exists x; obj=x)
	\heuristics(instanceof_to_exists)
 };

 instanceof_to_exist_false { \find (G::instance(obj)=FALSE) 
	\varcond (\notFreeIn(x, obj)) 
	\replacewith (!\exists x; obj=x)
 };
 
 instanceof_known_dynamic_type { 
        \find (G::instance(H::<get>(idx)))
        \varcond(\sub(H, G))  
	\replacewith (TRUE)
	\displayname "subtypes are instances of supertypes"
	\heuristics(evaluate_instanceof)
 };
 
  instanceof_known_dynamic_type_2 { 
        \assumes(H::<get>(idx) = obj ==>) 
        \find (G::instance(obj)) \sameUpdateLevel
        \varcond(\sub(H, G))  
	\replacewith (TRUE)
	\displayname "subtypes are instances of supertypes"
	\heuristics(evaluate_instanceof)
 };
 
 instanceof_known_dynamic_type_no_sub { 
        \find (G::instance(H::<get>(idx)))
        \varcond(\not\sub(H, G))  
	\replacewith (FALSE)
        \displayname "exact type no sub or equal type"
	\heuristics(evaluate_instanceof)
 };
 
 instanceof_known_dynamic_type_no_sub_2 {
        \assumes (H::<get>(idx) = obj ==>) 
        \find (G::instance(obj)) \sameUpdateLevel
        \varcond(\not\sub(H, G))  
	\replacewith (FALSE)
        \displayname "exact type no sub or equal type"
	\heuristics(evaluate_instanceof)
 };

 instanceof_static_type {
       \find(G::instance(obj))
       \varcond(\sub(\typeof(obj), G))
       \replacewith(TRUE)
       \displayname "instanceof static type is subtype"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_not_compatible {
       \find(G::instance(obj) = TRUE)
       \varcond(\disjointModuloNull(G, \typeof(obj)))
       \replacewith(obj = null)
       \displayname "instanceof not compatible types"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_not_compatible_1 {
       \find(G::instance(obj) = FALSE)
       \varcond(\disjointModuloNull(G, \typeof(obj)))
       \replacewith(!(obj = null))
       \displayname "instanceof not compatible types"
       \heuristics(simplify, evaluate_instanceof)
 };


//----------------------------------------------------------------------------
//-----------            Compile-time constant variables           -----------
//----------------------------------------------------------------------------

 insert_constant_value { \find ( #cv ) \replacewith ( #constantvalue ( #cv ) )
                         \heuristics(concrete)  };



//------------------------------------------------------------------------
// ------------ Rules for conditional expression
//------------------------------------------------------------------------

 condition { \find (\modality{#allmodal}{.. #lhs = #e0 ? #e1 : #e2; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. if(#e0) {#lhs = #e1;} 
             else {#lhs = #e2;} ...}\endmodality(post)) 
            \heuristics(simplify_prog)};

//------------------------------------------------------------------------
// ------------ Rules for comparison operators
//------------------------------------------------------------------------

  equality_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 == #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#se0=#se1) 
                    \then (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))  
                    \else (\modality{#allmodal}{.. #lhs = true;  ...}\endmodality(post)) )
    \heuristics(simplify_prog, split_if)
    \displayname "equality comparison"
  };

  inequality_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 != #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#se0=#se1) \then (\modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)) 
                                  \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "inequality comparison"
  };

  less_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 < #se1; ...}\endmodality(post)) 
    \replacewith ( \if (lt(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true;  ...}\endmodality(post)) 
                  		     \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "lesser than distinction"
  };

  less_equal_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 <= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (leq(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true; ...}\endmodality(post))  
                                      \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(simplify_prog, split_if)
    \displayname "less-or-equal than distinction"
   };

  greater_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 > #se1; ...}\endmodality(post)) 
    \replacewith ( \if (gt(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true;  ...}\endmodality(post)) 
                                     \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(simplify_prog, split_if)
    \displayname "greater than distinction"
   };

  greater_equal_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 >= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (geq(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true; ...}\endmodality(post))
		                      \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "greater-or-equal than distinction"
   };



//------------------------------------------------------------------------
// ----------- Rules for handling a cast applied to a compound expression
//------------------------------------------------------------------------

  compound_byte_cast_expression { \find (\modality{#allmodal}{.. #lhs = (byte) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (byte) #v;  ...}\endmodality(post))
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_short_cast_expression { \find (\modality{#allmodal}{.. #lhs = (short) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (short) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_int_cast_expression { \find (\modality{#allmodal}{.. #lhs = (int) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (int) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_long_cast_expression { \find (\modality{#allmodal}{.. #lhs = (long) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (long) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

//------------------------------------------------------------------------
// ----------- Rules for expanding compound assignment operators
//------------------------------------------------------------------------

   compound_assignment_op_mul_attr { \find (\modality{#allmodal}{.. #e0.#attribute *= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute * #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mul_array { \find (\modality{#allmodal}{.. #e0[#e] *= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
			#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] * #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_mul { \find (\modality{#allmodal}{.. #v *= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v * (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_div_attr { \find (\modality{#allmodal}{.. #e0.#attribute /= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute / #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_div_array { \find (\modality{#allmodal}{.. #e0[#e] /= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] / #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_div { \find (\modality{#allmodal}{.. #v /= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v / (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod_attr { \find (\modality{#allmodal}{.. #e0.#attribute %= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute % #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod_array { \find (\modality{#allmodal}{.. #e0[#e] %= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] % #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod { \find (\modality{#allmodal}{.. #v %= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v % (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus_attr { \find (\modality{#allmodal}{.. #e0.#attribute += #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute + #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus_array { \find (\modality{#allmodal}{.. #e0[#e] += #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] + #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus { \find (\modality{#allmodal}{.. #v += #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v + (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus_attr { \find (\modality{#allmodal}{.. #e0.#attribute -= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute - #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus_array { \find (\modality{#allmodal}{.. #e0[#e] -= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] - #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus { \find (\modality{#allmodal}{.. #v -= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v - (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft_attr { \find (\modality{#allmodal}{.. #e0.#attribute <<= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute << #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft_array { \find (\modality{#allmodal}{.. #e0[#e] <<= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] << #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft { \find (\modality{#allmodal}{.. #v <<= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v << (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright_attr { \find (\modality{#allmodal}{.. #e0.#attribute >>= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >> #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright_array { \find (\modality{#allmodal}{.. #e0[#e] >>= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >> #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright { \find (\modality{#allmodal}{.. #v >>= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v >> (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright_attr { \find (\modality{#allmodal}{.. #e0.#attribute >>>= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >>> #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright_array { \find (\modality{#allmodal}{.. #e0[#e] >>>= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright { \find (\modality{#allmodal}{.. #v >>>= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v >>> (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_and_attr { \find (\modality{#allmodal}{.. #e0.#attribute &= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute & #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_and_array { \find (\modality{#allmodal}{.. #e0[#e] &= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] & #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_and { \find (\modality{#allmodal}{.. #v &= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v & (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_or_attr { \find (\modality{#allmodal}{.. #e0.#attribute |= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute | #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_or_array { \find (\modality{#allmodal}{.. #e0[#e] |= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] | #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_or { \find (\modality{#allmodal}{.. #v |= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v | (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor_attr { \find (\modality{#allmodal}{.. #e0.#attribute ^= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute ^ #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor_array { \find (\modality{#allmodal}{.. #e0[#e] ^= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor { \find (\modality{#allmodal}{.. #v ^= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v ^ (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  


//------------------------------------------------------------------------
// ----------- Rule for expanding iterated assignments -------------------
//------------------------------------------------------------------------

  eval_order_iterated_assignments_0_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]=#e1; 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_0_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute=#e;
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_0 { \find (\modality{#allmodal}{.. #lhs0=#lhs1=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1=#e; #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_1_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]*=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] * #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_1_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute*=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute * #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_1 { \find (\modality{#allmodal}{.. #lhs0=#lhs1*=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 * #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_2_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]/=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] / #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_2_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute/=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute / #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_2 { \find (\modality{#allmodal}{.. #lhs0=#lhs1/=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 / #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_3_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]%=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] % #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_3_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute%=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute % #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_3 { \find (\modality{#allmodal}{.. #lhs0=#lhs1%=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 % #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_4_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]+=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] + #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_4_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute+=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute + #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_4 { \find (\modality{#allmodal}{.. #lhs0=#lhs1+=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 + #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_5_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]-=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] - #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_5_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute-=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute - #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_5 { \find (\modality{#allmodal}{.. #lhs0=#lhs1-=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 - #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_6_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]<<=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] << #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_6_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute<<=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute << #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_6 { \find (\modality{#allmodal}{.. #lhs0=#lhs1<<=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 << #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_7_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]>>=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >> #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_7_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute>>=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >> #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_7 { \find (\modality{#allmodal}{.. #lhs0=#lhs1>>=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >> #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_8_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]>>>=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_8_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute>>>=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >>> #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_8 { \find (\modality{#allmodal}{.. #lhs0=#lhs1>>>=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >>> #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_9_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]&=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] & #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_9_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute&=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute & #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_9 { \find (\modality{#allmodal}{.. #lhs0=#lhs1&=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 & #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_10_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]|=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] | #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_10_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute|=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute | #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_10 { \find (\modality{#allmodal}{.. #lhs0=#lhs1|=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 | #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_11_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]^=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_11_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute^=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute ^ #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_11 { \find (\modality{#allmodal}{.. #lhs0=#lhs1^=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 ^ #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

//------------------------------------------------------------------------
// ------------ Rules for lazy evaluation
//------------------------------------------------------------------------

 evaluate_lazy_and { \find (\modality{#allmodal}{.. #b0 = #e1 && #e2; ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. if (!(#e1)) {#b0 = false;}  else {#b0 = #e2;} ...}\endmodality(post)) 
	\heuristics(simplify_prog)};

 evaluate_lazy_or { \find (\modality{#allmodal}{.. #b0 = #e1 || #e2; ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. if (#e1) {#b0 = true;} else {#b0 = #e2;} ...}\endmodality(post)) 
	\heuristics(simplify_prog)};

//------------------------------------------------------------------------
// ----------- Rule for removing redundant braces
//------------------------------------------------------------------------

 elim_double_block { \find (\modality{#allmodal}{{ #slist }}\endmodality(post)) \replacewith (\modality{#allmodal}{ #slist }\endmodality(post)) };

 elim_double_block_2 { \find (\modality{#allmodal}{.. { { #slist } } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. { #slist } ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_3 { \find (\modality{#allmodal}{.. { while ( #e ) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. while ( #e ) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_4 { \find (\modality{#allmodal}{.. { for(#loopInit; #guard; #forupdates) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_5 { \find (\modality{#allmodal}{.. { for(; #guard; #forupdates) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_6 { \find (\modality{#allmodal}{.. { for(#loopInit; #guard;) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_7 { \find (\modality{#allmodal}{.. { for(; #guard;) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_8 { \find (\modality{#allmodal}{.. { do #s while (#e); } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. do #s while (#e); ...}\endmodality(post))
                       \displayname "elim_double_block" };


//------------------------------------------------------------------------
// ----------- Rule for removing redundant parentheses
//------------------------------------------------------------------------

  remove_parentheses_right  { \find (\modality{#allmodal}{.. #lhs = (#e); ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)};

  remove_parentheses_attribute_left  { \find (\modality{#allmodal}{.. (#e.#attribute) = #e0; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #e.#attribute = #e0; ...}\endmodality(post)) \heuristics(simplify_prog)
	\displayname "remove_parentheses"
	};

  remove_parentheses_lhs_left  { \find (\modality{#allmodal}{.. (#lhs) = #e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)
	\displayname "remove_parentheses"
	};

//------------------------------------------------------------------------ 
// ----------- Rules for binary arithmetic operators applied to at least one compound expression
//------------------------------------------------------------------------

   compound_multiplication_1 { \find (\modality{#allmodal}{.. #lhs=#nse * #se; ...}\endmodality(post))
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v * #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_multiplication_2 { \find (\modality{#allmodal}{.. #lhs=#e * #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 * #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_division_1 { \find (\modality{#allmodal}{.. #lhs=#nse / #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v / #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "division"};

   compound_division_2 { \find (\modality{#allmodal}{.. #lhs=#e / #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 / #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "division"};

   compound_modulo_1 { \find (\modality{#allmodal}{.. #lhs=#nse % #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v % #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_modulo_2 { \find (\modality{#allmodal}{.. #lhs=#e % #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 % #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_addition_1 { \find (\modality{#allmodal}{.. #lhs=#nse + #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v + #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_addition_2 { \find (\modality{#allmodal}{.. #lhs=#e + #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 + #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_binary_AND_1 { \find (\modality{#allmodal}{.. #lhs=#nse & #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v & #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_AND"};

   compound_binary_AND_2 { \find (\modality{#allmodal}{.. #lhs=#e & #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 & #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_AND"};

   compound_binary_OR_1 { \find (\modality{#allmodal}{.. #lhs=#nse | #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v | #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_OR"};

   compound_binary_OR_2 { \find (\modality{#allmodal}{.. #lhs=#e | #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 | #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_OR"};

   compound_binary_XOR_1 { \find (\modality{#allmodal}{.. #lhs=#nse ^ #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v ^ #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_XOR"};

   compound_binary_XOR_2 { \find (\modality{#allmodal}{.. #lhs=#e ^ #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 ^ #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_XOR"};

   compound_invert_bits { \find (\modality{#allmodal}{.. #lhs=~#nse; ...}\endmodality(post)) 
         \varcond (\new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{..  #typeof(#nse) #v1=#nse; #lhs=~#v1 ; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "invert_bits"};

   compound_subtraction_1 { \find (\modality{#allmodal}{.. #lhs=#nse - #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v - #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_subtraction_2 { \find (\modality{#allmodal}{.. #lhs=#e - #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 - #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >>> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >>> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >>> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >>> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_1 { \find (\modality{#allmodal}{.. #lhs=#nse << #se; ...}\endmodality(post)) 
	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v << #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_2 { \find (\modality{#allmodal}{.. #lhs=#e << #nse; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 << #v1; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_equality_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 == #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 == #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_equality_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e == #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 == #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_inequality_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 != #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 != #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_inequality_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e != #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 != #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_less_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 < #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 < #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e < #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 < #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_equal_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 <= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 <= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_less_equal_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e <= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 <= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_greater_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 > #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 > #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e > #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 > #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_equal_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 >= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 >= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

  compound_greater_equal_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e >= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 >= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

//------------------------------------------------------------------------
//---------------------- Rules boolean expressions -----------------------
//------------------------------------------------------------------------


  compound_assignment_1 { \find (\modality{#allmodal}{.. #lhs=!#seBool; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. if (#seBool) #lhs=false; else #lhs=true; ...}\endmodality(post))
         \heuristics(simplify_expression)
         \displayname "compound_assignment"};  

  compound_assignment_2 { \find (\modality{#allmodal}{.. #lhs=!#nseBool; ...}\endmodality(post))
          \varcond (\new(#v, boolean))
          \replacewith (\modality{#allmodal}{.. boolean #v=#nseBool; #lhs=!#v; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_3 { \find (\modality{#allmodal}{.. #lhs=#exBool0 && #exBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (!#exBool0) #lhs=false; else #lhs=#exBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_4 { \find (\modality{#allmodal}{.. #lhs=#exBool0 & #exBool1; ...}\endmodality(post))
          \replacewith (\modality{#allmodal}{.. #lhs=#exBool0; 
                            if (!#exBool1) #lhs=false; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

    compound_assignment_5 { \find (\modality{#allmodal}{.. #lhs=#exBool0 || #exBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (#exBool0) #lhs=true; else #lhs=#exBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_6 { \find (\modality{#allmodal}{.. #lhs=#exBool0 | #exBool1; ...}\endmodality(post))
          \replacewith (\modality{#allmodal}{.. #lhs=#exBool0;
                            if (#exBool1) #lhs=true; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

//------------------------------------------------------------------------
// ----------- Rules for array and attribute expressions 
//------------------------------------------------------------------------

eval_order_array_access1 { 
		\find (\modality{#allmodal}{..#nv[#e]=#e0;...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#nv)) )
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
				#v0[#e]=#e0;
				 ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_array_access2 { 
		\find (\modality{#allmodal}{..#v[#nse]=#e;...}\endmodality(post))
		\varcond (\new(#ar1, \typeof(#v)), \new(#v0, \typeof(#nse)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v) #ar1 = #v;
				#typeof(#nse) #v0=#nse;
				#ar1[#v0]=#e;
					 ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_array_access3 { 
		\find (\modality{#allmodal}{..#v[#se]=#nse;...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)),
            		  \new(#v2, \typeof(#se)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v) #v0=#v;
				#typeof(#se) #v2=#se;
				if(#length-reference(#v)<=#se || #se<0 ) {
				      throw new java.lang.ArrayIndexOutOfBoundsException();
				}
				#typeof(#nse) #v1=#nse;
				#v0[#v2]=#v1; ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocation"};


eval_order_array_access4 { 
		\find (\modality{#allmodal}{..#v=#nv[#e];...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#nv)))
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
				#v=#v0[#e];
					...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

eval_order_array_access5 { 
		\find (\modality{#allmodal}{..#v=#v0[#nse];...}\endmodality(post))
		\varcond (\new(#ar1, \typeof(#v0)), \new(#v1, \typeof(#nse)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v0) #ar1 = #v0;
				#typeof(#nse) #v1=#nse;
				#v=#ar1[#v1];
					...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

eval_order_array_access6 {
		\find (\modality{#allmodal}{..#v=#nv.#length; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#length; ...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

//-----------------------------------------------------------------------


eval_order_access1 {
		\find (\modality{#allmodal}{..#nv.#attribute=#e;...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v0.#attribute=#e;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_access2 { 
		\find (\modality{#allmodal}{.. #v=#nv.#attribute; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#attribute;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

}


\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  eval_order_access4 {
		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)), 
         		\not \static(#a)) 
		\replacewith(\modality{#allmodal}{..if(#v==null){
				throw new java.lang.NullPointerException();
			    }
			    #typeof(#v) #v0=#v;
			    #typeof(#nse) #v1=#nse;
			    #v0.#a=#v1;...}\endmodality(post))
         	\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocation"
  };
}
  
  
\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions) {
  eval_order_access4 {
		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)), 
         		\not \static(#a))
         		
	       "Normal Execution (#v != null)":         		 
		\replacewith(\modality{#allmodal}{.. #typeof(#v) #v0=#v;
			                             #typeof(#nse) #v1=#nse;
			                              #v0.#a=#v1;...}\endmodality(post))
    	       \add(==> #v = null);
			    
    	       "Null Reference (#v = null)":
    	       \replacewith(false);
    	       \add(#v = null ==>)
			    
               \heuristics(simplify_prog, simplify_prog_subset)
	       \displayname "assignmentSaveLocation"
  };
}


\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  assignment_to_reference_array_component { 
                 \find (\modality{#allmodal}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#allmodal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, int::select(heap,#v,Array::length)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#allmodal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#allmodal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(int::select(heap,#v,Array::length), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#allmodal}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, int::select(heap,#v,Array::length)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions) {
  assignment_to_reference_array_component { 
                 \find (\modality{#allmodal}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#allmodal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, int::select(heap,#v,Array::length)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(false)
			\add (!(#v=null) & (leq(int::select(heap,#v,Array::length), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(false)
                        \add (!(#v=null) & lt(#se, int::select(heap,#v,Array::length)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  assignment_to_primitive_array_component { 
                 \find (\modality{#allmodal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#allmodal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, int::select(heap,#v,Array::length)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#allmodal}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#allmodal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(int::select(heap,#v,Array::length), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions) {
  assignment_to_primitive_array_component { 
                 \find (\modality{#allmodal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#allmodal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, int::select(heap,#v,Array::length)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(false)
			\add (!(#v=null) & (leq(int::select(heap,#v,Array::length), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

		    
\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  assignment_array2{\find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
                  \varcond(\hasSort(#v, G))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   \add (==>(#v0=null) | leq(int::select(heap,#v0,Array::length), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#allmodal}{..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#allmodal}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(int::select(heap,#v0,Array::length), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions) {
  assignment_array2{\find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
                  \varcond(\hasSort(#v, G))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   \add (==>(#v0=null) | leq(int::select(heap,#v0,Array::length), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(false)
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(false)
		   \add (!(#v0=null) & (leq(int::select(heap,#v0,Array::length), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  assignment_read_attribute { 
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
 	        \varcond(\not \static(#a), \hasSort(#v0, G))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions) {
  assignment_read_attribute { 
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
 	        \varcond(\not \static(#a), \hasSort(#v0, G))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptionsPolicy:allowRuntimeExceptions) {
  assignment_write_attribute { 
		\find (\modality{#allmodal}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a))
		"Normal Execution (#v != null)":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  
}

\rules(programRules:Java, runtimeExceptionsPolicy:forbidRuntimeExceptions) {
  assignment_write_attribute { 
		\find (\modality{#allmodal}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a))
		"Normal Execution (#v != null)":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(false)
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  
}



\rules(programRules:Java) {

//------------------------------------------------------------------------
// ----------- Rules for modal tautologies
//------------------------------------------------------------------------

box_true{ \find (\[{.. #s ...}\]true)
	  \replacewith(true)
	  \heuristics(modal_tautology)};

diamond_false{ \find (\<{.. #s ...}\>false)
	       \replacewith(false)
	       \heuristics(modal_tautology)};

diamond_and_left{\find (\<{.. #s ...}\>(post & post1)==>)
		 \replacewith(\<{.. #s ...}\>post & \<{.. #s ...}\>post1==>)};

box_and_left{\find (\[{.. #s ...}\](post & post1) ==>)
		 \replacewith(\[{.. #s ...}\]post & \[{.. #s ...}\]post1==>)};

diamond_and_right{\find (==> \<{.. #s ...}\>(post & post1))
		 \replacewith(==> \<{.. #s ...}\>post);
		 \replacewith(==> \<{.. #s ...}\>post1)};

box_and_right{\find (==> \[{.. #s ...}\](post & post1))
		 \replacewith(==> \[{.. #s ...}\]post);  
		 \replacewith(==> \[{.. #s ...}\]post1)};

diamond_or_right{\find (==> \<{.. #s ...}\>(post | post1))
		 \replacewith(==> \<{.. #s ...}\>post | \<{.. #s ...}\>post1)};

box_or_right{\find (==> \[{.. #s ...}\](post | post1))
	     \replacewith(==> \[{.. #s ...}\]post | \[{.. #s ...}\]post1)};

diamond_or_left{\find (\<{.. #s ...}\>(post | post1)==>)
		 \replacewith(\<{.. #s ...}\>post | \<{.. #s ...}\>post1==>)};

box_or_left{\find (\[{.. #s ...}\](post | post1)==>)
	     \replacewith(\[{.. #s ...}\]post | \[{.. #s ...}\]post1==>)};

/////////////////////////////////////////////////////////////////
// for taclet proof obligations

box_imp_left{\find (\[{.. #s ...}\](post -> post1)==>)
	     \replacewith(\<{.. #s ...}\>post -> \[{.. #s ...}\]post1==>)};

diamond_imp_left{\find (\<{.. #s ...}\>(post -> post1)==>)
	     \replacewith(\[{.. #s ...}\]post -> \<{.. #s ...}\>post1==>)};

box_imp_right{\find (==>\[{.. #s ...}\](post -> post1))
	     \replacewith(==>\<{.. #s ...}\>post -> \[{.. #s ...}\]post1)};

diamond_imp_right{\find (==>\<{.. #s ...}\>(post -> post1))
	     \replacewith(==>\[{.. #s ...}\]post -> \<{.. #s ...}\>post1)};

/////////////////////////////////////////////////////////////////

same_diamonds_right{ \assumes (==>\<{#s}\>post) 
		    \find (==> \<{#s}\>post1)
		    \add (==> \<{#s}\>(post | post1))};

same_diamonds_left{ \assumes (\<{.. #s ...}\>post ==>)
		    \find (\<{.. #s ...}\>post1 ==>)
		    \add (\<{.. #s ...}\>(post & post1) ==>)};

same_boxes_right{ \assumes (==>\[{.. #s ...}\]post)
		    \find (==> \[{.. #s ...}\]post1)
		    \add (==> \[{.. #s ...}\](post | post1))};

same_boxes_left{ \assumes (\[{.. #s ...}\]post ==>)
		    \find (\[{.. #s ...}\]post1 ==>)
		    \add (\[{.. #s ...}\](post & post1) ==>)};

boxToDiamond{\find (\[{.. #s ...}\]post)
	    \replacewith(!\<{.. #s ...}\>!post)
            \heuristics(boxDiamondConv)
	    \oldname "box2diamond"};


diamondToBox{\find (\<{.. #s ...}\>post)
	    \replacewith(!\[{.. #s ...}\]!post)
            \heuristics(boxDiamondConv)
	    \oldname "diamond2box"};

diamond_split_termination{\find (\<{.. #s ...}\>post)
	    \replacewith(\[{.. #s ...}\]post & \<{.. #s ...}\>true )};


}


\rules(programRules:Java) {
  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any acception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_write_static_attribute {
	\find (\modality{#allmodal}{.. @(#sv) = #se; ...}\endmodality(post))
	\replacewith({#sv := #se} \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

}


\rules(programRules:Java) {
  // constant case cannot occur as no static initilisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\replacewith({#sv := #se} \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };

  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. #loc = @(#v.#sv); ...}\endmodality(post))
	\varcond(\hasSort(#loc, G))
        \replacewith({#loc := G::select(heap,#v,#memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
	\heuristics(simplify_prog)
        \displayname "assignment"
  };

}



//=====================================================================//
//======================= static method calls    ======================//
//=====================================================================//

\rules(programRules:Java, initialisation:disableStaticInitialisation) {
  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		 #method-call(#v0, #se.#mn(#elist));
		...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist));
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_with_assignment"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_via_typereference"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist));
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_with_assignment_via_typereference"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment_within_class"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.. #mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#method-call(#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_within_class"
  };   
}


\rules(programRules:Java, initialisation:enableStaticInitialisation) {

  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		#static-initialisation(#se.#mn(#elist));
		#method-call(#v0, #se.#mn(#elist));
		...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality((post))) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #static-initialisation(#se.#mn(#elist));
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist));
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_with_assignment"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist)); 
		                #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_via_typereference"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist));
				#typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist));
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_with_assignment_via_typereference"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #static-initialisation(#mn(#elist));
			       #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment_within_class"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.#ex.. #mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#static-initialisation(#mn(#elist));
	#method-call(#ex, #mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_within_class"
  };

 passiveMethodCallWithinClass { 
   		\find (\modality{#allmodal}{.#ex.. @(#mn(#elist)); ...}\endmodality(post)) 
   		\replacewith (\modality{#allmodal}{.. #method-call(#ex, #mn(#elist)); ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_within_class"
 };

 passiveMethodCallStatic { 
   		\find (\modality{#allmodal}{.. @(#t.#mn(#elist)); ...}\endmodality(post)) 
   		\replacewith (\modality{#allmodal}{.. #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_static"
 };

 passiveMethodCallWithAssignmentWithinClass {
   		\find (\modality{#allmodal}{.#ex.. #lhs=@(#mn(#elist)); ...}\endmodality(post)) 
   		\varcond(\new(#v0, \typeof(#lhs)))
   		\replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                                          #method-call(#ex, #v0, #mn(#elist));
                                          #lhs = #v0;
                                     ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_with_assignment_within_class"
 };

 passiveMethodCallStaticWithAssignment {
		\find (\modality{#allmodal}{.. #lhs = @(#t.#mn(#elist)); ...}\endmodality(post))
   		\varcond(\new(#v0, \typeof(#lhs)))
   		\replacewith(\modality{#allmodal}{..  #typeof(#lhs) #v0;
 		                 #method-call(#v0, #t.#mn(#elist));
		                 #lhs = #v0; 
			   ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_static_with_assignment"
 };



}



//===============================================================//
//============   axioms describing valid jvm states ===========//
//===============================================================//
\rules(programRules:Java) {
 
 class_being_initialized_is_prepared {
	\assumes (boolean::select(heap, null, alphaObj::<classInitializationInProgress>)  = TRUE, inReachableState ==>)  
        \find (boolean::select(heap, null, alphaObj::<classPrepared>)) \sameUpdateLevel
	\replacewith(TRUE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialized classes have been prepared"
  };   
  
 initialized_class_is_prepared {
	\assumes (boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find (boolean::select(heap, null, alphaObj::<classPrepared>)) \sameUpdateLevel
	\replacewith (TRUE)
	\heuristics(confluence_restricted, simplify)
        \displayname "classes being initialized have been prepared"
  };
 
 initialized_class_is_not_erroneous {
	\assumes (boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find (boolean::select(heap, null, alphaObj::<classErroneous>)) \sameUpdateLevel
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialized class is not erroneous"
  };

 class_initialized_excludes_class_init_in_progress {
	\assumes (boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find (boolean::select(heap, null, alphaObj::<classInitializationInProgress>)) \sameUpdateLevel
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialisation process has already terminated"
  };

 class_erroneous_excludes_class_in_init {
	\assumes (boolean::select(heap, null, alphaObj::<classErroneous>) = TRUE, inReachableState ==>) 
        \find (boolean::select(heap, null, alphaObj::<classInitializationInProgress>)) \sameUpdateLevel
	\replacewith (FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialization process has already terminated (or never begun)"
  };

 erroneous_class_has_no_initialized_sub_class {
        \assumes(boolean::select(heap, null, alphaObj::<classErroneous>) = TRUE, inReachableState ==>)
        \find(boolean::select(heap, null, betaObj::<classInitialized>)) \sameUpdateLevel
	\varcond(\sub(betaObj, alphaObj))
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "erroneous classes have no initialized subclasses"
 };
 
 superclasses_of_initialized_classes_are_initialized {
        \assumes(boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find(boolean::select(heap, null, betaObj::<classInitialized>)) \sameUpdateLevel
	\varcond(\isReference[non_null](betaObj), \strict \sub(betaObj, alphaObj))
	\replacewith(TRUE)
	\heuristics(simplify)
        \displayname "initialized classes have only initialized subclasses"
 };
 
 superclasses_of_initialized_classes_are_initialized_2 {
        \assumes(boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find(boolean::select(heap, null, betaObj::<classPrepared>)) \sameUpdateLevel
	\varcond(\sub(betaObj, alphaObj))
	\replacewith(TRUE)
	\heuristics(simplify)
        \displayname "initialied classes have only prepared subclasses"
 };

}
