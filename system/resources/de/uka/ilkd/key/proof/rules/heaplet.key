\sorts {
    Heaplet;
}


\functions {
    // constructors for Heaplets
    Heaplet heaplet(Heap, LocSet);
    Heaplet mergeHeaplet(Heaplet, Heaplet);

    //select/store
    alpha alpha::selectOnHeaplet(Heaplet, Object, Field);
    Heap storeOnHeaplet(Heaplet, Object, Field, any);
    Heap createOnHeaplet(Heaplet, Object);
    Heap anonOnHeaplet(Heaplet, LocSet, Heap);
    Heap memsetOnHeaplet(Heaplet, LocSet, any);

    // error element for reading out of the bounds of the heaplet
    \unique any elementOutOfHeaplet;

    // merge for Heaps
    Heap merge(Heap, LocSet, Heap);

    // return the set of all locations (o, f) of the given LocSet whose field f
    // does not equal <created>
    LocSet filterOutCreatedField(LocSet);
}


\predicates {
}


\programVariables {
}


   

\rules(programRules:Java){

    //--------------------------------------------------------------------------
    // axioms for merge and filterOutCreatedField
    //--------------------------------------------------------------------------

    selectOfMerge {
        \schemaVar \term Heap h1, h2;
        \schemaVar \term LocSet l;
        \schemaVar \term Field f;
        \schemaVar \term Object o;

        \find(beta::select(merge(h1, l, h2), o, f))

        \replacewith(\if(\elementOf(o, f, l))
                     \then(beta::select(h1, o, f))
                     \else(beta::select(h2, o, f)))
    };


    mergeEmpty {
        \schemaVar \term Heap h1, h2;

        \find(merge(h1, empty, h2))

        \replacewith(h2)

        \heuristics(simplify)
    };

    mergeAllLocs {
        \schemaVar \term Heap h1, h2;

        \find(merge(h1, allLocs, h2))

        \replacewith(h1)

        \heuristics(simplify)
    };

    axiomFilterOutCreatedField {
        \scheamVar \term LocSet l;
        \schemaVar \variable Object o;

        \find(filterOutCreatedField(l))

        \replacewith(setMinus(l, infiniteUnion{o;}(singleton(o, java.lang.Object::<created>))))
    };

    //--------------------------------------------------------------------------
    // lemmata for merge and filterOutCreatedField
    //--------------------------------------------------------------------------

    filterOutCreatedFieldIsSubset {
        \scheamVar \term LocSet l;
        \schemaVar \variable Object o;

        \find(filterOutCreatedField(l))

        \add(subset(filterOutCreatedField(l), l) ==>)

        \heuristics(simplify_enlarging)
    };


    //--------------------------------------------------------------------------
    // axioms for ...OnHeaplet
    //--------------------------------------------------------------------------

    selectOfHeaplet {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term LocSet l;
   
	\find(beta::selectOnHeaplet(heaplet(h, l), o, f))
	
	\replacewith(\if(\elementOf(o, f, l))
                     \then(beta:select(h, o, f))
                     \else((beta)elementOutOfHeaplet)
                     
      	\heuristics(simplify_enlarging)
    };

    axiomMergeHeaplet {
	\schemaVar \term Heap h1, h2;
        \schemaVar \term LocSet l1, l2;

	\find(mergeHeaplet(heaplet(h1, l1), heaplet(h2, l2)))

	\replacewith(heaplet(merge(h1, l1, h2), union(l1, l2)))
    };

    axiomStoreOnHeaplet {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet l;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \find(storeOnHeaplet(heaplet(h, l), o, f, x))

        \replacewith(\if(elementOf(o, f, l))
                     \then(heaplet(store(heap, o, f, x), l))
                     \else(heaplet(h, l)))

        \heuristics(simplify_enlarging)
    }

    axiomAnonOnHeaplet {
        \schemaVar \term Heap h, anonHeap;
        \schemaVar \term LocSet l1, l2;

        \find(anonOnHeaplet(heaplet(h, l1), l2, anonHeap))

        \replacewith(heaplet(anon(h, intersect(l1, l2), anonHeap), l1))
    }

// todo
    axiomCreateOnHeaplet {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet l;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \find(createOnHeaplet(heaplet(h, l), o))

        \replacewith(\if(elementOf(o, f, l))
                     \then(heaplet(store(heap, o, f, x), l))
                     \else(heaplet(h, l)))

        \heuristics(simplify_enlarging)
    }

// todo
    axiomMemsetOnHeaplet {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet l;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \find(storeOnHeaplet(heaplet(h, l), o, f, x))

        \replacewith(\if(elementOf(o, f, l))
                     \then(heaplet(store(heap, o, f, x), l))
                     \else(heaplet(h, l)))

        \heuristics(simplify_enlarging)
    }


    //--------------------------------------------------------------------------
    // axiom for merge
    //--------------------------------------------------------------------------

    selectOfMerge {
        \schemaVar \term Heap h1, h2;
        \schemaVar \term LocSet l;
        \schemaVar \term Field f;
        \schemaVar \term Object o;

        \find(beta::select(merge(h1, l, h2), o, f))

        \replacewith(\if(\elementOf(o, f, l))
                     \then(beta::select(h1, o, f))
                     \else(beta::select(h2, o, f)))
    };


    //--------------------------------------------------------------------------
    // lemmata for ...OnHeaplet
    //--------------------------------------------------------------------------

    selectOfMergeHeaplet {
	\schemaVar \term Heap h1, h2;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term LocSet l1, l2;

	\find(beta::selectOnHeaplet(mergeHeaplet(heaplet(h1, l1),
                                                 heaplet(h2, l2)), o, f))

	\replacewith(\if(\elementOf(o, f, l1))
                     \then(beta::selectOnHeaplet(heaplet(h1, l1), o, f))
                     \else(beta::selectOnHeaplet(heaplet(h2, l2), o, f))

      	\heuristics(simplify_enlarging)
    };
    
    storeOnMergeHeaplet {
        \schemaVar \term Heap h1, h2;
        \schemaVar \term LocSet l1, l2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \find(storeOnHeaplet(mergeHeaplet(heaplet(h1, l1),
                                          heaplet(h2, l2)), o, f, x))

        \replacewith(mergeHeaplet(storeOnHeaplet(heaplet(h1, l1), o, f, x),
                                  storeOnHeaplet(heaplet(h2, l2), o, f, x)))

        \heuristics(simplify_enlarging)
    }

    simplifyAnonOnHeaplet {
        \schemaVar \term Heap h, anonHeap;
        \schemaVar \term LocSet l1, l2;

        \find(anonOnHeaplet(heaplet(h, l1), l2, anonHeap))

        \replacewith(heaplet(merge(h, setMinus(l1, filterOutCreatedField(l2))), anonHeap), l1);
        \add(==> createdInHeap(l1, h))

        \heuristics(simplify_enlarging)
    }

    anonOnFreshLocsHeaplet {
        \schemaVar \term Heap h, anonHeap;
        \schemaVar \term LocSet l2;

        \find(anonOnHeaplet(heaplet(h, freshLocs(h)), l2, anonHeap))

        \replacewith(mergeHeaplet(heaplet(anonHeap, setMinus(freshLocs(h),
                                                             freshLocs(anonHeap))),
                                  heaplet(anonHeap, freshLocs(anonHeap))))

        \heuristics(simplify)
    }


    //--------------------------------------------------------------------------
    // EQ versions for lemmata for ...OnHeaplet
    //--------------------------------------------------------------------------

    selectOfMergeHeapletEQ {
	\schemaVar \term Heap h1, h2;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term LocSet l1, l2;

        \assumes(mergeHeaplet(heaplet(h1, l1), heaplet(h2, l2)) = EQ ==>)
	\find(beta::selectOnHeaplet(EQ, o, f))
        \sameUpdateLevel

	\replacewith(\if(\elementOf(o, f, l1))
                     \then(beta::selectOnHeaplet(heaplet(h1, l1), o, f))
                     \else(beta::selectOnHeaplet(heaplet(h2, l2), o, f))

      	\heuristics(simplify_enlarging)
    };

    storeOnMergeHeapletEQ {
        \schemaVar \term Heap h1, h2;
        \schemaVar \term LocSet l1, l2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \assumes(mergeHeaplet(heaplet(h1, l1), heaplet(h2, l2)) = EQ ==>)
        \find(storeOnHeaplet(EQ, o, f, x))
        \sameUpdateLevel

        \replacewith(mergeHeaplet(storeOnHeaplet(heaplet(h1, l1), o, f, x),
                                  storeOnHeaplet(heaplet(h2, l2), o, f, x)))

        \heuristics(simplify_enlarging)
    }


// todo ...
    //--------------------------------------------------------------------------
    //lemmata for some common cases
    //--------------------------------------------------------------------------
    
    selectCreatedOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	
        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>))
        
        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                     \then(TRUE)
                     \else(boolean::select(h2, o, java.lang.Object::<created>)))
                                  
        \heuristics(concrete)
    };
    
    
    selectCreatedOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Heap EQ;
	
	\assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>)) 
        \sameUpdateLevel
        
        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                     \then(TRUE)
                     \else(boolean::select(h2, o, java.lang.Object::<created>)))
                                  
        \heuristics(concrete)
    };
    
    
    //--------------------------------------------------------------------------
    //axioms for observer symbols
    //--------------------------------------------------------------------------    

    onlyCreatedObjectsAreObserved {
        \schemaVar \term Heap h;
        \schemaVar \term deltaObject obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \find(obs) \sameUpdateLevel
        \varcond(\isObserver(obs, h))
         
        \add(obs = null
             | boolean::select(h, obs, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };
    
    
    onlyCreatedObjectsAreObservedInLocSets {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \find(elementOf(o, f, obs) ==>)
        \varcond(\isObserver(obs, h))
         
        \add(o = null
             | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };
    
    
    onlyCreatedObjectsAreObservedInLocSetsEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs, EQ;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \assumes(obs = EQ ==>)
        \find(elementOf(o, f, EQ) ==>)
        \varcond(\isObserver(obs, h))        
        
        \add(o = null  
             | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };

}
