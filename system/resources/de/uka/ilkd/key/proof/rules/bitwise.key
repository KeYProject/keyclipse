\rules {

   // arbitrary fixed length bitvector operations
   shiftRightDef {
   	\schemaVar \term int left, right;

	\find ( shiftright(left, right) )
	\replacewith ( \if ( right < 0 )
		       \then ( shiftleft(left, -right) )
		       \else ( div (left, pow(2, right) ) )
     )

	 \heuristics (simplify_enlarging)	 
   };

   shiftLeftDef {
   	\schemaVar \term int left, right;

	\find ( shiftleft(left, right) )
	\replacewith ( \if ( right < 0 )
		       \then ( shiftright(left, -right) )
		       \else ( mul (left, pow(2, right) ) )
     )

	 \heuristics (simplify_enlarging)	 
   };
   

   powDef {
   	\schemaVar \term int base, exp;
   	\schemaVar \variables int x;

	\find ( pow(base, exp) )
	\varcond(\notFreeIn(x, exp, base))
	\replacewith ( \if (exp >= 0) 
				   \then ( bprod{x;}(0, exp, base) )
				   \else ( undefinedPow(base,exp) )
				  )
   
   };           


binaryOrNeutralRight {
  \schemaVar \term int left;

  \find (binaryOr(left, 0))
  \replacewith (left)
  \heuristics(concrete)  
};

binaryOrNeutralLeft {
  \schemaVar \term int right;

  \find (binaryOr(0, right))
  \replacewith(right)
  \heuristics(concrete)  
};

binaryOrSign {
  \schemaVar \term int left, right;
  
  \find (binaryOr(left,right)) \sameUpdateLevel
  \add(\if (left >= 0 & right >= 0) \then (1) \else (-1) * binaryOr(left, right) >= 0 ==>)
  \heuristics(userTaclets1)
};


binaryOrInInt {
  \schemaVar \term int left, right;
  
  \find (binaryOr(left,right)) \sameUpdateLevel
  \add((inInt(left) & inInt(right)) -> inInt(binaryOr(left,right)) ==>)
  \heuristics(userTaclets1)
};

moduloIntFixpoint {

  \schemaVar \term int t;
  \assumes( inInt(t) ==> )
  \find( moduloInt( t ) ) \sameUpdateLevel
  \replacewith ( t )
  \heuristics (simplify)
};

moduloIntIsInInt {

  \schemaVar \term int t;
  \find( inInt( moduloInt( t ) ) )
  \replacewith ( true )

  \heuristics ( concrete )

};


binaryOrGte {
  \schemaVar \term int left, right; 
  \find (binaryOr(left,right)) \sameUpdateLevel

  // could be more general, moduloInt(left) >= 0
  \add((left >= 0 & right >= 0) -> (binaryOr(left, right) >= left & binaryOr(left,right) >= right &
         binaryOr(left,right) <= 2*\if (left>right) \then (left) \else (right))
        ==>)
  \heuristics(userTaclets1)
};


// orJint like divJint etc is always inInt as the result is moduloInt(result)
orJintInInt {
  \schemaVar \term int left, right;
  
  \find (orJint(left,right)) \sameUpdateLevel
  \add(inInt(orJint(left,right)) ==> )
  \heuristics(userTaclets1)
};


// binaryAnd

	binaryAndZeroRight {
	  \schemaVar \term int left;
	  \find ( binaryAnd(left, 0) )
	  \replacewith (0)
	  \heuristics (concrete)
	};
	
	binaryAndZeroLeft {
	  \schemaVar \term int right;
	  \find ( binaryAnd(0, right) )
	  \replacewith (0)
	  \heuristics (concrete)
	};
	
	
	binaryAndSymm {
	  \schemaVar \term int left, right;
	  \find ( binaryAnd (left, right) ) 
	  \replacewith ( binaryAnd(right, left) )
	};

	binaryAndOne {
	  \schemaVar \term int left;
	  \find ( binaryAnd(left, 1) )
	  \replacewith( \if (left % 2 = 0 ) \then ( 0 ) \else ( 1 ) )    
	  \heuristics ( simplify_enlarging )
	};

}



\rules {

   pow_literals {
    \schemaVar \term numbers iz,jz;
	\find (pow(Z(iz),Z(jz)))     
    \replacewith (#pow(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)
   };


   // Literal rules for binary &, |, ^  
   binaryAnd_literals {
    \schemaVar \term numbers iz,jz;
   
      \find (binaryAnd(Z(iz),Z(jz)))    
      \replacewith (#BinaryAnd(Z(iz),Z(jz)))
      \heuristics (simplify_literals)
      \displayname "binary_AND" 
   };

   binaryOr_literals {
       \schemaVar \term numbers iz,jz;
   
      \find (binaryOr(Z(iz),Z(jz)))    
      \replacewith (#BinaryOr(Z(iz),Z(jz)))
      \heuristics (simplify_literals)
      \displayname "binary_OR" 
   };

   binaryXOr_literals {
   
      \schemaVar \term numbers iz,jz;
   
      \find (binaryXOr(Z(iz),Z(jz)))   
      \replacewith (#BinaryXOr(Z(iz),Z(jz)))
      \heuristics (simplify_literals)
      \displayname "binary_XOR" };


   // Shift operations 
   
   shiftright_literals {
      \schemaVar \term numbers iz,jz;
      \find (shiftright(Z(iz),Z(jz)))        
      \replacewith (#ShiftRight(Z(iz), Z(jz)))
      \heuristics (simplify_literals)
      \displayname "shift" 
   };
   
   shiftleft_literals {
      \schemaVar \term numbers iz,jz;
      \find (shiftleft(Z(iz),Z(jz)))        
      \replacewith (#ShiftLeft(Z(iz), Z(jz)))
      \heuristics (simplify_literals)
      \displayname "shift" 
   };

}


\rules {

	javaShiftRightIntDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftrightJint(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
		\replacewith ( moduloInt(shiftright(left, mod(right,32) ) ) ) 
	    \heuristics (simplify_enlarging)
	};

	javaShiftRightLongDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftrightJlong(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		\replacewith ( moduloLong(shiftright(left, mod(right, 64) ) ) )
	    
	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftIntDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftleftJint(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
		\replacewith ( moduloInt(shiftleft(left, mod(right,32) ) ) ) 
	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftLongDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftleftJlong(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		\replacewith ( moduloLong(shiftleft(left, mod(right, 64) ) ) )
	    
	    \heuristics (simplify_enlarging)
	};


   unsignedShiftRightJintDef {
   	 \schemaVar \term int left, right;
	 \find ( unsignedshiftrightJint(left, right) )
	 \replacewith ( \if (left >= 0) \then (shiftrightJint(left, right)) 
	 			    \else (addJint(shiftrightJint(left, right), shiftleftJint(2,31-mod(right, 32))) )) 
	 \heuristics (simplify_enlarging)
   };
   
   xorJIntDef {
   	 \schemaVar \term int left, right;
   	 
   	 \find ( xorJint(left, right) )
   	 \replacewith ( moduloInt( binaryXOr(left,right) ) )	
     
     \heuristics(simplify)
   };

   orJIntDef {
   	 \schemaVar \term int left, right;
   	 
   	 \find ( orJint(left, right) )
   	 \replacewith ( moduloInt( binaryOr(left,right) ) )	
     
     \heuristics(simplify)
   };


   andJIntDef {
   	 \schemaVar \term int left, right;
   	 \find ( andJint(left, right) )
   	 \replacewith ( moduloInt( binaryAnd(left, right) ) )	
     
     \heuristics(simplify)
   };




}