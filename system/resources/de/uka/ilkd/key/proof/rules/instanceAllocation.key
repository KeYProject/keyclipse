// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2009 Universitaet Karlsruhe Germany
//                         Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

\sorts {
  \generic G;
  \generic H \extends Object;
  \generic J \extends Object;
  \generic K;
  \generic alphaObj \extends Object;
  \generic betaObj \extends Object;
}


\schemaVariables {
  \modalOperator { diamond, box } #allmodal ;
  
  \program <allocate> #allocate;
 
  \program SpecialConstructorReference #scr;
 
  \program InstanceCreation #n;
  \program ArrayCreation #na;
  \program ArrayInitializer #arrayinitializer;
 
  \program SimpleExpression #len;
   
  \program StaticVariable #staticField;
  \program Variable #v0;
  \program LeftHandSide #lhs;
  \program Type #t, #t2;

 \program ExecutionContext #ex;
 
  \term int idx0, idx1, allocNr;
   
  \variables int iv;
  \variables boolean bv;
  \variables G ov;
  \term G ot;
  \term H const;
  \term J obj;
  \formula post, b;
  
  \term boolean bool;
  \skolemTerm G sk ;
  
  \term J array;
  // attention some strategies rely on the name of the SV if you change it, please adapt
  // the strategies as well
  \term int negLit;
  \term int nonNegLit;
}
 
 
\rules(programRules:Java) {

//----------------------------------------------------------------------------
//-----------                 object creation                      -----------
//----------------------------------------------------------------------------

   instanceCreationAssignment { \find (\modality{#allmodal}{.. #lhs = #n;  ...}\endmodality(post)) 
        \varcond(\new(#v0, \typeof(#n)))
        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
		          #constructor-call(#v0, #n); 
                          #post-work(#v0);
			  #lhs = #v0;
		      ...}\endmodality(post)) 
	\heuristics(simplify_object_creation)
   };

   instanceCreation { \find (\modality{#allmodal}{.. #n ...}\endmodality(post)) 
        \varcond(\new(#v0, \typeof(#n)))
        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
		          #constructor-call(#v0, #n); 
                          #post-work(#v0); ...}\endmodality(post)) 
	\heuristics(simplify_object_creation)
   };


   allocateInstance {       
        \find (\modality{#allmodal}{.#t2().. #t(#lhs)::#t.#allocate(); ...}\endmodality(post))
        \varcond(\hasSort(#t2, H))
        
        //   Attention: critical for correctness: 
        //          * allocation should be done simultaneously
        //          * increment _needs_ arithmetical add operator (no mod semantics)
                           
        \replacewith ({#lhs := H::<get>(int::select(heap,null,java.lang.Object::<nextToCreate>)) || 
                       int::select(heap,null,java.lang.Object::<nextToCreate>) := add(int::select(heap,null,java.lang.Object::<nextToCreate>), 1) ||
                       heap := store(heap, (H::<get>(int::select(heap,null,java.lang.Object::<nextToCreate>))), java.lang.Object::<created>, TRUE)}
	                      \modality{#allmodal}{..  ...}\endmodality(post))	    
	\heuristics(simplify_object_creation)
   };

   special_constructor_call { 
        \find (\modality{#allmodal}{.. #scr ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #special-constructor-call(#scr); ...}\endmodality(post)) 
	\heuristics(simplify_object_creation)
   };

   

//----------------------------------------------------------------------------
//-----------                 array creation                      -----------
//----------------------------------------------------------------------------

   

   arrayCreation { 
        \find (\modality{#allmodal}{.. #lhs = #na; ...}\endmodality(post)) 	
        \varcond(\new(#v0, \typeof(#na)))	
        \replacewith (\modality{#allmodal}{.. 	
		#typeof(#na) #v0; 
		#init-array-creation(#v0, #na);
                #lhs = #v0; ...}\endmodality(post)) 
	    \heuristics(simplify_prog)
   };

   arrayCreationWithInitializers { 
        \find (\modality{#allmodal}{.. #lhs = #arrayinitializer; ...}\endmodality(post)) 	
        \varcond(\new(#v0, \typeof(#lhs)))	
        \replacewith (\modality{#allmodal}{.. 	
		#typeof(#lhs) #v0; 
		#init-array-creation(#v0, #arrayinitializer);
                #lhs = #v0; ...}\endmodality(post)) 
	   \heuristics(simplify_prog)
   };


// --------- createdness of objects -------------- //

   only_created_objects_are_referenced {
         \schemaVar \term Field f;
   	          
         \assumes (boolean::select(heap,obj,java.lang.Object::<created>) = TRUE, inReachableState ==>)	 
         \find ( alphaObj::select(heap, obj, f)) \sameUpdateLevel	 
         \add ( boolean::select(heap, alphaObj::select(heap,obj,f), java.lang.Object::<created>) = TRUE 
                | alphaObj::select(heap,obj,f) = null ==>)	 
         \displayname "referenced object is created"	 
   };
   
   only_created_objects_are_referenced_non_null {
         \schemaVar \term Field f;
         
         \assumes (boolean::select(heap,obj,java.lang.Object::<created>) = TRUE, inReachableState 
                    ==> alphaObj::select(heap,obj,f) = null)	 
         \find ( alphaObj::select(heap,obj,f) ) \sameUpdateLevel	 
         \add ( boolean::select(heap, alphaObj::select(heap,obj,f), java.lang.Object::<created>) = TRUE ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };

   only_created_objects_are_referenced_right {
         \schemaVar \term Field f;
   
         \assumes (inReachableState ==>)	 
         \find (==> boolean::select(heap, alphaObj::select(heap,obj,f), java.lang.Object::<created>) = TRUE)
         \add (boolean::select(heap, obj, java.lang.Object::<created>) = FALSE | obj=null | alphaObj::select(heap,obj,f) = null ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };

   only_created_objects_are_referenced_by_arrays_right {
         \assumes (inReachableState ==>)
         \find (==> boolean::select(heap, alphaObj::select(heap, array, arr(idx0)), java.lang.Object::<created>) = TRUE)
         \add (boolean::select(heap,array,java.lang.Object::<created>) = FALSE | array=null | alphaObj::select(heap,array,arr(idx0)) = null ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"	 
   };

/*
   enclosing_this_is_created{
         \assumes (obj.<created>@(java.lang.Object) = TRUE, inReachableState ==>)	 
         \find ( obj.#et ) \sameUpdateLevel
         \add ((obj.#et).<created>@(java.lang.Object) = TRUE  ==> obj.#et=null)
         \heuristics(inReachableStateImplication)
         \displayname "enclosing instance is created"
   };
*/
   
   // extremely common situation due to skolem constants introduced during proofs
   only_created_object_are_referenced_non_null2 {
         \schemaVar \term Field f;
      
         \assumes (boolean::select(heap,obj,java.lang.Object::<created>) = TRUE, inReachableState ==> const = null)
         \find ( alphaObj::select(heap,obj,f) = const ==> )	 
         \add ( boolean::select(heap, const, java.lang.Object::<created>) = TRUE ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };
   
   only_created_object_are_referenced_non_null3 {
         \schemaVar \term Field f;
   
         \assumes (boolean::select(heap, obj, java.lang.Object::<created>) = TRUE, inReachableState ==>)
         \find ( alphaObj::select(heap,obj,f) = H::<get>(allocNr) ==> )
         \varcond(\isReference[non_null](H))
         \add (boolean::select(heap, H::<get>(allocNr), java.lang.Object::<created>) = TRUE ==>)	 
         \heuristics(inReachableStateImplication)
         \displayname "referenced object is created"	 
   };
   

   only_created_object_are_referenced_by_arrays {	 
         \assumes (boolean::select(heap,array,java.lang.Object::<created>) = TRUE, inReachableState ==>)	 
         \find ( alphaObj::select(heap,array,arr(idx0)) ) \sameUpdateLevel
         \add (boolean::select(heap, alphaObj::select(heap,array,arr(idx0)), java.lang.Object::<created>) = TRUE 
               | alphaObj::select(heap,array,arr(idx0)) = null ==>)	 
         \displayname "indexed object is created"  
   };
   
   only_created_object_are_referenced_by_arrays_non_null {	 
         \assumes (boolean::select(heap,array,java.lang.Object::<created>) = TRUE, inReachableState 
                   ==> alphaObj::select(heap,array,arr(idx0)) = null)	 
         \find ( alphaObj::select(heap,array,arr(idx0)) ) \sameUpdateLevel	 
         \add ( boolean::select(heap, alphaObj::select(heap,array,arr(idx0)), java.lang.Object::<created>) = TRUE ==>)
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"  
   };
   
   // extremely common situation due to skolem constants introduced during proofs
   only_created_object_are_referenced_by_arrays_non_null2 {
         \assumes (boolean::select(heap,array,java.lang.Object::<created>) = TRUE, inReachableState ==> const = null)
         \find ( alphaObj::select(heap,array,arr(idx0)) = const ==> )	 
         \add ( boolean::select(heap,const,java.lang.Object::<created>) = TRUE ==>)
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"  
   };

   only_created_object_are_referenced_by_arrays_non_null3 {
         \assumes ( boolean::select(heap, array, java.lang.Object::<created>) = TRUE, inReachableState ==>)
         \find ( alphaObj::select(heap, array, arr(idx0)) = H::<get>(allocNr) ==> )
         \varcond(\isReference[non_null](H))
         \add (boolean::select(heap, H::<get>(allocNr), java.lang.Object::<created>) = TRUE ==>)
         \heuristics(inReachableStateImplication)
         \displayname "indexed object is created"  
   };
   
   only_created_object_are_referenced_by_arrays_2 {	 
         \assumes (boolean::select(heap,array,java.lang.Object::<created>) = TRUE, inReachableState ==>)	 
         \find (==> boolean::select(heap, alphaObj::select(heap,array,arr(idx0)), java.lang.Object::<created>) = TRUE ) 
         \replacewith (==> !alphaObj::select(heap,array,arr(idx0)) = null)
         \heuristics (simplify) 
         \displayname "indexed object is created"  
   };   
      
      
  
   static_fields_of_initialized_classes_are_null_or_reference_created_objects {
        \schemaVar \term Field f;
         
   	\assumes (inReachableState, boolean::select(heap,null,betaObj::<classInitialized>) = TRUE ==>)
   	\find (alphaObj::select(heap, null, f)) \sameUpdateLevel 
   	\varcond(\same(betaObj, \containerType(f)))
   	\add(alphaObj::select(heap, null, f) = null 
   	     | boolean::select(heap, alphaObj::select(heap, null, f), java.lang.Object::<created>) = TRUE ==>)
   	\displayname "static field welldefined"
   };
   
  
   static_fields_of_initialized_classes_reference_created_objects {
        \schemaVar \term Field f;
    
   	\assumes (inReachableState, boolean::select(heap,null,betaObj::<classInitialized>) = TRUE ==> alphaObj::select(heap,null,f) = null)
   	\find (alphaObj::select(heap,null,f)) \sameUpdateLevel 
   	\varcond(\same(betaObj, \containerType(f)))
   	\add(boolean::select(heap, alphaObj::select(heap,null,f), java.lang.Object::<created>) = TRUE ==>)
        \heuristics(inReachableStateImplication)
   	\displayname "static field welldefined"
   };

   // extremely common situation due to skolem constants introduced during proofs
   static_fields_of_initialized_classes_reference_created_objects2 {
        \schemaVar \term Field f;
   
   	\assumes (inReachableState, boolean::select(heap,null,betaObj::<classInitialized>) = TRUE ==> const = null)
   	\find (alphaObj::select(heap,null,f) = const ==>)
   	\varcond(\same(betaObj, \containerType(f)))
   	\add(boolean::select(heap, const, java.lang.Object::<created>) = TRUE ==>)
        \heuristics(inReachableStateImplication)
   	\displayname "static field welldefined"
   };

   

// ---------------   JVM invariants  ------------------------ //

   created_inv_index_in_bounds {
	 \assumes ( H::exactInstance(obj) = TRUE, inReachableState ==> )	          
         \find ( boolean::select(heap, obj, java.lang.Object::<created>) = TRUE ==>)
         \varcond(\isReference[non_null](\typeof(obj)), \notFreeIn(iv, obj))	 
         \add (\exists iv; (iv >= 0 & iv < int::select(heap,null,java.lang.Object::<nextToCreate>) & obj = H::<get>(iv)) ==>)	 
         \displayname "insert invariant (repository bounds)"	 
   };


   /*no longer sound
   created_to_known_index_in_bounds {	 
         \assumes (inReachableState ==>) 
         \find ( boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE ) \sameUpdateLevel
         \replacewith ( idx0 >= 0 & idx0 < (H::<get>(idx0)).<nextToCreate>@(java.lang.Object) )
         \heuristics (simplify)	 
         \displayname "created as known index in bounds"
   };
   */
     

   created_add_known_index_in_bounds {
	 \assumes ( boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE, inReachableState ==> )	          
         \find ( obj = H::<get>(idx0) ==> ) 
	 \varcond( \isReference[non_null](H) )	 
         \add (idx0 >= 0 & idx0 < int::select(heap, null, java.lang.Object::<nextToCreate>) ==>)	 
         \displayname "created add known index in bounds"	 
   };

   
   created_add_known_index_in_bounds_sym {
	 \assumes ( boolean::select(heap, obj, java.lang.Object::<created>) = TRUE, inReachableState ==> )	          
         \find ( H::<get>(idx0) = obj ==> ) 
	 \varcond(\isReference[non_null](H) )	 
         \add (idx0 >= 0 & idx0 < int::select(heap, null, java.lang.Object::<nextToCreate>) ==>)	 
         \displayname "created add known index in bounds"	 
   };
   
   created_add_known_index_in_bounds_2 {
	 \assumes ( obj = H::<get>(idx0), inReachableState ==> )	          
         \find ( boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE ==> ) 
	 \varcond( \isReference[non_null](H) )	 
         \add (idx0 >= 0 & idx0 < int::select(heap, null, java.lang.Object::<nextToCreate>) ==>)	 
         \displayname "created add known index in bounds"	 
   };
  

   objects_with_index_geq_next_to_create_are_not_created {
	 \assumes ( idx0 >= int::select(heap, null, java.lang.Object::<nextToCreate>), inReachableState ==> )	          
         \find ( boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE ==> ) 
	 \varcond( \isReference[non_null](H) )	 
         \replacewith(false ==>)	 
         \heuristics (simplify)
         \displayname "contradiction (object index is too great)"	 
   };   

   //--  rules designed to be used by strategies  --//

   //  START  //
   objects_with_negative_index_are_not_created {
	 \assumes ( obj = H::<get>(idx0), idx0 <= negLit, inReachableState ==> )
         \find ( boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE ==> ) 
         \varcond( \isReference[non_null](H) )	 
         \replacewith(\if (negLit < 0) \then ( false ) \else (boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE) ==>)	 
         \heuristics (system_invariant)
         \displayname "contradiction, if object index is negative"	 
   };
   
   
   objects_with_index_greater_next_to_create_are_not_createdsystem_invariant_for_created_2a_automated_use_3 {
	 \assumes ( obj = H::<get>(idx0), idx0 >= nonNegLit + int::select(heap, null, java.lang.Object::<nextToCreate>), inReachableState ==> )	          
         \find ( boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE ==> )
         \varcond( \isReference[non_null](H))	 
         \replacewith(\if (int::select(heap, null, java.lang.Object::<nextToCreate>) + nonNegLit >= 0) 
                      \then (false) 
                      \else (boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE)==>)	 
         \heuristics (system_invariant)
         \displayname "contradiction, if object index is too great"	 
   };
   //  END  //
   

   system_invariant_for_created_2a_sym {
	 \assumes ( H::<get>(idx0) = obj, inReachableState ==> )	          
         \find ( boolean::select(heap, obj, java.lang.Object::<created>) = TRUE ==> ) 
	 \varcond( \isReference[non_null](\typeof(obj)) )	 
         \add (idx0 >= 0 & idx0 < int::select(heap, null, java.lang.Object::<nextToCreate>) ==>)	 
         \displayname "system invariant for created"	 
   };
   
  /*no longer sound
   system_invariant_for_created_3 {
         \assumes ( inReachableState ==> boolean::select(heap, H::<get>(idx0), java.lang.Object::<created>) = TRUE)	          
         \find ( obj = H::<get>(idx0) ==> ) 
         \varcond( \isReference[non_null](H) )	 
         \add (idx0 < 0 | idx0 >= int::select(heap, null, java.lang.Object::<nextToCreate>) ==>)	 
         \displayname "system invariant for created"	 
   };
   */
   
   /*no longer sound
   system_invariant_for_created_3_sym {
	 \assumes ( inReachableState ==> boolean::select(heap, obj, java.lang.Object::<created>) = TRUE)	          
         \find ( H::<get>(idx0) = obj ==> ) 
         \varcond( \isReference[non_null](H) )	 
         \add (idx0 >= ((H)obj).<nextToCreate>@(java.lang.Object) ==>)	 
         \displayname "system invariant for created"	 
   };
   */

   repository_object_non_null {
        \find (G::<get>(allocNr) = null) \sameUpdateLevel
	\varcond(\isReference[non_null](G))
        \replacewith (false) 
        \heuristics(type_hierarchy_def)
        \displayname "repository object is not null"
   };

   nextToCreate_non_negative {
        \assumes(inReachableState ==>) 
        \find ( int::select(heap, null, java.lang.Object::<nextToCreate>) ) \sameUpdateLevel 
        \add ( int::select(heap, null, java.lang.Object::<nextToCreate>) >= 0 ==>) 
        \heuristics(inReachableStateImplication)
   };

   array_length_non_negative { 
   	\assumes(inReachableState, boolean::select(heap, array, java.lang.Object::<created>) = TRUE ==> array = null)
        \find (int::select(heap, array, Array::length) >= 0)  \sameUpdateLevel
        \replacewith (true)
	\displayname "array length is non-negative"
   };

   array_length_non_negative_2 { 
   	\assumes(inReachableState, boolean::select(heap, array, java.lang.Object::<created>) = TRUE ==> array = null)
        \find (int::select(heap, array, Array::length) < 0)   \sameUpdateLevel       
        \replacewith(false) 
	\displayname "array length is non-negative"
   };

   array_length_non_negative_3 { 
   	\assumes(inReachableState, boolean::select(heap, array, java.lang.Object::<created>) = TRUE ==> array = null)
        \find(int::select(heap, array, Array::length)) \sameUpdateLevel
        \add (int::select(heap, array, Array::length) >=0 ==>)
	\heuristics(inReachableStateImplication)
	\displayname "array length is non-negative"
   };

   //-- this rule is for automatic use --// 
   nextToCreate_non_negative_2 {
        \assumes(inReachableState ==>) 
        \find ( int::select(heap, null, java.lang.Object::<nextToCreate>) <= negLit ==>)
        \replacewith(\if (negLit < 0) \then (false) \else (int::select(heap, null, java.lang.Object::<nextToCreate>) <= negLit) ==>) 
        \heuristics (system_invariant)
   };


   identical_object_equal_index { 
        \find (G::<get>(idx0) = G::<get>(idx1)) 
        \varcond(\isReference[non_null](G))
        \replacewith (idx0 = idx1) 
        \heuristics(type_hierarchy_def)
	\displayname "identical objects equal index"
   };

   disjoint_repositories { 
	\find (G::<get>(idx0) = H::<get>(idx1))
	\varcond(\not\same(G, H))
        \replacewith (false)	
        \heuristics(type_hierarchy_def)
	\displayname "disjoint object repositories"
   };
   

   // instance for primitive types
   boolean_is_no_int {
   	\find(boolean::instance(bool)) 
   	\replacewith(TRUE)
        \heuristics(type_hierarchy_def)
   };
         

   all_integer_sorts_are_equals {
        \find(int::instance(idx0))
        \replacewith(TRUE)
        \heuristics(type_hierarchy_def)
   };
   
   
   //====================================//
   //                                    //
   //    Definition of exactInstance     //
   //                                    //
   //====================================//
        
   exact_instance_definition_reference { 
         \find (G::exactInstance(obj) = TRUE)
         \varcond(\not\isAbstractOrInterface(G),
                  \isReference[non_null](G),
                  \isReference[non_null](\typeof(obj)), 
                  \notFreeIn(iv, obj))	 
         \replacewith (\exists iv; (obj = G::<get>(iv)))
         \heuristics (simplify)	 
         \displayname "insert definition"	 
   };   
   
  exact_instance_definition_int {
         \find(int::exactInstance(idx0) = TRUE)
         \varcond(\notFreeIn(iv, idx0))
         \replacewith (\exists iv; (idx0 = iv))
         \heuristics (simplify)
         \displayname "insert definition"
   };

   exact_instance_definition_boolean {	 
         \find ( boolean::exactInstance(bool) = TRUE)
         \varcond(\notFreeIn(bv, bool))	 
         \replacewith (\exists bv; (bool = bv))
         \heuristics (simplify)	 
         \displayname "insert definition"	 
   };   
   
    exact_instance_definition_null {	 
         \find ( Null::exactInstance(obj) = TRUE)
         \varcond(\notFreeIn(bv, bool))	 
         \replacewith (obj = null)
         \heuristics (simplify)	 
         \displayname "insert definition"	 
   };   
   
   exact_instance_definition_known {	 
         \find (G::exactInstance(G::<get>(idx0)))
         \varcond(\isReference[non_null](G))	      
         \replacewith (TRUE)
         \heuristics (type_hierarchy_def)
         \displayname "known exact type"	 
   };   
   
   exact_instance_definition_known_eq {	 
    	 \assumes(G::<get>(idx0) = obj ==>)
         \find (G::exactInstance(obj)) \sameUpdateLevel
         \varcond(\isReference[non_null](G))	      
         \replacewith (TRUE)
         \heuristics (type_hierarchy_def)	 
         \displayname "known exact type"	 
   };   
   
   exact_instance_definition_known_false {	 
         \find (H::exactInstance(G::<get>(idx0)))
         \varcond(\not\same(G, H))      
         \replacewith (FALSE)
         \heuristics (type_hierarchy_def)	 
         \displayname "known exact type"	 
   };   
   
    exact_instance_definition_known_eq_false {	 
    	 \assumes(G::<get>(idx0) = obj ==>)
         \find (H::exactInstance(obj)) \sameUpdateLevel
         \varcond(\not\same(G, H))	      
         \replacewith (FALSE)
         \heuristics (type_hierarchy_def)	 
         \displayname "known exact type"	 
   };   
   
   exact_instance_for_interfaces_or_abstract_classes {	     	
         \find (G::exactInstance(obj)) 
         \varcond(\isAbstractOrInterface(G))	      
         \replacewith (FALSE)
         \heuristics (type_hierarchy_def)	 
         \displayname "interfaces or abstract classes have no exact instances"	 
   };   
   
}
