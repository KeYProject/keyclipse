// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


/** Abstract datatype of (untyped) partial maps.
 * @author Daniel Bruns
 */

\sorts {
    Free;
}


\functions {
    //getters
    any mapGet(Free, any);
    \unique any mapUndef;
    \unique int mapSizeUndefined;
    
    //constructors
    Free mapForeach{true,true}(boolean, any);
    Free mapEmpty;
    Free mapSingleton(any, any);
    Free mapOverride(Free, Free);
    Free seq2map(Seq);
    Free mapUpdate(Free, any, any);
    Free mapRemove(Free, any);
    int mapSize(Free);
}

\predicates {
    inDomain(Free, any);
    isFinite(Free);
}

\schemaVariables {
   \term Free m, m0, m1;
   \term boolean b;
   \term any x, y, z;
   \term alpha xa, za;
   \variables alpha v;
   \variables any vy;
}

\rules {

    //--------------------------------------------------------------------------
    //axioms
    //--------------------------------------------------------------------------

    getOfMapForeach {
        \find(mapGet(mapForeach{v;}(b,y),x))
        \sameUpdateLevel
        \replacewith(\if(alpha::instance(x)=TRUE)
                        \then({\subst v; alpha::cast(x)}
                              \if(b=TRUE)\then(y)\else(mapUndef))
                        \else(mapUndef))
      	\heuristics(simplify_enlarging)
    };

    //--------------------------------------------------------------------------
    //definitions (conservative extensions)
    //--------------------------------------------------------------------------

    inDomainOfMapForeach {
        \find(inDomain(mapForeach{v;}(b,y),x))
        \replacewith({\subst v; alpha::cast(x)}b = TRUE
		& alpha::instance(x)=TRUE )
        \heuristics(simplify)
    };

    defMapEmpty {
        \find(mapEmpty)
        \replacewith(mapForeach{vy;}(FALSE,42))
    };

    defMapSingleton {
        \find(mapSingleton(xa, y))
        \varcond(\notFreeIn(vy,xa,y))
        \replacewith(mapForeach{vy;}(
		\if(vy=any::cast(xa))\then(TRUE)\else(FALSE),y)
        )
    };

    defMapOverride {
        \find(mapOverride(m0,m1))
        \varcond(\notFreeIn(vy,m0,m1))
        \replacewith(mapForeach{vy;}(
		\if(inDomain(m0,vy)|inDomain(m1,vy))\then(TRUE)\else(FALSE),
		\if(inDomain(m1,vy))
			\then(mapGet(m1,vy))\else(mapGet(m0,vy))
	))
    };

    defSeq2Map {
        \schemaVar \term Seq s;
        \schemaVar \variables int ix;
        \find(seq2map(s))
        \varcond(\notFreeIn(ix,s))
        \replacewith(mapForeach{ix;}(
		\if(0 <= ix & ix < seqLen(s))\then(TRUE)\else(FALSE),
		any::seqGet(s,ix)
	))
    };
    
    // Added by Kai Wallisch
    mapUpdate{
	    \schemaVar \skolemTerm Free mapUpdateResult;
	    \schemaVar \term any key,value;
		\find(mapUpdate(m,key,value))
		\varcond(\notFreeIn(vy,m,key,value))
		\replacewith(mapUpdateResult)
		\add( mapUpdateResult = mapForeach{vy;}(
				( \if(inDomain(m,vy) | vy = key)
					\then(TRUE)
					\else(FALSE) ),
				( \if(vy = key)
					\then(value)
					\else(mapGet(m,vy)) )) & 
					( isFinite(m)-> (
						isFinite(mapUpdateResult)  &
						( mapSize(mapUpdateResult) = \if(inDomain(m, key))
							\then (mapSize(m))
							\else (mapSize(m) + 1) )) )
				==> )
		\heuristics(simplify_enlarging)
	};
    // Added by Kai Wallisch
    mapRemove{
	    \schemaVar \skolemTerm Free mapRemoveResult;
	    \schemaVar \term any key;
		\find(mapRemove(m,key))
		\varcond(\notFreeIn(vy,m,key))
		\replacewith(mapRemoveResult)
		\add( mapRemoveResult = mapForeach{vy;}(
				( \if(!inDomain(m,vy) | vy = key)
					\then(FALSE)
					\else(TRUE) ),
				( \if(vy = key)
					\then(mapUndef)
					\else(mapGet(m,vy)) )) & 
					( isFinite(m)-> (
						isFinite(mapRemoveResult)  &
						( mapSize(mapRemoveResult) = \if(inDomain(m, key))
							\then (mapSize(m) - 1)
							\else (mapSize(m)) )) )
				==> )
		\heuristics(simplify_enlarging)
	};
	
	// Added by Kai Wallisch (can be left out maybe)
	notInDomain{
		\find(==> inDomain(m,x))
		\add(mapGet(m,x) = mapUndef ==>)
        \heuristics(inReachableStateImplication)
	};

    //--------------------------------------------------------------------------
    //derived rules (proven sound in KeY)
    //--------------------------------------------------------------------------

    inDomainOfMapEmpty {
        \find(inDomain(mapEmpty, x))
        \replacewith(false)
        \heuristics(concrete)
    };

    inDomainOfMapSingleton {
        \find(inDomain(mapSingleton(x,y),z))
        \replacewith(x=z)
        \heuristics(simplify)
    };

    inDomainOfMapOverride {
        \find(inDomain(mapOverride(m0,m1),x))
        \replacewith(inDomain(m0,x)|inDomain(m1,x))
        \heuristics(simplify)
    };

    inDomainOfSeq2Map {
        \schemaVar \term Seq s;
        \find(inDomain(seq2map(s),x))
        \replacewith(int::instance(x) = TRUE & 
		0 <= int::cast(x) & int::cast(x) < seqLen(s))
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    getOfMapEmpty {
        \find(mapGet(mapEmpty,x))
        \sameUpdateLevel
        \replacewith(mapUndef)
        \heuristics(simplify)
    };

    getOfMapSingleton {
        \find(mapGet(mapSingleton(x,y),z))
        \sameUpdateLevel
        \replacewith(\if(x=z)\then(y)\else(mapUndef))
        \heuristics(simplify)
    };

    getOfMapOverride {
        \find(mapGet(mapOverride(m0,m1),x))
        \sameUpdateLevel
	\replacewith(\if(inDomain(m1,x))
		\then(mapGet(m1,x))\else(mapGet(m0,x)))
      	\heuristics(simplify_enlarging)
    };

    getOfSeq2Map {
        \schemaVar \term Seq s;
	\schemaVar \term int n;
        \find(mapGet(seq2map(s),n))
        \sameUpdateLevel
        \replacewith(\if(0 <= n & n < seqLen(s))
                     \then(any::seqGet(s,n))\else(mapUndef))
      	\heuristics(simplify_enlarging)
    };

    // actually an axiom, cannot be proven without HOL
    inDomainConcrete {
        \assumes(==> mapUndef = y)
        \find(mapGet(m,x) = y ==>)
        \add(inDomain(m,x) ==>)
        \heuristics(inReachableStateImplication)
    };
    
    //--------------------------------------------------------------------------
    //taclets for mapSize and isFinite (added by Kai Wallisch)
    //--------------------------------------------------------------------------
    
	sizeOfMapEmpty{
		\find(mapSize(mapEmpty))
		\varcond(\notFreeIn(v, m, x))
		\replacewith(0)
		\heuristics(simplify)
	};
	
	finiteMapEmpty{
		\find(isFinite(mapEmpty))
		\varcond(\notFreeIn(v, m, x))
		\replacewith(true)
		\heuristics(simplify)
	};
	
	mapEmptyUnique{
		\find(mapSize(m) = 0)
		\add(m = mapEmpty ==> )
        \heuristics(inReachableStateImplication)
	};
    
}
