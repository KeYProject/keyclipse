// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

/**
 * This file contains the rules for resolving the well-definedness
 * transformers (WD(Formula) and wd(any)). For formulas, these
 * rules are defined for the three different operators L, D and Y
 * (for more information on those, please consult explanations in
 * the taclet options).
 *
 * author Michael Kirsten
 */

\sorts {
	Formula;
}

\schemaVariables {
	\formula a, b, t;
	\term any c, d;
	\term int e, f, g;
	\term Heap h, m;
	\variables alpha i;
	\variables int j, k;
	\termlabel l;
	\term numbers n;
	\term Object o, q;
	\term Field p;
	\term LocSet r, s;
	\term Seq u, v;
	\term CharList x, y;
}

\transformers {
	wd(any);
	WD(Formula);
	T(Formula);
	F(Formula);
}

\rules {

// General rules
	wd_Atomic_Formula {

		\find (
			WD( a )
		)
		\varcond (
			\isAtomic(a)
		)
		\replacewith (
			true
		)
		\heuristics ( simplify )
	};

	wd_Atomic_Term {

		\find (
			wd( c )
		)
		\varcond (
			\isAtomic(c)
		)
		\replacewith (
			true
		)
		\heuristics ( simplify )
	};

	wd_Type_Cast {

		\find (
			wd( alpha::cast(c) )
		)
		\replacewith (
			wd(c) & (alpha::instance(c) = TRUE)
		)
		\heuristics ( simplify )
	};

	wd_Type_ExactInstance {

		\find (
			wd( alpha::exactInstance(c) )
		)
		\replacewith (
			wd(c)
		)
		\heuristics ( simplify )
	};

	wd_Type_Instance {

		\find (
			wd( alpha::instance(c) )
		)
		\replacewith (
			wd(c)
		)
		\heuristics ( simplify )
	};

	wd_Type_Pred_Instance {

		\find (
			WD( alpha::contains(c) )
		)
		\replacewith (
			wd(c)
		)
		\heuristics ( simplify )
	};

	wd_Equality_Pred {

		\find (
			WD( (c = d) )
		)
		\replacewith (
			wd(c) & wd(d)
		)
		\heuristics ( simplify )
	};

// Numerical rules

	wd_Numerical_Const {

		\find (
			wd( n )
		)
		\replacewith (
			true
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Const_Z {

		\find (
			wd( Z(n) )
		)
		\replacewith (
			true
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Const"
	};

	wd_Numerical_Const_C {

		\find (
			wd( C(n) )
		)
		\replacewith (
			true
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Const"
	};

	wd_Numerical_Op_Neg {
		\find (
			wd( neg(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Op_BitNeg {

		\find (
			wd( javaBitwiseNegation(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Neg"
	};

	wd_Numerical_Op_MinusJInt {

		\find (
			wd( unaryMinusJint(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Minus"
	};

	wd_Numerical_Op_MinusJLong {

		\find (
			wd( unaryMinusJlong(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Minus"
	};

	wd_Numerical_Op_MinusInt {

		\find (
			wd( javaUnaryMinusInt(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Minus"
	};

	wd_Numerical_Op_MinusLong {

		\find (
			wd( javaUnaryMinusLong(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Minus"
	};

	wd_Numerical_Op_MinusIntOverFlow {

		\find (
			wd( javaUnaryMinusIntOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Minus"
	};

	wd_Numerical_Op_MinusLongOverFlow {

		\find (
			wd( javaUnaryMinusLongOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Minus"
	};

	wd_Numerical_Cast_Byte {

		\find (
			wd( javaCastByte(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_Short {

		\find (
			wd( javaCastShort(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_Int {

		\find (
			wd( javaCastInt(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_Long {

		\find (
			wd( javaCastLong(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_Char {

		\find (
			wd( javaCastChar(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_ByteOverFlow {

		\find (
			wd( javaCastByteOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_ShortOverFlow {

		\find (
			wd( javaCastShortOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_IntOverFlow {

		\find (
			wd( javaCastIntOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_LongOverFlow {

		\find (
			wd( javaCastLongOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Cast_CharOverFlow {

		\find (
			wd( javaCastCharOverFlow(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Cast"
	};

	wd_Numerical_Mod_Byte {

		\find (
			wd( moduloByte(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Mod"
	};

	wd_Numerical_Mod_Short {

		\find (
			wd( moduloShort(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Mod"
	};

	wd_Numerical_Mod_Int {

		\find (
			wd( moduloInt(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Mod"
	};

	wd_Numerical_Mod_Long {

		\find (
			wd( moduloLong(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Mod"
	};

	wd_Numerical_Mod_Char {

		\find (
			wd( moduloChar(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Mod"
	};

	wd_Numerical_Op_Add {

		\find (
			wd( add(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Op_AddJInt {

		\find (
			wd( addJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Add"
	};

	wd_Numerical_Op_AddJLong {

		\find (
			wd( addJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Add"
	};

	wd_Numerical_Op_AddInt {

		\find (
			wd( javaAddInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Add"
	};

	wd_Numerical_Op_AddLong {

		\find (
			wd( javaAddLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Add"
	};

	wd_Numerical_Op_AddIntOverFlow {

		\find (
			wd( javaAddIntOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Add"
	};

	wd_Numerical_Op_AddLongOverFlow {

		\find (
			wd( javaAddLongOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Add"
	};

	wd_Numerical_Op_Sub {

		\find (
			wd( sub(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Op_SubJInt {

		\find (
			wd( subJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Sub"
	};

	wd_Numerical_Op_SubJLong {

		\find (
			wd( subJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Sub"
	};

	wd_Numerical_Op_SubInt {

		\find (
			wd( javaSubInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Sub"
	};

	wd_Numerical_Op_SubLong {

		\find (
			wd( javaSubLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Sub"
	};

	wd_Numerical_Op_SubIntOverFlow {

		\find (
			wd( javaSubIntOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Sub"
	};

	wd_Numerical_Op_SubLongOverFlow {

		\find (
			wd( javaSubLongOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Sub"
	};

	wd_Numerical_Op_Mul {

		\find (
			wd( mul(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Op_MulJInt {

		\find (
			wd( mulJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mul"
	};

	wd_Numerical_Op_MulJLong {

		\find (
			wd( mulJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mul"
	};

	wd_Numerical_Op_MulInt {

		\find (
			wd( javaMulInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mul"
	};

	wd_Numerical_Op_MulLong {

		\find (
			wd( javaMulLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mul"
	};

	wd_Numerical_Op_MulIntOverFlow {

		\find (
			wd( javaMulIntOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mul"
	};

	wd_Numerical_Op_MulLongOverFlow {

		\find (
			wd( javaMulLongOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mul"
	};

	wd_Numerical_Op_Div {

		\find (
			wd( div(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Op_JDiv {

		\find (
			wd( jdiv(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_DivJInt {

		\find (
			wd( divJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_DivJLong {

		\find (
			wd( divJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_DivInt {

		\find (
			wd( javaDivInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_DivLong {

		\find (
			wd( javaDivLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_DivIntOverFlow {

		\find (
			wd( javaDivIntOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_DivLongOverFlow {

		\find (
			wd( javaDivLongOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Div"
	};

	wd_Numerical_Op_ShiftRightInt {

		\find (
			wd( shiftrightJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_ShiftRightLong {

		\find (
			wd( shiftrightJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_ShiftLeftInt {

		\find (
			wd( shiftleftJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftLeft"
	};

	wd_Numerical_Op_ShiftLeftLong {

		\find (
			wd( shiftleftJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftLeft"
	};

	wd_Numerical_Op_UShiftRightInt {

		\find (
			wd( unsignedshiftrightJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_UShiftRightLong {

		\find (
			wd( unsignedshiftrightJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_OrJInt {

		\find (
			wd( orJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Or"
	};

	wd_Numerical_Op_OrJLong {

		\find (
			wd( orJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Or"
	};

	wd_Numerical_Op_BitOrInt {

		\find (
			wd( javaBitwiseOrInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Or"
	};

	wd_Numerical_Op_BitOrLong {

		\find (
			wd( javaBitwiseOrLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Or"
	};

	wd_Numerical_Op_AndJInt {

		\find (
			wd( andJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_And"
	};

	wd_Numerical_Op_AndJLong {

		\find (
			wd( andJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_And"
	};

	wd_Numerical_Op_BitAndInt {

		\find (
			wd( javaBitwiseAndInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_And"
	};

	wd_Numerical_Op_BitAndLong {

		\find (
			wd( javaBitwiseAndLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_And"
	};

	wd_Numerical_Op_XorJInt {

		\find (
			wd( xorJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Xor"
	};

	wd_Numerical_Op_XorJLong {

		\find (
			wd( xorJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Xor"
	};

	wd_Numerical_Op_BitXOrInt {

		\find (
			wd( javaBitwiseXOrInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Xor"
	};

	wd_Numerical_Op_BitXOrLong {

		\find (
			wd( javaBitwiseXOrLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Xor"
	};

	wd_Numerical_Op_Mod {

		\find (
			wd( mod(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Op_JMod {

		\find (
			wd( jmod(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mod"
	};

	wd_Numerical_Op_ModJInt {

		\find (
			wd( modJint(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mod"
	};

	wd_Numerical_Op_ModJLong {

		\find (
			wd( modJlong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mod"
	};

	wd_Numerical_Op_JavaMod {

		\find (
			wd( javaMod(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mod"
	};

	wd_Numerical_Op_JavaModOverFlow {

		\find (
			wd( javaModOverFlow(e, f) )
		)
		\replacewith (
			wd(e) & wd(f) & (f != 0)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_Mod"
	};

	wd_Numerical_Op_JavaShiftRightInt {

		\find (
			wd( javaShiftRightInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_JavaShiftRightLong {

		\find (
			wd( javaShiftRightLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_JavaShiftLeftInt {

		\find (
			wd( javaShiftLeftInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftLeft"
	};

	wd_Numerical_Op_JavaShiftLeftLong {

		\find (
			wd( javaShiftLeftLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftLeft"
	};

	wd_Numerical_Op_JavaUnsignedShiftRightInt {

		\find (
			wd( javaUnsignedShiftRightInt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Op_JavaUnsignedShiftRightLong {

		\find (
			wd( javaUnsignedShiftRightLong(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
		\displayname "wd_Numerical_Op_ShiftRight"
	};

	wd_Numerical_Quant_Bsum {

		\find (
			wd( bsum{j;} (e, f, g) )
		)
		\varcond (
			\notFreeIn(j, e),
			\notFreeIn(j, f)
		)
		\replacewith (
			wd(e) & wd(f) & \forall j; ((leq(e,j) & lt(j,f)) -> wd(g))
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Quant_Prod {

		\find (
			wd( bprod{j;} (e, f, g) )
		)
		\varcond (
			\notFreeIn(j, e),
			\notFreeIn(j, f)
		)
		\replacewith (
			wd(e) & wd(f) & \forall j; ((leq(e,j) & lt(j,f)) -> wd(g))
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_InByte {

		\find (
			WD( inByte(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_InChar {

		\find (
			WD( inChar(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_InShort {

		\find (
			WD( inShort(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_InInt {

		\find (
			WD( inInt(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_InLong {

		\find (
			WD( inLong(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_Lt {

		\find (
			WD( lt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_Leq {

		\find (
			WD( leq(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_Gt {

		\find (
			WD( gt(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_Geq {

		\find (
			WD( geq(e, f) )
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( simplify )
	};

	wd_Numerical_Pred_WellOrdered {

		\find (
			WD( wellOrderLeqInt(e, f) )
		 )
		\replacewith (
			wd(e) & wd(f)
		 )
		\heuristics ( simplify )
	};

// Location set rules

	wd_LocSet_AllFields {

		\find (
			wd( allFields(o) )
		)
		\replacewith (
			wd(o) & o != null
		)
		\heuristics ( simplify )
	};

	wd_LocSet_AllObjects {

		\find (
			wd( allObjects(p) )
		)
		\replacewith (
			wd(p)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_FreshLocs {

		\find (
			wd( freshLocs(h) )
		)
		\replacewith (
			wd(h) & wellFormed(h)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Singleton {

		\find (
			wd( singleton(o, p) )
		)
		\varcond (
			\not \isArray(o),
			\not \isStaticField(p)
		)
		\replacewith (
			wd(o) & wd(p) & o != null
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Singleton_Static {

		\find (
			wd( singleton(o, p) )
		)
		\varcond (
			\not \isArray(o),
			\isStaticField(p)
		)
		\replacewith (
			wd(o) & wd(p) & o = null
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Singleton_Arr {

		\find (
			wd( singleton(o, arr(e)) )
		)
		\varcond (
			\isArray(o)
		)
		\replacewith (
			wd(o) & wd(e) & o != null & leq(0,e) & lt(e,length(o))
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Union {

		\find (
			wd( union(r, s) )
		)
		\replacewith (
			wd(r) & wd(s)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Intersect {
		\find (
			wd( intersect(r, s) )
		)
		\replacewith (
			wd(r) & wd(s)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Diff {

		\find (
			wd( setMinus(r, s) )
		)
		\replacewith (
			wd(r) & wd(s)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_ArrRange {

		\find (
			wd( arrayRange(o, e, f) )
		)
		\varcond (
			\isArray(o)
		)
		\replacewith (
			wd(o) & o != null & wd(e) & wd(f) & leq(0,e) & leq(e,f) & lt(e,length(o))
		)
		\heuristics ( simplify )
	};

	wd_LocSet_AllElemsArr {

		\find (
			wd( allElementsOfArray(h, o, r) )
		)
		\varcond (
			\isArray(o)
		)
		\replacewith (
			wd(h) & wd(o) & o != null & wd(r) & boolean::select(h, o, java.lang.Object::<created>) = TRUE
			& wellFormed(h)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_AllElemsArrLocsets {

		\find (
			wd( allElementsOfArrayLocsets(h, o, r) )
		)
		\varcond (
			\isArray(o)
		)
		\replacewith (
			wd(h) & wd(o) & o != null & wd(r) & boolean::select(h, o, java.lang.Object::<created>) = TRUE
			& wellFormed(h)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_InfiniteUnion {

		\find (
			wd( infiniteUnion{j;}(r) )
		)
		\replacewith (
			\forall j; wd(r)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Pred_ElementOf {

		\find (
			WD( elementOf(o, p, r) )
		)
		\varcond (
			\not \isStaticField(p)
		)
		\replacewith (
			wd(o) & wd(p) & wd(r) & o != null
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Pred_ElementOf_Static {

		\find (
			WD( elementOf(o, p, r) )
		)
		\varcond (
			\isStaticField(p)
		)
		\replacewith (
			wd(o) & wd(p) & wd(r) & o = null
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Pred_Subset {

		\find (
			WD( subset(r, s) )
		)
		\replacewith (
			wd(r) & wd(s)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Pred_Disjoint {
		\find (
			WD( disjoint(r, s) )
		)
		\replacewith (
			wd(r) & wd(s)
		)
		\heuristics ( simplify )
	};

	wd_LocSet_Pred_InHeap {

		\find (
			WD( createdInHeap(r, h) )
		)
		\replacewith (
			wd(r) & wd(h) & wellFormed(h)
		)
		\heuristics ( simplify )
	};

// Heap rules

	wd_Heap_ArrLength {

		\find (
			wd( length(o) )
		)
		\varcond (
			\isArray(o)
		)
		\replacewith (
			o != null & wd(o)
		)
		\heuristics ( simplify )
	};

	wd_Heap_Create {

		\find (
			wd( create(h, o) )
		 )
		\replacewith (
			wd(h) & wd(o) & o != null & wellFormed(h)
		 )
		\heuristics ( simplify )
	};

	wd_Heap_Reference_Created {

		\find (
			wd( alpha::select(h, o, java.lang.Object::<created>) )
		)
		\replacewith (
			wd(h) & wd(o) & o != null & wellFormed(h)
		)
		\heuristics ( simplify )
	};

	wd_Heap_Reference {

		\find (
			wd( alpha::select(h, o, p) )
		)
		\varcond (
			\not \isArray(o),
			\not \isStaticField(p)
		)
		\replacewith (
			wd(o) & o != null & wd(h) & wd(p) & wellFormed(h)
			& (p = java.lang.Object::<created> | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
		)
		\heuristics ( simplify )
	};

	wd_Heap_Reference_Static {

		\find (
			wd( alpha::select(h, o, p) )
		)
		\varcond (
			\not \isArray(o),
			\isStaticField(p)
		)
		\replacewith (
			wd(h) & wd(o) & o = null & wd(p) & wellFormed(h)
		)
		\heuristics ( simplify )
	};

	wd_Heap_Reference_Array {

		\find (
			wd( alpha::select(h, o, arr(e)) )
		)
		\varcond (
			\isArray(o)
		)
		\replacewith (
			wd(o) & o != null & boolean::select(h, o, java.lang.Object::<created>) = TRUE
			& wd(h) & wd(e) & leq(0,e) & lt(e,length(o)) & wellFormed(h)
		)
		\heuristics ( simplify )
	};

	wd_Heap_Anon {

		\find (
			wd( anon(h, r, m) )
		 )
		\replacewith (
			wd(h) & wd(r) & wd(m) & wellFormed(h) & wellFormed(m)
		 )
		\heuristics ( simplify )
	};

	wd_Heap_Memset {

		\find (
			wd( memset(h, r, c) )
		 )
		\replacewith (
			wd(h) & wd(r) & wd(c) & wellFormed(h)
		 )
		\heuristics ( simplify )
	};

	wd_Heap_Store {

		\find (
			wd( store(h, o, p, c) )
		 )
		\replacewith (
			wd(h) & wd(o) & o != null & wd(p) & wd(c) & boolean::select(h, o, java.lang.Object::<created>) = TRUE
			& wellFormed(h)
		 )
		\heuristics ( simplify )
	};

	wd_Heap_Pred_WellFormed {

		\find (
			WD( wellFormed(h) )
		)
		\replacewith (
			wd(h)
		)
		\heuristics ( simplify )
	};

	wd_Heap_Pred_ArrStoreValid {
		\find (
			WD( arrayStoreValid(c, d) )
		 )
		\replacewith (
			wd(c) & wd(d)
		 )
		\heuristics ( simplify )
	};

// Reach rules

	wd_Reach_Pred_Acc {

		\find (
			WD( acc(h, r, o, q) )
		)
		\replacewith (
			wd(h) & wd(r) & wd(o) & o != null & wd(q) & q != null & wellFormed(h)
			& boolean::select(h, o, java.lang.Object::<created>) = TRUE
			& boolean::select(h, q, java.lang.Object::<created>) = TRUE
		)
		\heuristics ( simplify )
	};

	wd_Reach_Pred_Reach {

		\find (
			WD( reach(h, r, o, q, e) )
		)
		\replacewith (
			wd(h) & wd(r) & wd(o) & o != null & wd(q) & q != null & wd(e) & wellFormed(h)
			& boolean::select(h, o, java.lang.Object::<created>) = TRUE
			& boolean::select(h, q, java.lang.Object::<created>) = TRUE
		)
		\heuristics ( simplify )
	};

// Sequent rules

	wd_Seq_Length {

		\find (
			wd( seqLen(u) )
		)
		\replacewith (
			wd(u)
		)
		\heuristics ( simplify )
	};

	wd_Seq_Singleton {

		\find (
			wd( seqSingleton(c) )
		)
		\replacewith (
			wd(c)
		)
		\heuristics ( simplify )
	};

	wd_Seq_Reverse {

		\find (
			wd( seqReverse(u) )
		)
		\replacewith (
			wd(u)
		)
		\heuristics ( simplify )
	};

	wd_Seq_NPermInv {

		\find (
			wd( seqNPermInv(u) )
		 )
		\replacewith (
			wd(u)
		 )
		\heuristics ( simplify )
	};

	wd_Seq_Get {

		\find (
			wd( alpha::seqGet(u, e) )
		)
		\replacewith (
			wd(u) & wd(e) & leq(0,e) & lt(e,seqLen(u))
		)
		\heuristics ( simplify )
	};

	wd_Seq_IndexOf {

		\find (
			wd( seqIndexOf(u, c) )
		)
		\replacewith (
			wd(u) & wd(c)
		)
		\heuristics ( simplify )
	};

	wd_Seq_Concat {

		\find (
			wd( seqConcat(u, v) )
		)
		\replacewith (
			wd(u) & wd (v)
		)
		\heuristics ( simplify )
	};

	wd_Seq_Remove {

		\find (
			wd( seqRemove(u, e) )
		)
		\replacewith (
			wd(u) & wd(e) & leq(0,e) & lt(e,seqLen(u))
		)
		\heuristics ( simplify )
	};

	wd_Seq_Sub {

		\find (
			wd( seqSub(u, e, f) )
		)
		\replacewith (
			wd(u) & wd(e) & wd(f) & leq(0,e) & leq(e,f) & leq(e,seqLen(u))
		)
		\heuristics ( simplify )
	};

	wd_Seq_Swap {

		\find (
			wd( seqSwap(u, e, f) )
		)
		\replacewith (
			wd(u) & wd(e) & wd(f) & leq(0,e) & leq(0,f) & lt(e,seqLen(u)) & lt(f,seqLen(u))
		)
		\heuristics ( simplify )
	};

	wd_Seq_Def {

		\find (
			wd( seqDef{j;} (e, f, c) )
		)
		\varcond (
			\notFreeIn(j, e),
			\notFreeIn(j, f)
		)
		\replacewith (
			wd(e) & wd(f) & \forall j; ((leq(e,j) & lt(j,f)) -> wd(c))
		)
		\heuristics ( simplify )
	};

	wd_Seq_Pred_Perm {

		\find (
			WD( seqPerm(u, v) )
		 )
		\replacewith (
			wd(u) & wd(v)
		 )
		\heuristics ( simplify )
	};

	wd_Seq_Pred_NPerm {

		\find (
			WD( seqNPerm(u) )
		 )
		\replacewith (
			wd(u)
		 )
		\heuristics ( simplify )
	};

// String rules

	wd_String_Length {

		\find (
			wd( clLength(x) )
		)
		\replacewith (
			wd(x)
		)
		\heuristics ( simplify )
	};

	wd_String_Translate {

		\find (
			wd( clTranslateInt(e) )
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( simplify )
	};

	wd_String_RmvZeros {

		\find (
			wd( clRemoveZeros(x) )
		)
		\replacewith (
			wd(x)
		)
		\heuristics ( simplify )
	};

	wd_String_Hash {

		\find (
			wd( clHashCode(x) )
		)
		\replacewith (
			wd(x)
		)
		\heuristics ( simplify )
	};

	wd_String_Cat {

		\find (
			wd( clCat(x, y) )
		)
		\replacewith (
			wd(x) & wd(y)
		)
		\heuristics ( simplify )
	};

	wd_String_Cons {

		\find (
			wd( clCons(e, x) )
		)
		\replacewith (
			wd(e) & wd(x) & leq(0,e)
		)
		\heuristics ( simplify )
	};

	wd_String_CharAt {

		\find (
			wd( clCharAt(e, x) )
		)
		\replacewith (
			wd(e) & wd(x) & leq(0, e) & lt(e, clLength(x))
		)
		\heuristics ( simplify )
	};

	wd_String_Concat {

		\find (
			wd( clConcat(x, y) )
		)
		\replacewith (
			wd(x) & wd(y)
		)
		\heuristics ( simplify )
	};

	wd_String_IndexOfChar {

		\find (
			wd( clIndexOfChar(e, f, x) )
		)
		\replacewith (
			wd(e) & wd(f) & wd(x) & leq(0, e) & leq(e, f) & lt(f, clLength(x))
		)
		\heuristics ( simplify )
	};

	wd_String_Sub {

		\find (
			wd( clSub(e, f, x) )
		)
		\replacewith (
			wd(e) & wd(f) & wd(x) & leq(0, e) & lt(e, f) & lt(f, clLength(x))
		)
		\heuristics ( simplify )
	};

	wd_String_IndexOfStr {

		\find (
			wd( clIndexOfCl(x, e, y) )
		)
		\replacewith (
			wd(x) & wd(e) & wd(y) & leq(0, e) & lt(add(e, clLength(x)), clLength(y))
		)
		\heuristics ( simplify )
	};

	wd_String_LastIndexOfChar {

		\find (
			wd( clLastIndexOfChar(e, f, x) )
		)
		\replacewith (
			wd(e) & wd(f) & wd(x) & leq(0, e) & leq(e, f) & lt(f, clLength(x))
		)
		\heuristics ( simplify )
	};

	wd_String_LastIndexOfStr {

		\find (
			wd( clLastIndexOfCl(x, e, y) )
		)
		\replacewith (
			wd(x) & wd(e) & wd(y) & leq(0, e) & lt(add(e, clLength(x)), clLength(y))
		)
		\heuristics ( simplify )
	};

	wd_String_Replace {

		\find (
			wd( clReplace(e, f, x) )
		)
		\replacewith (
			wd(e) & wd(f) & wd(x) & leq(0,e) & leq(0,f)
		)
		\heuristics ( simplify )
	};

	wd_String_Pred_StartsWith {

		\find (
			WD( clStartsWith(x, y) )
		)
		\replacewith (
			wd(x) & wd(y) & leq(clLength(x), clLength(y))
		)
		\heuristics ( simplify )
	};

	wd_String_Pred_EndsWith {

		\find (
			WD( clEndsWith(x, y) )
		)
		\replacewith (
			wd(x) & wd(y) & leq(clLength(x), clLength(y))
		)
		\heuristics ( simplify )
	};

	wd_String_Pred_Contains {

		\find (
			WD( clContains(x, y) )
		)
		\replacewith (
			wd(x) & wd(y) & leq(clLength(x), clLength(y))
		)
		\heuristics ( simplify )
	};
}

\rules(wdOperator:L) {

	wd_Logical_Op_Neg {

		\find (
			WD( !a )
		)
		\replacewith (
			WD(a)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_And {

		\find (
			WD( (a & b)<<l>> )
		)
		\varcond (
			\not \hasLabel(l, SC)
		)
		\replacewith (
			WD(a) & WD(b)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_AndSC {

		\find (
			WD( ((a & b)<<l>>) )
		)
		\varcond (
			\hasLabel(l, SC)
		)
		\replacewith (
			WD(a) & (a -> WD(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Or {

		\find (
			WD( (a | b)<<l>> )
		)
		\varcond (
			\not \hasLabel(l, SC)
		)
		\replacewith (
			WD(a) & WD(b)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_OrSC {

		\find (
			WD( ((a | b)<<l>>) )
		)
		\varcond (
			\hasLabel(l, SC)
		)
		\replacewith (
			WD(a) & (!a -> WD(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Imp {

		\find (
			WD( (a -> b) )
		)
		\replacewith (
			WD(a) & (a -> WD(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Eqv {

		\find (
			WD( (a <-> b) )
		)
		\replacewith (
			WD(a) & WD(b)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Cond_Expr {

		\find (
			wd( \if (a) \then (c) \else (d) )
		)
		\replacewith (
			WD(a) & (a -> wd(c)) & (!a -> wd(d))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Cond_Form {

		\find (
			WD( \if (a) \then (b) \else (t) )
		)
		\replacewith (
			WD(a) & (a -> WD(b)) & (!a -> WD(t))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_ExCond_Expr {

		\find (
			wd( \ifEx j; (a) \then (c) \else (d) )
		)
		\varcond (
			\notFreeIn(j, d)
		)
		\replacewith (
			(\forall j; WD(a)) & (\forall j; (a -> wd(c))) & ((\forall j; !a) -> wd(d))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_ExCond_Form {

		\find (
			WD( \ifEx j; (a) \then (b) \else (t) )
		)
		\varcond (
			\notFreeIn(j, t)
		)
		\replacewith (
			(\forall j; WD(a)) & (\forall j; (a -> WD(b))) & ((\forall j; !a) -> WD(t))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Quant_All {

		\find (
			WD( \forall i; a )
		)
		\replacewith (
			\forall i; WD(a)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Quant_Exist {

		\find (
			WD( \exists i; a )
		)
		\replacewith (
			\forall i; WD(a)
		)
		\heuristics ( simplify )
	};
}

\rules(wdOperator:D) {

	wd_Logical_Op_Neg {

		\find (
			WD( !a )
		)
		\replacewith (
			WD(a)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_And {

		\find (
			WD( (a & b) )
		)
		\replacewith (
			(WD(a) & !a) | (WD(b) & !b) | (WD(a) & WD(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Or {

		\find (
			WD( (a | b) )
		)
		\replacewith (
			(WD(a) & a) | (WD(b) & b) | (WD(a) & WD(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Imp {

		\find (
			WD( (a -> b) )
		)
		\replacewith (
			(WD(a) & !a) | (WD(b) & b) | (WD(a) & WD(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Eqv {

		\find (
			WD( (a <-> b) )
		)
		\replacewith (
			WD(a) & WD(b)
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Cond_Expr {

		\find (
			wd( \if (a) \then (c) \else (d) )
		)
		\replacewith (
			(WD(a) & a & wd(c)) | (WD(a) & !a & wd(d)) | (wd(c) & wd(d) & (c = d))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Cond_Form {

		\find (
			WD( \if (a) \then (b) \else (t) )
		)
		\replacewith (
			(WD(a) & a & WD(b)) | (WD(a) & !a & WD(t)) | (WD(b) & WD(t) & (b <-> t))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_ExCond_Expr {

		\find (
			wd( \ifEx j; (a) \then (c) \else (d) )
		)
		\varcond (
			\notFreeIn(j, d)
		)
		\replacewith (
			(\exists j; (WD(a) & a & wd(c)))
			| (\forall j; (WD(a) & !a & wd(d)))
			| (\forall j; (wd(c) & wd(d) & (c = d)))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_ExCond_Form {

		\find (
			WD( \ifEx j; (a) \then (b) \else (t) )
		)
		\varcond (
			\notFreeIn(j, t)
		)
		\replacewith (
			(\exists j; (WD(a) & a & WD(b)))
			| (\forall j; (WD(a) & !a & WD(t)))
			| (\forall j; (WD(b) & WD(t) & (b <-> t)))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Quant_All {

		\find (
			WD( \forall i; a )
		)
		\replacewith (
			(\exists i; (WD(a) & !a)) | (\forall i; WD(a))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Quant_Exist {

		\find (
			WD( \exists i; a )
		)
		\replacewith (
			(\exists i; (WD(a) & a)) | (\forall i; WD(a))
		)
		\heuristics ( simplify )
	};
}

\rules(wdOperator:Y) {

	wd_T_Logical_Op_Neg {

		\find (
			T( !a )
		)
		\replacewith (
			F(a)
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_Neg {

		\find (
			F( !a )
		)
		\replacewith (
			T(a)
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Op_And {

		\find (
			T( (a & b) )
		)
		\replacewith (
			T(a) & T(b)
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_And {

		\find (
			F( (a & b) )
		)
		\replacewith (
			F(a) | F(b)
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Op_Or {

		\find (
			T( (a | b) )
		)
		\replacewith (
			T(a) | T(b)
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_Or {

		\find (
			F( (a | b) )
		)
		\replacewith (
			F(a) & F(b)
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Op_Imp {

		\find (
			T( (a -> b) )
		)
		\replacewith (
			F(a) | T(b)
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_Imp {

		\find (
			F( (a -> b) )
		)
		\replacewith (
			T(a) & F(b)
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Op_Eqv {

		\find (
			T( (a <-> b) )
		)
		\replacewith (
			(T(a) & T(b)) | (F(a) & F(b))
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_Eqv {

		\find (
			F( (a <-> b) )
		)
		\replacewith (
			(T(a) & F(b)) | (F(a) & T(b))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_Cond_Expr {

		\find (
			wd( \if (a) \then (c) \else (d) )
		)
		\replacewith (
			(T(a) & wd(c)) | (F(a) & wd(d)) | (wd(c) & wd(d) & (c = d))
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Op_Cond_Form {

		\find (
			T( \if (a) \then (b) \else (t) )
		)
		\replacewith (
			(T(a) & T(b)) | (F(a) & T(t)) | (T(b) & T(t))
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_Cond_Form {

		\find (
			F( \if (a) \then (b) \else (t) )
		)
		\replacewith (
			(T(a) & F(b)) | (F(a) & F(t)) | (F(b) & F(t))
		)
		\heuristics ( simplify )
	};

	wd_Logical_Op_ExCond_Expr {

		\find (
			wd( \ifEx j; (a) \then (c) \else (d) )
		)
		\varcond (
			\notFreeIn(j, d)
		)
		\replacewith (
			(\exists j; (T(a) & wd(c)))
			| (\forall j; (F(a) & wd(d)))
			| (\forall j; (wd(c) & wd(d) & (c = d)))
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Op_ExCond_Form {

		\find (
			T( \ifEx j; (a) \then (b) \else (t) )
		)
		\varcond (
			\notFreeIn(j, t)
		)
		\replacewith (
			(\exists j; (T(a) & T(b)))
			| (\forall j; (F(a) & T(t)))
			| (\forall j; (T(b) & T(t)))
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Op_ExCond_Form {

		\find (
			F( \ifEx j; (a) \then (b) \else (t) )
		)
		\varcond (
			\notFreeIn(j, t)
		)
		\replacewith (
			(\exists j; (T(a) & F(b)))
			| (\forall j; (F(a) & F(t)))
			| (\forall j; (F(b) & F(t)))
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Quant_All {

		\find (
			T( \forall i; a )
		)
		\replacewith (
			\forall i; T(a)
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Quant_All {

		\find (
			F( \forall i; a )
		)
		\replacewith (
			\exists i; F(a)
		)
		\heuristics ( simplify )
	};

	wd_T_Logical_Quant_Exist {

		\find (
			T( \exists i; a )
		)
		\replacewith (
			\exists i; T(a)
		)
		\heuristics ( simplify )
	};

	wd_F_Logical_Quant_Exist {

		\find (
			F( \exists i; a )
		)
		\replacewith (
			\forall i; F(a)
		)
		\heuristics ( simplify )
	};

// Split and resolve rules

	wd_Y_Split {

		\find (
			WD( a )
		 )
		\varcond (
			\hasSubFormulas(a)
		)
		\replacewith (
			T(a) | F(a)
		 )
		\heuristics ( simplify )
	};

	wd_T_Resolve {

		\find (
			T( a )
		 )
		\varcond (
			\not \hasSubFormulas(a)
		)
		\replacewith (
			WD(a) & a
		 )
		\heuristics ( simplify )
	};

	wd_F_Resolve {

		\find (
			F( a )
		 )
		\varcond (
			\not \hasSubFormulas(a)
		)
		\replacewith (
			WD(a) & !a
		 )
		\heuristics ( simplify )
	};
}