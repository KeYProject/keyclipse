\sorts{
	//any;
	//boolean;
	//int;
	//numbers;
	//variable;
	Formula;
	\generic I;
}

\schemaVariables {
	\formula a;
	\formula b;
	\variables I i, j;
	\term any c;
	\term any d;
	\term int e;
	\term int f;
	\term numbers n;
	\term any v;
}

\functions{
	boolean TRUE;
	boolean FALSE;
	Null null;
}

\transformers {
	wd(any);
	WD(Formula);
}

\rules {
	wd_Prim_Expr_True_Bool {

		\find (
			wd(TRUE)
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Prim_Expr_True_Form {

		\find (
			WD(true)
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Prim_Expr_False_Bool {

		\find (
			wd(FALSE)
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Prim_Expr_False_Form {

		\find (
			WD(false)
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Logical_Op_Neg {

		\find (
			WD(!a)
		)
		\replacewith (
			WD(a)
		)
		\heuristics ( concrete )
	};

	wd_Logical_Op_Or {

		\find (
			WD((a | b))
		)
		\replacewith (
// We need some way to distinguish "|" from "|<Shortcut>" on taclet level,
// probably a new \varcond
			WD(a) & (!a -> WD(b))
		)
		\heuristics ( concrete )
	};

	wd_Logical_Op_And {

		\find (
			WD((a & b))
		)
		\replacewith (
// We need some way to distinguish "&" from "&<Shortcut>" on taclet level,
// probably a new \varcond
			WD(a) & (a -> WD(b))
		)
		\heuristics ( concrete )
	};

	wd_Logical_Op_Imp {

		\find (
			WD((a -> b))
		)
		\replacewith (
			(WD(a) & !a) | (WD(a) & WD(b))
		)
		\heuristics ( concrete )
	};

	wd_Logical_Op_Eqv {

		\find (
			WD((a <-> b))
		)
		\replacewith (
			WD(a) & WD(b)
		)
		\heuristics ( concrete )
	};

	wd_Equality_Pred_Eq {

		\find (
			WD((c = d))
		)
		\replacewith (
			wd(c) & wd(d)
		)
		\heuristics ( concrete )
	};

	wd_Equality_Pred_Lt {

		\find (
			WD(lt(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Equality_Pred_Leq {

		\find (
			WD(leq(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Equality_Pred_Gt {

		\find (
			WD(gt(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Equality_Pred_Geq {

		\find (
			WD(geq(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitNeg {

		\find (
			wd(javaBitwiseNegation(e))
		)
		\replacewith (
			wd(e)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_Add {

		\find (
			wd(add(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_Sub {

		\find (
			wd(sub(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_Mul {

		\find (
			wd(mul(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_Div {

		\find (
			wd(div(e,f))
		)
		\replacewith (
			wd(e) & wd(f) & !(f = 0)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_ShiftRightInt {

		\find (
			wd(shiftrightJint(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_ShiftRightLong {

		\find (
			wd(shiftrightJlong(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_ShiftLeftInt {

		\find (
			wd(shiftleftJint(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_ShiftLeftLong {

		\find (
			wd(shiftleftJlong(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_UShiftRightInt {

		\find (
			wd(unsignedshiftrightJint(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_UShiftRightLong {

		\find (
			wd(unsignedshiftrightJlong(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitOrInt {

		\find (
			wd(javaBitwiseOrInt(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitOrLong {

		\find (
			wd(javaBitwiseOrLong(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitAndInt {

		\find (
			wd(javaBitwiseAndInt(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitAndLong {

		\find (
			wd(javaBitwiseAndLong(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitXOrInt {

		\find (
			wd(javaBitwiseXOrInt(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_BitXOrLong {

		\find (
			wd(javaBitwiseXOrLong(e,f))
		)
		\replacewith (
			wd(e) & wd(f)
		)
		\heuristics ( concrete )
	};

	wd_Numerical_Op_Mod {

		\find (
			wd(javaMod(e,f))
		)
		\replacewith (
			wd(e) & wd(f) & !(f = 0)
		)
		\heuristics ( concrete )
	};

	wd_Conditional_Expr {

		\find (
			wd(\if (a) \then (c) \else (d))
		)
		\replacewith (
			(a & WD(a) & wd(c))
					| (!a & WD(a) & wd(d))
		)
		\heuristics ( concrete )
	};

	wd_Ref_Expr_Int {

		\find (
			wd(Z(n))
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Ref_Expr_Const {

		\find (
			wd(n)
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

// 	wd_Ref_Expr_LocVar {
//
// We need some type of new \varcond like "is in namespace (programVariables
// or functions)" to (trivially) simplify well-definedness of those to true

// 		\find (
// 			wd(v)
// 		)
// 		\varcond (
// 			\isLocalVariable(v)
// 		)
// 		\replacewith (
// 			true
// 		)
// 		\heuristics ( concrete )
// 	};

	wd_Ref_Expr_Empty {

		\find (
			wd( empty )
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Ref_Expr_Null {

		\find (
			wd( null )
		)
		\replacewith (
			true
		)
		\heuristics ( concrete )
	};

	wd_Logical_Quant_All {

		\find (
			WD(\forall i; a)
		)
		\replacewith (
			\forall i; WD(a)
		)
		\heuristics ( concrete )
	};

	wd_Logical_Quant_Exist {

		\find (
			WD(\exists i; a)
		)
		\replacewith (
			\forall i; WD(a)
		)
		\heuristics ( concrete )
	};
}