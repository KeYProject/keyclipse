//

\sorts {
}


\functions {
//    LocSet java.lang.Object::$equivalenceLocs(Heap, java.lang.Object);
//    LocSet java.lang.Object::$equivalenceRecursionLocs(Heap, java.lang.Object);
}


\predicates {
    equals(Heap, java.lang.Object, Heap, java.lang.Object);
    equalsAtLocs(Heap, Heap, LocSet, LocSet);
}


\programVariables {
}


   

\rules {


    Eq_axiom_null {
        \schemaVar \term Heap h1, h2;

        \find( equals(h1, null, h2, null) )
        \sameUpdateLevel
        \replacewith( true )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_1 {
        \schemaVar \term java.lang.Object o1, o2;
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap;

        \assumes(anon(heapBefore, empty, anonHeap) = h1  ==> )
        \find( equals(h1, o1, h2, o2) )
        \sameUpdateLevel
        \replacewith( equals(heapBefore, o1, h2, o2) )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_2 {
        \schemaVar \term java.lang.Object o1, o2;
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap;

        \find(
            equals(
                anon(heapBefore, empty, anonHeap),
                o1,
                h2,
                o2
            )
        )
        \sameUpdateLevel
        \replacewith( equals(heapBefore, o1, h2, o2) )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_3 {
        \schemaVar \term java.lang.Object o1, o2;
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap;

        \assumes(anon(heapBefore, empty, anonHeap) = h2  ==> )
        \find( equals(h1, o1, h2, o2) )
        \sameUpdateLevel
        \replacewith( equals(h1, o1, heapBefore, o2) )
        \heuristics( simplify )
    };


    Eq_axiom_object {
        \schemaVar \term Heap h1, h2;
        \schemaVar \term java.lang.Object o1, o2;
        \schemaVar \variables Field f;

        \find( equals(h1, o1, h2, o2) )
        \sameUpdateLevel
        \varcond (
            \notFreeIn( f, h1),
            \notFreeIn( f, o1),
            \notFreeIn( f, h2),
            \notFreeIn( f, o2)
        )
        \replacewith (
            (   (   o1 = null
                  & o2 = null
                )
              | (   o1 != null
                  & o2 != null
                  & \forall f;
                    (   (   (   elementOf(
                                    o1,
                                    f,
                                    java.lang.Object::$equivalenceLocs(h1, o1)
                                )
                              | elementOf(
                                    o2,
                                    f,
                                    java.lang.Object::$equivalenceLocs(h2, o2)
                                )
                            )
                         -> any::select(h1, o1, f) = any::select(h2, o2, f)
                        )
                      & (   (   elementOf(
                                    o1,
                                    f,
                                    java.lang.Object::$equivalenceRecursionLocs(
                                        h1,
                                        o1
                                    )
                                )
                              | elementOf(
                                    o2,
                                    f,
                                    java.lang.Object::$equivalenceRecursionLocs(
                                        h2,
                                        o2
                                    )
                                )
                            )
                          & java.lang.Object::instance(o1) = TRUE
                          & java.lang.Object::instance(o2) = TRUE
                         -> equals(
                                h1,
                                java.lang.Object::select(h1, o1, f),
                                h2,
                                java.lang.Object::select(h2, o2, f)
                            )
                        )
                    )
                )
            )
         )
//        \heuristics( simplify )
     };


    Eq_axiom_ineffective_heap_change_4 {
        \schemaVar \term java.lang.Object o1, o2;
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap;

        \find(
            equals(
                h1,
                o1,
                anon(heapBefore, empty, anonHeap),
                o2
            )
        )
        \sameUpdateLevel
        \replacewith( equals(h1, o1, heapBefore, o2) )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_5 {
        \schemaVar \term java.lang.Object o;
        \schemaVar \term Heap heapBefore, anonHeap, heapAfter;

        \assumes(anon(heapBefore, empty, anonHeap) = heapAfter  ==> )
        \find( java.lang.Object::$equivalenceLocs(heapAfter, o) )
        \sameUpdateLevel
        \replacewith( java.lang.Object::$equivalenceLocs(heapBefore, o) )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_6 {
        \schemaVar \term java.lang.Object o;
        \schemaVar \term Heap heapBefore, anonHeap;

        \find(
            java.lang.Object::$equivalenceLocs(
                anon(heapBefore, empty, anonHeap),
                o
            )
        )
        \sameUpdateLevel
        \replacewith( java.lang.Object::$equivalenceLocs(heapBefore, o) )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_7 {
        \schemaVar \term java.lang.Object o;
        \schemaVar \term Heap heapBefore, anonHeap, heapAfter;

        \assumes(anon(heapBefore, empty, anonHeap) = heapAfter  ==> )
        \find( java.lang.Object::$equivalenceRecursionLocs(heapAfter, o) )
        \sameUpdateLevel
        \replacewith( java.lang.Object::$equivalenceRecursionLocs(heapBefore, o) )
        \heuristics( simplify )
    };


    Eq_axiom_ineffective_heap_change_8 {
        \schemaVar \term java.lang.Object o;
        \schemaVar \term Heap heapBefore, anonHeap;

        \find(
            java.lang.Object::$equivalenceRecursionLocs(
                anon(heapBefore, empty, anonHeap),
                o
            )
        )
        \sameUpdateLevel
        \replacewith( java.lang.Object::$equivalenceRecursionLocs(heapBefore, o) )
        \heuristics( simplify )
     };


//     Eq_At_Locs_axiom_ineffective_heap_change_1 {
//        \schemaVar \term Heap heapBefore, anonHeap, heapAfter;
//
//         \assumes(anon(heapBefore, empty, anonHeap) = heapAfter  ==> )
//         \find( bank.BankFacade::$publicUser(heapAfter) )
//         \sameUpdateLevel
//         \replacewith( bank.BankFacade::$publicUser(heapBefore) )
//         \heuristics( simplify )
//     };
// 
// 
//     Eq_At_Locs_axiom_ineffective_heap_change_2 {
//         \schemaVar \term Heap heapBefore, anonHeap;
// 
//         \find(
//             bank.BankFacade::$publicUser(
//                 anon(heapBefore, empty, anonHeap)
//             )
//         )
//         \sameUpdateLevel
//         \replacewith( bank.BankFacade::$publicUser(heapBefore) )
//         \heuristics( simplify )
//     };


    Eq_At_Locs_axiom_ineffective_heap_change_3 {
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap, heapAfter;
        \schemaVar \term LocSet eqLocs, recLocs;

        \assumes(anon(heapBefore, empty, anonHeap) = heapAfter  ==> )
        \find( equalsAtLocs(heapAfter, h2, eqLocs, recLocs) )
        \sameUpdateLevel
        \replacewith( equalsAtLocs(heapBefore, h2, eqLocs, recLocs) )
        \heuristics( simplify )
    };


    Eq_At_Locs_axiom_ineffective_heap_change_4 {
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap, heapAfter;
        \schemaVar \term LocSet eqLocs, recLocs;

        \find(
            equalsAtLocs(
                anon(heapBefore, empty, anonHeap),
                h2,
                eqLocs,
                recLocs
            )
        )
        \sameUpdateLevel
        \replacewith( equalsAtLocs(heapBefore, h2, eqLocs, recLocs) )
        \heuristics( simplify )
     };


     Eq_At_Locs_axiom_ineffective_heap_change_5 {
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap, heapAfter;
        \schemaVar \term LocSet eqLocs, recLocs;

        \assumes(anon(heapBefore, empty, anonHeap) = heapAfter  ==> )
        \find( equalsAtLocs(h1, heapAfter, eqLocs, recLocs) )
        \sameUpdateLevel
        \replacewith( equalsAtLocs(h1, heapBefore, eqLocs, recLocs) )
        \heuristics( simplify )
    };


    Eq_At_Locs_axiom_ineffective_heap_change_6 {
        \schemaVar \term Heap h1, h2, heapBefore, anonHeap, heapAfter;
        \schemaVar \term LocSet eqLocs, recLocs;

        \find(
            equalsAtLocs(
                h1,
                anon(heapBefore, empty, anonHeap),
                eqLocs,
                recLocs
            )
        )
        \sameUpdateLevel
        \replacewith( equalsAtLocs(h1, heapBefore, eqLocs, recLocs) )
        \heuristics( simplify )
     };


     Eq_At_Locs_axiom {
        \schemaVar \term Heap h1, h2;
        \schemaVar \term LocSet eqLocs, recLocs;
        \schemaVar \variables java.lang.Object o;
        \schemaVar \variables Field f;

        \find( equalsAtLocs(h1, h2, eqLocs, recLocs) )
        \sameUpdateLevel
        \varcond (
            \notFreeIn( f, h1),
            \notFreeIn( f, h2),
            \notFreeIn( f, eqLocs),
            \notFreeIn( f, recLocs),
            \notFreeIn( o, h1),
            \notFreeIn( o, h2),
            \notFreeIn( o, eqLocs),
            \notFreeIn( o, recLocs)
        )
        \replacewith (
            (   \forall o;
                \forall f;
                (   o != null
//                  & o.<created>                           // necessary??
                 -> (   elementOf(o, f, eqLocs)
                     -> any::select(h1, o, f) = any::select(h2, o, f)
                    )
                  & (   elementOf(o, f, recLocs)
                      & java.lang.Object::instance(o) = TRUE
                     -> equals(
                            h1,
                            java.lang.Object::select(h1, o, f),
                            h2,
                            java.lang.Object::select(h2, o, f)
                        )
                    )
                )
            )
         )
//        \heuristics( simplify )
     };

}
