\sorts { Generic; }

\functions {
    \unique Generic atom;
    \unique Generic branch(Generic,Generic);

    int height(Generic);
    Seq seqInc(Seq);
    Seq tree2seq(Generic);
    int leaves(Generic);
}

\schemaVariables {
    \term Generic x,y;
    \variables Generic g,g1,g2;
    \skolemTerm Generic gl,gr;
    \formula phi;
}

\rules {

  heightBranch {
    \schemaVar \term int hx,hy;
    \find(height(branch(x,y)))
    \replacewith(add(1, \if (hx > hy) \then (hx) \else (hy)))
    \add(hx = height(x) & hy = height(y) ==>)
    \heuristics(simplify)
  };

  heightAtom {
    \find(height(atom))
    \replacewith(0)
    \heuristics(concrete)
  };

  branch2seq {
    \find(tree2seq(branch(x,y)))
    \replacewith(seqInc(seqConcat(tree2seq(x),tree2seq(y))))
    \heuristics(simplify)
  };

  atom2seq {
    \find(tree2seq(atom))
    \replacewith(seqSingleton(0))
    \heuristics(concrete)
  };


  leavesAtom {
    \find(leaves(atom))
    \replacewith(1)
    \heuristics(concrete)
  };

  leavesBranch {
    \find(leaves(branch(x,y)))
    \replacewith(leaves(x)+leaves(y))
    \heuristics(simplify)
  };

  forallTreeLeftUnfold {
    \find(\forall g; phi ==>)
    \varcond(\notFreeIn(g1,phi),\notFreeIn(g2,phi))
    \add({\subst g; atom}phi &
         \forall g1,g2; {\subst g; branch(g1,g2)}phi ==>)
  };

  existsTreeRightUnfold {
    \find(==> \exists g; phi)
    \varcond(\notFreeIn(g1,phi),\notFreeIn(g2,phi))
    \add(==> {\subst g; atom}phi |
             \exists g1,g2; {\subst g; branch(g1,g2)}phi)
  };

  forallTreeRightInduction {
    \find(==> \forall g; phi)
    \varcond(
               \new(gl,\dependingOn(phi)),
               \new(gr,\dependingOn(phi))
             )
    "base case": \replacewith(==> {\subst g; atom} phi);
    "step case": 
      \replacewith(==> {\subst g; branch(gl,gr)} phi)
      \add({\subst g; gl}phi & {\subst g; gr}phi ==>)
    \heuristics(auto_induction)
  };

  existsTreeLeftInduction {
    \find(\exists g; phi ==>)
    \varcond(
               \new(gl,\dependingOn(phi)),
               \new(gr,\dependingOn(phi))
             )
    "base case": \replacewith(==> {\subst g; atom} !phi);
    "step case": 
      \replacewith(==> ({\subst g; gl}!phi & {\subst g; gr}!phi)
                  -> {\subst g; branch(gl,gr)} !phi)
    \heuristics(auto_induction)
  };

  getOfSeqInc {
    \schemaVar \term Seq z;
    \schemaVar \term int idx;
    \find(beta::seqGet(seqInc(z),idx))
    \replacewith(((int)beta::seqGet(z,idx))+1)
    \heuristics(simplify)
  };
  
  lenOfSeqInc {
    \schemaVar \term Seq z;
    \schemaVar \term int idx;
    \find(seqLen(seqInc(z)))
    \replacewith(seqLen(z))
    \heuristics(simplify)
  };
   
}
