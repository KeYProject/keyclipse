\sorts {
    Field;
    Heap;
}


\functions {
    //select/store
    alpha alpha::select(Heap, Object, Field);
    Heap store(Heap, Object, Field, any);
    Heap changeHeapAtLocs(Heap, Set, Heap);
    Heap changeHeapAtLocs2(Heap, Set, any);    
    
    //location sets    
    Set allLocs;
    Set allFields(Object);
    Set freshLocs(Heap);
    
    //fields
    \unique Field arr(int);
    \unique Field length;
    \unique Field java.lang.Object::<created>;
    \unique Field java.lang.Object::<initialized>;        
    \unique Field alpha::<classPrepared>;    			//static
    \unique Field alpha::<classInitialized>;			//static
    \unique Field alpha::<classInitializationInProgress>;	//static
    \unique Field alpha::<classErroneous>;			//static
    
    //null
    Null null;
}


\predicates {
    wellFormed(Heap);
    acc(Heap, Set, Object, Object);
    reach(Heap, Set, Object, Object, int);
}


\programVariables {
    Heap heap;
}


   

\rules {

    //--------------------------------------------------------------------------
    //axioms
    //--------------------------------------------------------------------------
    
    selectOfStore {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
   
	\find(beta::select(store(h, o, f, x), o2, f2))
	
	\replacewith(\if(o = o2 & f = f2)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
                     
      	\heuristics(simplify)
    };
    
    
    selectOfChangeHeapAtLocs {
        \schemaVar \term Heap h, h2;
        \schemaVar \term Set s;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(changeHeapAtLocs(h, s, h2), o, f))
        
        \replacewith(\if(elementOf(pair(o, f), s) 
                         & !(f=java.lang.Object::<created> 
                             & boolean::select(h, o, java.lang.Object::<created>)=TRUE))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };
    
    
    selectOfChangeHeapAtLocs2 {
        \schemaVar \term Heap h;
        \schemaVar \term Set s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(changeHeapAtLocs2(h, s, x), o, f))
        
        \replacewith(\if(elementOf(pair(o, f), s))
                     \then(x)
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };
    
    
    elementOfAllLocs {
        \schemaVar \term Object o;
	\schemaVar \term Field f;        
        
        \find(elementOf(pair(o, f), allLocs))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllLocsInt {
        \schemaVar \term int x;        
        
        \find(elementOf(x, allLocs))
        
        \replacewith(false)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllLocsAny {
        \schemaVar \term any a;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;
        
        \find(elementOf(a, allLocs))
        \varcond(\notFreeIn(ov, a), \notFreeIn(fv, a))
        
        \replacewith(\exists ov; \exists fv; a = pair(ov, fv))
        
        \heuristics(simplify)
    };      
    
    
    elementOfAllFields {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;        
        
        \find(elementOf(pair(o, f), allFields(o2)))
        
        \replacewith(o = o2)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllFieldsAny {
        \schemaVar \term any a;
        \schemaVar \term Object o;
        \schemaVar \variables Field fv;
        
        \find(elementOf(a, allFields(o)))
        \varcond(\notFreeIn(fv, a), \notFreeIn(fv, o))
        
        \replacewith(\exists fv; a = pair(o, fv))
        
        \heuristics(simplify)
    };    
    
    
    elementOfFreshLocs {
        \schemaVar \term Object o;
	\schemaVar \term Field f;  
	\schemaVar \term Heap h;      
        
        \find(elementOf(pair(o, f), freshLocs(h)))
        
        \replacewith(!o=null & !boolean::select(h,o,java.lang.Object::<created>)=TRUE)
        
        \heuristics(concrete)
    };
    
    
    elementOfFreshLocsAny {
        \schemaVar \term any a;  
	\schemaVar \term Heap h;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;     
        
        \find(elementOf(a, freshLocs(h)))
        \varcond(\notFreeIn(ov, a), \notFreeIn(ov, h), \notFreeIn(fv, a), \notFreeIn(fv, h))
        
        \replacewith(\exists ov; \exists fv; (a = pair(ov, fv) & !ov=null & !boolean::select(h,ov,java.lang.Object::<created>)=TRUE))
        
        \heuristics(simplify)
    };

    
    selectToAnySelect { //partially hardcoded in DependencyContractPO
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
   
	\find(beta::select(h, o, f))
	\varcond(\strict\sub(beta, any))
	
	\add(beta::select(h, o, f) = any::select(h, o, f) ==>)	
    };    
    
    
    accDefinition {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o;
	\schemaVar \term deltaObject o2;
	\schemaVar \variables Field fv;
   
	\find(acc(h, s, o, o2))
	\varcond(\notFreeIn(fv, h), \notFreeIn(fv, s), \notFreeIn(fv, o), \notFreeIn(fv, o2))
	
	\replacewith(o != null & o2 != null & \exists fv; (elementOf(fv, s) & deltaObject::select(h, o, fv) = o2))
	
      	\heuristics(simplify)
    };
    
    
    reachDefinition {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2;
	\schemaVar \term int n;
	\schemaVar \variables Object ov;
   
	\find(reach(h, s, o, o2, n))
	\varcond(\notFreeIn(ov, h), \notFreeIn(ov, s), \notFreeIn(ov, o), \notFreeIn(ov, o2), \notFreeIn(ov, n))
		
	\replacewith(n >= 0
	             & o != null
	             & o2 != null
	             & (n = 0 & o = o2 
	                | \exists ov; (reach(h, s, o, ov, n-1) & acc(h, s, ov, o2))))
    };    
        

    

    
    //--------------------------------------------------------------------------
    //EQ versions of axioms (these are lemmata)
    //--------------------------------------------------------------------------
    
    selectOfStoreEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
	\schemaVar \term Heap EQ;
   
        \assumes(store(h, o, f, x) = EQ ==>)
	\find(beta::select(EQ, o2, f2))
        \sameUpdateLevel
	
	\replacewith(\if(o = o2 & f = f2)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
      	\heuristics(simplify)
    };
    
    
    selectOfChangeHeapAtLocsEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term Set s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ; 
	
	\assumes(changeHeapAtLocs(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel
        
        \replacewith(\if(elementOf(pair(o, f), s)
		         & !(f=java.lang.Object::<created> 
                             & boolean::select(h, o, java.lang.Object::<created>)=TRUE))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };    
    
    
    selectOfChangeHeapAtLocs2EQ {
        \schemaVar \term Heap h;
        \schemaVar \term Set s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ; 
	
	\assumes(changeHeapAtLocs2(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel
        
        \replacewith(\if(elementOf(pair(o, f), s))
                     \then(x)
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };        
       
       
    elementOfAllLocsEQ {
        \schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Set EQ;        
        
        \assumes(allLocs = EQ ==>)
        \find(elementOf(pair(o, f), EQ))
        \sameUpdateLevel
                
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllFieldsEQ {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;   
	\schemaVar \term Set EQ;     
        
        \assumes(allFields(o2) = EQ ==>)
        \find(elementOf(pair(o, f), EQ))
        \sameUpdateLevel
        
        \replacewith(o = o2)
        
        \heuristics(simplify)
    };
    
    
    elementOfFreshLocsEq {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term Heap h;
	\schemaVar \term Set EQ;     	
        
        \assumes(freshLocs(h) = EQ ==>)
        \find(elementOf(pair(o, f), EQ))        
        
        \replacewith(!o=null & !boolean::select(h,o,java.lang.Object::<created>)=TRUE)
        
        \heuristics(simplify)
    };      
        
    
    
    //--------------------------------------------------------------------------
    //lemmata for changeHeapAtLocs
    //--------------------------------------------------------------------------
       
    changeHeapAtEmpty {
        \schemaVar \term Heap h, h2;
        
        \find(changeHeapAtLocs(h, empty, h2))
        
        \replacewith(h)
        
        \heuristics(concrete)
    };
    
    /*
    changeHeapAtAllLocs {
        \schemaVar \term Heap h, h2;
        
        \find(changeHeapAtLocs(h, allLocs, h2))
        
        \replacewith(h2)
        
        \heuristics(concrete)
    };
    */
    
    changeHeapAtEmpty2 {
        \schemaVar \term Heap h;
        \schemaVar \term any x;
        
        \find(changeHeapAtLocs2(h, empty, x))
        
        \replacewith(h)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for some other common cases
    //--------------------------------------------------------------------------
    
    ifThenPairElse0Equality {
        \schemaVar \formula phi;
        \schemaVar \term Pair p, p2;
        
        \find(\if(phi)\then(p)\else(0) = p2)
        
        \replacewith(phi & p = p2)
        
        \heuristics(concrete)
    };
    
    
    ifThenPairElse0InAllLocs {
        \schemaVar \formula phi;
        \schemaVar \term Pair p, p2;
        
        \find(elementOf(\if(phi)\then(p)\else(0), allLocs))
        
        \replacewith(phi & elementOf(p, allLocs))
        
        \heuristics(concrete)
    };
    
    
    dropEffectlessStores {
        \schemaVar \term Heap h, result;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \term any x;	
	
	\find(store(h, o, f, x))
	\varcond(\dropEffectlessStores(h, o, f, x, result))
	
	\replacewith(result)
	
	\heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for reachability
    //--------------------------------------------------------------------------
    
    reachZero {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2;
   
	\find(reach(h, s, o, o2, 0))
		
	\replacewith(o != null & o = o2)
	
	\heuristics(simplify)
    };
    
    
    reachOne {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2;
   
	\find(reach(h, s, o, o2, 1))
		
	\replacewith(acc(h, s, o, o2))
	
	\heuristics(simplify)
    };   
    
    
    reachNull {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o;
	\schemaVar \term int n;
   
	\find(reach(h, s, o, null, n))
		
	\replacewith(false)
	
	\heuristics(simplify)
    };
    
    
    reachNull2 {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o2;
	\schemaVar \term int n;
   
	\find(reach(h, s, null, o2, n))
		
	\replacewith(false)
	
	\heuristics(simplify)
    };    
    
    
    reachAddOne {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2;
	\schemaVar \term int n;
	\schemaVar \variables Object ov;	
   
	\find(reach(h, s, o, o2, 1 + n))
	\varcond(\notFreeIn(ov, h), \notFreeIn(ov, s), \notFreeIn(ov, o), \notFreeIn(ov, o2), \notFreeIn(ov, n))
		
	\replacewith(n >= -1
	             & o != null
	             & o2 != null
	             & (n = -1 & o = o2 
	                | \exists ov; (reach(h, s, o, ov, n) & acc(h, s, ov, o2))))
	
	\heuristics(simplify)
    };
    
    
    reachUniquePathSameSteps {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2, o3;
	\schemaVar \term int n;
	\schemaVar \term Field f;
   
	\assumes(reach(h, singleton(f), o, o2, n) ==>)    
	\find(reach(h, singleton(f), o, o3, n) ==>)
	\varcond(\different(o2, o3))

	\add(o2 = o3 ==>)
	
	\heuristics(inReachableStateImplication)
    };    
    
    
    reachEndOfUniquePath {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2, o3;
	\schemaVar \term int n, n2;
	\schemaVar \term Field f;
   
	\assumes(reach(h, singleton(f), o, o2, n), 
	         alpha::select(h, o2, f) = null, 
	         alpha::select(h, o3, f) = null ==>)    
	\find(reach(h, singleton(f), o, o3, n2) ==>)
	\varcond(\different(n, n2))

	\add(o2 = o3 & n = n2 ==>)
	
	\heuristics(inReachableStateImplication)
    };     
    
    
    reachAddOne2 {
	\schemaVar \term Heap h;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2;
	\schemaVar \term int n;
	\schemaVar \variables Object ov;
   
	\find(reach(h, s, o, o2, n + 1))
	\varcond(\notFreeIn(ov, h), \notFreeIn(ov, s), \notFreeIn(ov, o), \notFreeIn(ov, o2), \notFreeIn(ov, n))
				
	\replacewith(n >= -1
	             & o != null
	             & o2 != null
	             & (n = -1 & o = o2 
	                | \exists ov; (reach(h, s, o, ov, n) & acc(h, s, ov, o2))))
	
	\heuristics(simplify)
    };
    
    
    reachDependenciesStore {
	\schemaVar \term Heap h;
	\schemaVar \term Field f;
	\schemaVar \term any x;
	\schemaVar \term Set s;
	\schemaVar \term Object o, o2, o3;
	\schemaVar \term int n;
	\schemaVar \variables int nv;
   
	\find(reach(store(h, o3, f, x), s, o, o2, n))
	\sameUpdateLevel	
	\varcond(\notFreeIn(nv, h), 
	         \notFreeIn(nv, o3),
	         \notFreeIn(nv, f),
	         \notFreeIn(nv, x),
	         \notFreeIn(nv, s),
	         \notFreeIn(nv, o),
	         \notFreeIn(nv, o2),
	         \notFreeIn(nv, n))
		
	"Dependencies changed":
	  \add(==> !(\exists nv; reach(h, s, o, o3, nv) & elementOf(f, s)));
	
	"Dependencies unchanged":
	  \add(\forall nv; (reach(store(h, o3, f, x), s, o, o2, nv) <-> reach(h, s, o, o2, nv)), 
	       !(\exists nv; reach(h, s, o, o3, nv) & elementOf(f, s)) ==>)
	       
	\heuristics(dependencies)
    };    
    
    
    reachDependenciesChangeHeapAtLocs {
	\schemaVar \term Heap h, h2;
	\schemaVar \term Set s, s2;
	\schemaVar \term Object o, o2;
	\schemaVar \term int n;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;
	\schemaVar \variables int nv;
   
	\find(reach(changeHeapAtLocs(h, s2, h2), s, o, o2, n))
	\sameUpdateLevel	
	\varcond(\notFreeIn(ov, h), 
	         \notFreeIn(ov, s2),
	         \notFreeIn(ov, h2),
	         \notFreeIn(ov, s),
	         \notFreeIn(ov, o),
	         \notFreeIn(ov, o2),
	         \notFreeIn(ov, n),
	         \notFreeIn(fv, h), 
	         \notFreeIn(fv, s2),
	         \notFreeIn(fv, h2),
	         \notFreeIn(fv, s),
	         \notFreeIn(fv, o),
	         \notFreeIn(fv, o2),
	         \notFreeIn(fv, n),
	         \notFreeIn(nv, h), 
	         \notFreeIn(nv, s2),
	         \notFreeIn(nv, h2),
	         \notFreeIn(nv, s),
	         \notFreeIn(nv, o),
	         \notFreeIn(nv, o2),
	         \notFreeIn(nv, n))
		
	"Dependencies changed":
	  \add(==> \forall ov; \forall fv; !(elementOf(pair(ov, fv), s2) & \exists nv; reach(h, s, o, ov, nv) & elementOf(fv, s)));
	
	"Dependencies unchanged":
	  \add(\forall nv; (reach(changeHeapAtLocs(h, s2, h2), s, o, o2, nv) <-> reach(h, s, o, o2, nv)), 
	       \forall ov; \forall fv; !(elementOf(pair(ov, fv), s2) & \exists nv; reach(h, s, o, ov, nv) & elementOf(fv, s)) ==>)
	       
	\heuristics(dependencies)
    };
}
