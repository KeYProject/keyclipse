\sorts {
    Field;
    Location;
    Heap;
}


\functions {
    alpha alpha::select(Heap, Object, Field);
    Heap store(Heap, Object, Field, any);
    Heap changeHeapAtLocs(Heap, Set, Heap);
    
    //these would be automatically created later, but we already need them here
    \unique Field arr(int);
    \unique Field Array::length;    
    \unique Field java.lang.Object::<created>;
    /*\unique*/ Field alpha::<nextToCreate>;
}


\predicates {
    wellFormed(Heap);
}


\programVariables {
    Heap heap;
}



   

\rules {

    //--------------------------------------------------------------------------
    //axiom about unique function symbols (TODO: generalise)
    //--------------------------------------------------------------------------
    
    fieldEquality {
	\schemaVar \term Field f, f2;
   
	\find(f = f2)
	\varcond(\isUnique(f), \isUnique(f2))
	         
	\replacewith(#sameField(f,f2))
	
	\heuristics(concrete)
    };
    
    

    //--------------------------------------------------------------------------
    //axioms for selectOfX
    //--------------------------------------------------------------------------

    selectOfStore {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
   
	\find(beta::select(store(h, o, f, x), o2, f2))
	
	\replacewith(\if(o = o2 & f = f2)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
      	\heuristics(simplify)
    };
    
    
    selectOfChangeHeapAtLocs {
        \schemaVar \term Heap h, h2;
        \schemaVar \term Set s;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(changeHeapAtLocs(h, s, h2), o, f))
        
        \replacewith(\if(elementOf(pair(o, f), s))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };   
    
    
    //--------------------------------------------------------------------------
    //lemmata for changeHeapAtLocs
    //--------------------------------------------------------------------------
       
    changeHeapAtEmpty {
        \schemaVar \term Heap h, h2;
        
        \find(changeHeapAtLocs(h, empty, h2))
        
        \replacewith(h)
        
        \heuristics(concrete)
    };
    
    changeHeapAtEverything {
        \schemaVar \term Heap h, h2;
        
        \find(changeHeapAtLocs(h, everything, h2))
        
        \replacewith(h2)
        
        \heuristics(concrete)
    };

   /*
    //--------------------------------------------------------------------------
    //rules for wellFormed(Heap)
    //--------------------------------------------------------------------------
   
    //if o != null, if o.<created>, if o.f != null and if the heap is well-formed,
    //then we know that o.f.<created> 
    only_created_object_are_referenced_non_null_NEW {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
    	          
	\assumes((boolean) select(h, o, java.lang.Object::<created>) = TRUE, wellFormed(h) 
	         ==> o = null, (deltaObject) select(h, o, f) = null) 
	\find(select(h, o, f))	 
	\sameUpdateLevel
	
	\add((boolean)select(h, (deltaObject) select(h, o, f), java.lang.Object::<created>) = TRUE ==>)
	\heuristics(inReachableStateImplication)         	 
    };
   
   
    createdAndNextToCreateAreConsistent {
	\schemaVar \term Heap h;
	\schemaVar \term int i;	
     
	\assumes(wellFormed(h) ==>)
	\find(deltaObject::<get>(i))
	\sameUpdateLevel
	          
	\add((boolean) select(h, deltaObject::<get>(i), java.lang.Object::<created>) = TRUE
                        <-> i < (int){heap:=h}#nextToCreate((deltaObject)null) ==>)
	\heuristics(inReachableStateImplication)     
    };
   
   
    arrayLengthNonNegative {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
   
	\assumes(wellFormed(h) ==> o = null)
	\find(select(h,o,Array::length)) 
	\sameUpdateLevel       
	\add((jint) select(h,o,Array::length) >= 0 ==>)
	\heuristics(inReachableStateImplication)
    };
   
   
    wellFormedReferenceStoreRight {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term G x;
    
	\find(==> wellFormed(store(h, o, f, x)))  
	\varcond(\isReference(\fieldTargetType(o, f)))
	
	"Original heap well-formed":
          \replacewith(==> wellFormed(h));
	"Store preserves well-formedness":
          \replacewith(==> (boolean) select(h, o, java.lang.Object::<created>) = FALSE,
                           x = null,
                           (boolean) select(h, x, java.lang.Object::<created>) = TRUE)
                       
	\heuristics(simplify)
    };
    
    
    wellFormedPrimitiveStoreRight {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term G x;
    
	\find(==> wellFormed(store(h, o, f, x)))  
	\varcond(\not\isReference(\fieldTargetType(o, f)))
	
	"Original heap well-formed":
          \replacewith(==> wellFormed(h));
	"Store preserves well-formedness":
          \replacewith(==> (boolean) select(h,o,java.lang.Object::<created>) = FALSE, 
                           f != java.lang.Object::<created>) 
	\heuristics(simplify)
    };
   
      
   
    //--------------------------------------------------------------------------
    //rules for typing (could be in normal KeY as well)
    //--------------------------------------------------------------------------
   
    sortsDisjointModuloNull {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
	\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(x = null & y = null)
	\heuristics(simplify)
   };
   
   
    sortsDisjoint1 {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
   	\varcond(\not\sub(Null, G), \disjointModuloNull(G, H))
   	
   	\replacewith(false)
   	\heuristics(simplify)
    };
   
   
    sortsDisjoint2 {
        \schemaVar \term G x;
        \schemaVar \term H y;

	\find(x = y)
	\varcond(\not\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(false)
	\heuristics(simplify)
    };

   
   //--------------------------------------------------------------------------
   //rules for array initialisation
   //--------------------------------------------------------------------------
  
  
    arrayInitialisation_NEW {
	\schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
   	\schemaVar \program Type #t;
   	\schemaVar \program Variable #v, #a;
   	\schemaVar \program SimpleExpression #se;   	
   	\schemaVar \program ArrayLength #length;
   	\schemaVar \program Literal #lit;
   	\schemaVar \formula post;
   	\schemaVar \skolemTerm Heap arrayInitHeap;   	
       	\schemaVar \skolemTerm Heap beforeArrayInitHeap;   
	\schemaVar \skolemTerm G array;   	
       		
    
  	\find (\modality{#normalassign}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\varcond( \hasSort(#t, G),
		  \hasSort(array, G),
	          \same(\typeof(array), \typeof(#a)))
  	
	\replacewith(array = #a & heap = beforeArrayInitHeap 
	             -> {heap := changeHeapAtLocs(heap, setMinus(allFields(#a), singleton(#a, Array::length)), arrayInitHeap)}
	                \modality{#normalassign}{..  ...}\endmodality(post))
	\add(wellFormed(changeHeapAtLocs(beforeArrayInitHeap, setMinus(allFields(array), singleton(array, Array::length)), arrayInitHeap)) ==>)
	
	\addrules ( selectFromArrayInitHeap {
			\schemaVar \term Object o;
			\schemaVar \term Field f;
	   		\schemaVar \term int i;
	   		 
			\find(select(arrayInitHeap, o, arr(i)))
			\replacewith(#lit)
			\heuristics(simplify)
	            },
	            
	            selectFromArrayInitHeap2 {
	            	\schemaVar \term Heap h;
			\schemaVar \term Object o;
			\schemaVar \term Field f;
	   		\schemaVar \term int i;
	   		
	   		\assumes(h = arrayInitHeap ==>)
			\find(select(h, o, arr(i)))
			\sameUpdateLevel			
			
			\replacewith(#lit)
	                             
			\heuristics(simplify)
	            },
	            
	            selectFromArrayInitHeap3 {
	            	\schemaVar \term Heap h;
			\schemaVar \term Object o;
			\schemaVar \term Field f;
	   		\schemaVar \term int i;
	   		
	   		\assumes(arrayInitHeap = h ==>)
			\find(select(h, o, arr(i)))
			\sameUpdateLevel			
			
			\replacewith(#lit)
	                             
			\heuristics(simplify)
	            }
	          )
	            
	\heuristics(simplify)
    };
*/    
}
