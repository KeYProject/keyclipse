\sorts {
    Field;
    Heap;
}


\functions {
    //select/store
    alpha alpha::select(Heap, Object, Field);
    Heap store(Heap, Object, Field, any);
    Heap anon(Heap, LocSet, Heap);
    Heap memset(Heap, LocSet, any);
    
    //fields
    \unique Field arr(int);
    \unique Field length;
    \unique Field java.lang.Object::<created>;
    \unique Field java.lang.Object::<initialized>;        
    \unique Field alpha::<classPrepared>;    			//static
    \unique Field alpha::<classInitialized>;			//static
    \unique Field alpha::<classInitializationInProgress>;	//static
    \unique Field alpha::<classErroneous>;			//static
    
    //null
    Null null;
}


\predicates {
    wellFormed(Heap);
}


\programVariables {
    Heap heap;
}


   

\rules {

    //--------------------------------------------------------------------------
    //axioms for select/store
    //--------------------------------------------------------------------------
    
    selectOfStore {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
   
	\find(beta::select(store(h, o, f, x), o2, f2))
	
	\replacewith(\if(o = o2 & f = f2)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
                     
      	\heuristics(simplify)
    };
    
    
    selectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(anon(h, s, h2), o, f))
        
        \replacewith(beta::select(\if(elementOf(o, f, s) & f != java.lang.Object::<created> 
                                      | elementOf(o, f, freshLocs(h)))
                                  \then(h2)
                                  \else(h),
                                  o,
                                  f))
                                  
        \heuristics(simplify)
    };
    
    
    selectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(memset(h, s, x), o, f))
        
        \replacewith(\if(elementOf(o, f, s))
                     \then(x)
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };
    
    
    
    //--------------------------------------------------------------------------
    //EQ versions of axioms for select/store (these are lemmata)
    //--------------------------------------------------------------------------
    
    selectOfStoreEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
	\schemaVar \term Heap EQ;
   
        \assumes(store(h, o, f, x) = EQ ==>)
	\find(beta::select(EQ, o2, f2))
        \sameUpdateLevel
	
	\replacewith(\if(o = o2 & f = f2)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
      	\heuristics(simplify)
    };

    
    selectOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ; 
	
	\assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel
        
        \replacewith(beta::select(\if(elementOf(o, f, s) & f != java.lang.Object::<created> 
                                      | elementOf(o, f, freshLocs(h)))
                                  \then(h2)
                                  \else(h),
                                  o,
                                  f))
                     
        \heuristics(simplify)
    };    
    
    
    selectOfMemsetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ; 
	
	\assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel
        
        \replacewith(\if(elementOf(o, f, s))
                     \then(x)
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify)
    };
        
    
       
    //--------------------------------------------------------------------------
    //lemmata for some common cases
    //--------------------------------------------------------------------------
    
    elementOfGuardedSet {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \formula phi;
        \schemaVar \term LocSet s;
        
        \find(elementOf(o, f, \if(phi)\then(s)\else(empty)))
        
        \replacewith(phi & elementOf(o, f, s))
        
        \heuristics(concrete)
    };
        
    
    dropEffectlessStores {
        \schemaVar \term Heap h, result;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \term any x;	
	
	\find(store(h, o, f, x))
	\varcond(\dropEffectlessStores(h, o, f, x, result))
	
	\replacewith(result)
	
	\heuristics(concrete)
    };
        
    
    memsetEmpty {
        \schemaVar \term Heap h;
        \schemaVar \term any x;
        
        \find(memset(h, empty, x))
        
        \replacewith(h)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //axioms for using wellFormed
    //--------------------------------------------------------------------------

    onlyCreatedObjectsAreReferenced {
        \schemaVar \term Heap h;  
        \schemaVar \term Object o; 
        \schemaVar \term Field f;
   	          
        \assumes(wellFormed(h) ==>)	 
        \find(deltaObject::select(h, o, f)) \sameUpdateLevel	 
         
        \add(deltaObject::select(h, o, f) = null 
             | boolean::select(h, 
                               deltaObject::select(h, o, f), 
                               java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)	 
    };
   

    arrayLengthNotNegative {//TODO: does not match with rules for proving wellFormed
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        
   	\assumes(wellFormed(h) ==>)
        \find(int::select(h, o, length)) \sameUpdateLevel
        
        \add(int::select(h, o, length) >= 0 ==>)
        
	\heuristics(inReachableStateImplication)
    };
    
   
    /*
    enclosing_this_is_created {
        \assumes (obj.<created>@(java.lang.Object) = TRUE, inReachableState ==>)	 
        \find ( obj.#et ) \sameUpdateLevel
         
        \add ((obj.#et).<created>@(java.lang.Object) = TRUE  ==> obj.#et=null)
        
        \heuristics(inReachableStateImplication)
    };
    */
    
    
    
    
    //--------------------------------------------------------------------------
    //axioms for proving wellFormed
    //--------------------------------------------------------------------------
    
    wellFormedStoreObject {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term deltaObject x;
        
   	\find(==> wellFormed(store(h, o, f, x)))
   	\replacewith(==> wellFormed(h) 
   	                 & (x = null
   	                    | boolean::select(h, x, java.lang.Object::<created>) = TRUE))
   	             
   	\heuristics(simplify)
    };
    
    
    wellFormedStoreNonObject {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term beta x;
        
   	\find(==> wellFormed(store(h, o, f, x)))
   	\varcond(\not\sub(beta, java.lang.Object))
   	\replacewith(==> wellFormed(h))
   	             
   	\heuristics(simplify)
    };
    
    
    wellFormedAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	
        \find(==> wellFormed(anon(h, s, h2)))
        
        \replacewith(==> wellFormed(h) & wellFormed(h2))
	
        \heuristics(simplify)    
    };
    
    
    
    //--------------------------------------------------------------------------
    //EQ versions of taclets for proving wellFormed (these are lemmata)
    //--------------------------------------------------------------------------
    
    wellFormedStoreObjectEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term deltaObject x;
	\schemaVar \term Heap EQ;
        
        \assumes(store(h, o, f, x) = EQ ==>)        
   	\find(==> wellFormed(EQ))
   	\replacewith(==> wellFormed(h) 
   	                 & (x = null
   	                    | boolean::select(h, x, java.lang.Object::<created>) = TRUE))
   	             
   	\heuristics(simplify)
    };
    
    
    wellFormedStoreNonObjectEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term beta x;
	\schemaVar \term Heap EQ;
        
        \assumes(store(h, o, f, x) = EQ ==>)        
   	\find(==> wellFormed(EQ))
   	\varcond(\not\sub(beta, java.lang.Object))
   	\replacewith(==> wellFormed(h))
   	             
   	\heuristics(simplify)
    };
    
    
    wellFormedAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Heap EQ;        
	
	\assumes(anon(h, s, h2) = EQ ==>)	
        \find(==> wellFormed(EQ))
        
        \replacewith(==> wellFormed(h) & wellFormed(h2))
	
        \heuristics(simplify)    
    };    
    
    
    
    //--------------------------------------------------------------------------
    //axioms for observer symbols (perhaps should be created by JML front end)
    //--------------------------------------------------------------------------    

    onlyCreatedObjectsAreObserved {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \find(elementOf(o, f, obs) ==>)
        \varcond(\isObserver(obs, h))
         
        \add(o = null
             | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };
   
   
    onlyCreatedObjectsAreObservedEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs, EQ;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \assumes(obs = EQ ==>)
        \find(elementOf(o, f, EQ) ==>)
        \varcond(\isObserver(obs, h))
        
        \add(o = null  
             | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };       
}
