\sorts {
    Field;
    Heap;
    \generic alphaObj \extends Object;
}


\functions {
    //select/store
    alpha alpha::select(Heap, Object, Field);
    Heap store(Heap, Object, Field, any);
    Heap create(Heap, Object);
    Heap anon(Heap, LocSet, Heap);
    Heap memset(Heap, LocSet, any);
    
    //fields
    \unique Field arr(int);
    \unique Field java.lang.Object::<transient>;
    \unique Field java.lang.Object::<transactionConditionallyUpdated>;
    \unique Field java.lang.Object::<created>;
    \unique Field java.lang.Object::<initialized>;        
    \unique Field alpha::<classPrepared>;    			//static
    \unique Field alpha::<classInitialized>;			//static
    \unique Field alpha::<classInitializationInProgress>;	//static
    \unique Field alpha::<classErroneous>;			//static
    
    //array length
    int length(Object);
    
    //null
    Null null;
}


\predicates {
    wellFormed(Heap);
    arrayStoreValid(any, any);
}


\programVariables {
    Heap heap, savedHeap;
}

   

\rules(programRules:Java,optimisedSelectRules:off){

    //--------------------------------------------------------------------------
    //axioms for select/store
    //--------------------------------------------------------------------------

    selectOfStore {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
   
	\find(beta::select(store(h, o, f, x), o2, f2))
	
	\replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
                     
      	\heuristics(simplify_enlarging)
    };


    selectOfCreate {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f;
   
	\find(beta::select(create(h, o), o2, f))
	
	\replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                     \then((beta)TRUE)
                     \else(beta::select(h, o2, f)))
                     
      	\heuristics(simplify_enlarging)
    };
    
    
    selectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(anon(h, s, h2), o, f))
        
        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created> 
                      | elementOf(o, f, freshLocs(h)))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
                                  
        \heuristics(simplify_enlarging)
    };

    
    selectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f; 
	
        \find(beta::select(memset(h, s, x), o, f))
        
        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify_enlarging)
    };


    // CS: This is an implicit axiom which follows from the rules
    // selectCreatedOfAnon and selectOfAnon. I made the axiom explicit in this
    // rule. The rule is proven correct within KeY using the rules
    // selectCreatedOfAnon and selectOfAnon on the cut-formula
    // \forall Heap h2;
    // ( boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>) =
    //   boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>)   ) .
    // See comment on selectCreatedOfAnon.
    nullCreated {
        \schemaVar \variables Heap h;

        \add((\forall h; boolean::select(h, null, java.lang.Object::<created>) = TRUE)  |
             (\forall h; boolean::select(h, null, java.lang.Object::<created>) = FALSE)   ==> )
    };


    //--------------------------------------------------------------------------
    //EQ versions of axioms for select/store (these are lemmata)
    //--------------------------------------------------------------------------
    
    // proven with KeY for beta = Object using selectOfStore (CS)
    selectOfStoreEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
	\schemaVar \term Heap EQ;
   
        \assumes(store(h, o, f, x) = EQ ==>)
	\find(beta::select(EQ, o2, f2))
        \sameUpdateLevel
	
	\replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
                     
      	\heuristics(simplify_enlarging)
    };


    // proven with KeY for beta = Object using selectOfCreate (CS)
    selectOfCreateEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ;
   
        \assumes(create(h, o) = EQ ==>)
	\find(beta::select(EQ, o2, f))
        \sameUpdateLevel
	
	\replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                     \then((beta)TRUE)
                     \else(beta::select(h, o2, f)))
                     
      	\heuristics(simplify_enlarging)
    };


    // proven with KeY for beta = Object using selectOfAnon (CS)
    selectOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ; 
	
	\assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel
        
        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created> 
                      | elementOf(o, f, freshLocs(h)))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify_enlarging)
    };


    // proven with KeY for beta = Object using selectOfMemset (CS)
    selectOfMemsetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ; 
	
	\assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel
        
        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o, f)))
                     
        \heuristics(simplify_enlarging)
    };
}

\rules(programRules:Java,optimisedSelectRules:on){

    //--------------------------------------------------------------------------
    //axioms for select/store (here for manual use only)
    //--------------------------------------------------------------------------

    selectOfStore {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;

	\find(beta::select(store(h, o, f, x), o2, f2))

	\replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
    };


    selectOfCreate {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f;

	\find(beta::select(create(h, o), o2, f))

	\replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                     \then((beta)TRUE)
                     \else(beta::select(h, o2, f)))
    };


    selectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;

        \find(beta::select(anon(h, s, h2), o, f))

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>
                      | elementOf(o, f, freshLocs(h)))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
    };


    selectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;

        \find(beta::select(memset(h, s, x), o, f))

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o, f)))
    };


    // CS: This is an implicit axiom which follows from the rules
    // selectCreatedOfAnon and selectOfAnon. I made the axiom explicit in this
    // rule. The rule is proven correct within KeY using the rules
    // selectCreatedOfAnon and selectOfAnon on the cut-formula
    // \forall Heap h2;
    // ( boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>) =
    //   boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>)   ) .
    // See comment on selectCreatedOfAnon.
    nullCreated {
        \schemaVar \variables Heap h;

        \add((\forall h; boolean::select(h, null, java.lang.Object::<created>) = TRUE)  |
             (\forall h; boolean::select(h, null, java.lang.Object::<created>) = FALSE)   ==> )
    };


    //--------------------------------------------------------------------------
    //EQ versions of axioms for select/store (here for manual use only)
    //--------------------------------------------------------------------------

    // proven with KeY for beta = Object using selectOfStore (CS)
    selectOfStoreEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
	\schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
	\find(beta::select(EQ, o2, f2))
        \sameUpdateLevel

	\replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2)))
    };


    // proven with KeY for beta = Object using selectOfCreate (CS)
    selectOfCreateEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ;

        \assumes(create(h, o) = EQ ==>)
	\find(beta::select(EQ, o2, f))
        \sameUpdateLevel

	\replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                     \then((beta)TRUE)
                     \else(beta::select(h, o2, f)))
    };


    // proven with KeY for beta = Object using selectOfAnon (CS)
    selectOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ;

	\assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>
                      | elementOf(o, f, freshLocs(h)))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f)))
    };


    // proven with KeY for beta = Object using selectOfMemset (CS)
    selectOfMemsetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap EQ;

	\assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o, f)))
    };


    //--------------------------------------------------------------------------
    // prevent exponetial heap term size explosion by introduction of linear
    // many equations
    // author: scheben
    //--------------------------------------------------------------------------

    // this is a specialisation of the normal pull out rule which
    // matches only select-terms and introduces a skolem constant with a
    // particular name (which is used in the  strategy)
    pullOutSelect {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \skolemTerm beta selectSK;

        \find( beta::select(h, o, f) )
        \sameUpdateLevel

        \replacewith(selectSK)
        \add( beta::select(h, o, f) = selectSK ==>)
        \heuristics(pull_out_select)
    };


    simplifySelectOfStore {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
        \schemaVar \term beta sk;

	\find(beta::select(store(h, o, f, x), o2, f2) = sk ==>)

        \replacewith(
                \if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2))
               = sk ==>)

        \addrules ( replaceKnownSelect {
                        \find(beta::select(store(h, o, f, x), o2, f2))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

        \heuristics(simplify_select)
    };


    simplifySelectOfStoreEQ {
	\schemaVar \term Heap h, EQ;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f, f2;
	\schemaVar \term alpha x;
        \schemaVar \term beta sk;

        \assumes(store(h, o, f, x) = EQ ==>)
	\find(beta::select(EQ, o2, f2) = sk ==>)

        \replacewith(
                \if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                     \then((beta)x)
                     \else(beta::select(h, o2, f2))
               = sk ==>)

        \addrules ( replaceKnownSelect {
                        \assumes(store(h, o, f, x) = EQ ==>)
                        \find(beta::select(EQ, o2, f2))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

        \heuristics(simplify_select)
    };


    simplifySelectOfCreate {
	\schemaVar \term Heap h;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f;
        \schemaVar \term beta sk;

	\find(beta::select(create(h, o), o2, f) = sk ==>)

        \replacewith(
                \if(o = o2 & o != null & f = java.lang.Object::<created>)
                     \then((beta)TRUE)
                     \else(beta::select(h, o2, f))
              = sk ==>)

        \addrules ( replaceKnownSelect {
                        \find(beta::select(create(h, o), o2, f))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

      	\heuristics(simplify_select)
    };


    simplifySelectOfCreateEQ {
	\schemaVar \term Heap h, EQ;
	\schemaVar \term Object o, o2;
	\schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(create(h, o) = EQ ==>)
	\find(beta::select(EQ, o2, f) = sk ==>)

        \replacewith(
                \if(o = o2 & o != null & f = java.lang.Object::<created>)
                     \then((beta)TRUE)
                     \else(beta::select(h, o2, f))
              = sk ==>)

        \addrules ( replaceKnownSelect {
                        \assumes(create(h, o) = EQ ==>)
                        \find(beta::select(EQ, o2, f))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

      	\heuristics(simplify_select)
    };


    simplifySelectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(anon(h, s, h2), o, f) = sk ==>)

        \replacewith(
                \if(elementOf(o, f, s) & f != java.lang.Object::<created>
                      | elementOf(o, f, freshLocs(h)))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f))
              = sk ==>)

        \addrules ( replaceKnownSelect {
                        \find(beta::select(anon(h, s, h2), o, f))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

        \heuristics(simplify_select)
    };


    simplifySelectOfAnonEQ {
        \schemaVar \term Heap h, h2, EQ;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f) = sk ==>)

        \replacewith(
                \if(elementOf(o, f, s) & f != java.lang.Object::<created>
                      | elementOf(o, f, freshLocs(h)))
                     \then(beta::select(h2, o, f))
                     \else(beta::select(h, o, f))
              = sk ==>)

        \addrules ( replaceKnownSelect {
                        \assumes(anon(h, s, h2) = EQ ==>)
                        \find(beta::select(EQ, o, f))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

        \heuristics(simplify_select)
    };


    simplifySelectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(memset(h, s, x), o, f) = sk ==>)
        \replacewith(
                \if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                     \then(x)
                     \else(beta::select(h, o, f))
              = sk ==>)

        \addrules ( replaceKnownSelect {
                        \find(beta::select(memset(h, s, x), o, f))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

        \heuristics(simplify_select)
    };


    simplifySelectOfMemsetEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f) = sk ==>)
        \replacewith(
                \if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                     \then(x)
                     \else(beta::select(h, o, f))
              = sk ==>)

        \addrules ( replaceKnownSelect {
                        \assumes(memset(h, s, x) = EQ ==>)
                        \find(beta::select(EQ, o, f))
                        \inSequentState
                        \replacewith(sk)
                        \heuristics(concrete) } )

        \heuristics(simplify_select)
    };
}

 \rules(programRules:Java){
   
    //--------------------------------------------------------------------------
    //lemmata for some common cases
    //--------------------------------------------------------------------------
    
    dropEffectlessStores {
        \schemaVar \term Heap h, result;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \term any x;	
	
	\find(store(h, o, f, x))
	\varcond(\dropEffectlessStores(h, o, f, x, result))
	
	\replacewith(result)
	
	\heuristics(concrete)
    };
        
    
    memsetEmpty {
        \schemaVar \term Heap h;
        \schemaVar \term any x;
        
        \find(memset(h, empty, x))
        
        \replacewith(h)
        
        \heuristics(concrete)
    };
    

    // CS: This taclet is not a lemma. It does not follow from the axiom
    // selectOfAnon. The term
    // boolean::select(anon(h, s, h2), null, java.lang.Object::<created>)
    // equals beta::select(h, null, java.lang.Object::<created>) by the
    // definition selectOfAnon and freshLocs. This taclet replaces
    // boolean::select(anon(h, s, h2), null, java.lang.Object::<created>)
    // by beta::select(h, null, java.lang.Object::<created>) |
    //    beta::select(h2, null, java.lang.Object::<created>)   .
    // As a consequence we have forall heaps h, h2
    // beta::select(h, null, java.lang.Object::<created>) <->
    // ( beta::select(h, null, java.lang.Object::<created>) |
    //   beta::select(h2, null, java.lang.Object::<created>)  )
    // which is equivalent to
    // beta::select(h2, null, java.lang.Object::<created>) ->
    // beta::select(h, null, java.lang.Object::<created>)      forall h, h2.
    // Hence we only consider interpretations where (the underspecified)
    // location (null, java.lang.Object::<created>) equals TRUE on all heaps
    // or where it equals FALSE on all heaps. Since we "only" overspecify the
    // the underspecified here and since an adoption of the rule
    // selectCreatedOfAnon would complicate the rule, I chose to make the above
    // observation explicit in the lemma nullCreated instead of changing the
    // rule selectCreatedOfAnon.
    selectCreatedOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	
        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>))
        
        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                     \then(TRUE)
                     \else(boolean::select(h2, o, java.lang.Object::<created>)))

//        \heuristics(simplify_enlarging)
    };
    

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonAsFormula {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;

        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>) = TRUE)

        \replacewith(boolean::select(h, o, java.lang.Object::<created>) = TRUE |
                     boolean::select(h2, o, java.lang.Object::<created>) = TRUE)

        \heuristics(concrete)
    };


    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Heap EQ;
	
	\assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>))
        \sameUpdateLevel
        
        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                     \then(TRUE)
                     \else(boolean::select(h2, o, java.lang.Object::<created>)))

//        \heuristics(simplify_enlarging)
    };


    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonAsFormulaEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Object o;
	\schemaVar \term Heap EQ;

	\assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>) = TRUE)
        \sameUpdateLevel

        \replacewith(boolean::select(h, o, java.lang.Object::<created>) = TRUE |
                     boolean::select(h2, o, java.lang.Object::<created>) = TRUE)

        \heuristics(concrete)
    };
}

\rules(programRules:Java){

    //--------------------------------------------------------------------------
    //axioms for using wellFormed
    //--------------------------------------------------------------------------

    onlyCreatedObjectsAreReferenced {
        \schemaVar \term Heap h;  
        \schemaVar \term Object o; 
        \schemaVar \term Field f;
   	          
        \assumes(wellFormed(h) ==>)	 
        \find(deltaObject::select(h, o, f)) 
        \sameUpdateLevel	 
         
        \add(deltaObject::select(h, o, f) = null 
             | boolean::select(h, 
                               deltaObject::select(h, o, f), 
                               java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };
    
    
    onlyCreatedObjectsAreInLocSets {
        \schemaVar \term Heap h;  
        \schemaVar \term Object o, o2; 
        \schemaVar \term Field f, f2;
   	          
        \assumes(wellFormed(h) ==>)	 
        \find(elementOf(o2, f2, LocSet::select(h, o, f)) ==>)	 
         
        \add(o2 = null 
             | boolean::select(h, 
                               o2, 
                               java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };    
    
    
    onlyCreatedObjectsAreInLocSetsEQ {
        \schemaVar \term Heap h;  
        \schemaVar \term Object o, o2; 
        \schemaVar \term Field f, f2;
        \schemaVar \term LocSet EQ;
   	          
        \assumes(wellFormed(h), LocSet::select(h, o, f) = EQ ==>)	 
        \find(elementOf(o2, f2, EQ) ==>)
         
        \add(o2 = null 
             | boolean::select(h, 
                               o2, 
                               java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };        
   

    arrayLengthNotNegative {
        \schemaVar \term Object o;
        
        \find(length(o)) \sameUpdateLevel
        
        \add(length(o) >= 0 ==>)
        
	\heuristics(inReachableStateImplication)
    };
    
   
    /*
    enclosing_this_is_created {
        \assumes (obj.<created>@(java.lang.Object) = TRUE, inReachableState ==>)	 
        \find ( obj.#et ) 
        \sameUpdateLevel
         
        \add ((obj.#et).<created>@(java.lang.Object) = TRUE  ==> obj.#et=null)
        
        \heuristics(inReachableStateImplication)
    };
    */
    
    
    
    //--------------------------------------------------------------------------
    //axioms for proving wellFormed
    //--------------------------------------------------------------------------
    
    wellFormedStoreObject {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term deltaObject x;
        
   	\find(wellFormed(store(h, o, f, x)))
        \succedentPolarity

        \varcond(\fieldType(f, alpha))
   	
   	\replacewith(wellFormed(h) & x = null | (boolean::select(h, x, java.lang.Object::<created>) = TRUE & alpha::instance(x) = TRUE))
   	             
   	\heuristics(simplify_enlarging)
    };


    wellFormedStoreArray {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term int idx;
	\schemaVar \term deltaObject x;

        \find(wellFormed(store(h, o, arr(idx), x)))
        \succedentPolarity

        \varcond(\hasSort(\elemSort(o), alpha))
   	
        \replacewith(wellFormed(h) & x = null | (boolean::select(h, x, java.lang.Object::<created>) = TRUE & arrayStoreValid(o, x)))

        \heuristics(simplify_enlarging)
    };

    
    wellFormedStoreLocSet {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term LocSet x;
        
   	\find(wellFormed(store(h, o, f, x)))
        \succedentPolarity
   	
        \varcond(\fieldType(f, alpha), \sub(LocSet, alpha))

   	\replacewith(wellFormed(h) & createdInHeap(x, h))
   	             
   	\heuristics(simplify_enlarging)
    };    
    
    
    wellFormedStorePrimitive {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term beta x;
        
   	\find(wellFormed(store(h, o, f, x)))
        \succedentPolarity
   	\varcond(\fieldType(f, alpha), \not\sub(beta, java.lang.Object), 
                 \not\sub(beta, LocSet), \sub(beta, alpha))
   	
   	\replacewith(wellFormed(h))
   	             
   	\heuristics(concrete)
    };

    wellFormedStorePrimitiveArray {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term int idx;
	\schemaVar \term beta x;

        \find(wellFormed(store(h, o, arr(idx), x)))
        \succedentPolarity

        \varcond(\hasSort(\elemSort(o), alpha),\not\sub(beta, java.lang.Object), 
                 \not\sub(beta, LocSet), \sub(beta, alpha)) 

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedCreate {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
        
   	\find(wellFormed(create(h, o)))
        \succedentPolarity
   	
   	\replacewith(wellFormed(h))
   	             
   	\heuristics(concrete)
    };    
    
    
    wellFormedAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	
        \find(wellFormed(anon(h, s, h2)))
        \succedentPolarity
        
        \replacewith(wellFormed(h) & wellFormed(h2))
	
        \heuristics(concrete)    
    };

    wellFormedMemsetArrayObject {
        \schemaVar \term Heap h;
        \schemaVar \term Object ar;
        \schemaVar \term int lo, up;
        \schemaVar \term deltaObject x;
	
        \find(wellFormed(memset(h, arrayRange(ar, lo, up), x)))
        \succedentPolarity
        
        \varcond(\hasSort(\elemSort(ar), alpha))

   	\replacewith(wellFormed(h) & x = null | 
           (boolean::select(h, x, java.lang.Object::<created>) = TRUE & arrayStoreValid(ar, x)))
                     
        \heuristics(simplify_enlarging)
    }; 

    wellFormedMemsetArrayPrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term Object ar;
        \schemaVar \term int lo, up;
        \schemaVar \term beta x;
	
        \find(wellFormed(memset(h, arrayRange(ar, lo, up), x)))
        \succedentPolarity
        
        \varcond(\hasSort(\elemSort(ar), alpha), \not\sub(beta, java.lang.Object), 
                 \not\sub(beta, LocSet), \sub(beta, alpha)) 

   	\replacewith(wellFormed(h))
                     
        \heuristics(simplify_enlarging)
    }; 

   /* 

    In the general case , memset can no longer maintain wellformedness :(

    wellFormedMemsetObject {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term deltaObject x;
	
        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity
        
   	\replacewith(wellFormed(h) & x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE)
                     
        \heuristics(simplify_enlarging)
    };
    
    
    wellFormedMemsetLocSet {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s, x;
	
        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity
        
   	\replacewith(wellFormed(h) & createdInHeap(x, h))
                     
        \heuristics(simplify_enlarging)
    };      
    
    
    wellFormedMemsetPrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term beta x;
	
        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity
   	\varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))
        
   	\replacewith(wellFormed(h))
                     
        \heuristics(concrete)
    };
    */
    
    
    //--------------------------------------------------------------------------
    //EQ versions of taclets for proving wellFormed (these are lemmata)
    //--------------------------------------------------------------------------
    
    wellFormedStoreObjectEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term deltaObject x;
	\schemaVar \term Heap EQ;
        
        \assumes(store(h, o, f, x) = EQ ==>)        
   	\find(wellFormed(EQ))   	
        \sameUpdateLevel
        \succedentPolarity

   	\replacewith(wellFormed(h) & x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE)
   	             
   	\heuristics(simplify_enlarging)
    };
    
    
    wellFormedStoreLocSetEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term LocSet x;
	\schemaVar \term Heap EQ;	
        
        \assumes(store(h, o, f, x) = EQ ==>)         
   	\find(wellFormed(EQ))
   	\sameUpdateLevel
        \succedentPolarity

   	\replacewith(wellFormed(h) & createdInHeap(x, h))
   	             
   	\heuristics(simplify_enlarging)
    };        
    
    
    wellFormedStorePrimitiveEQ {
	\schemaVar \term Heap h;
	\schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term beta x;
	\schemaVar \term Heap EQ;
        
        \assumes(store(h, o, f, x) = EQ ==>)        
   	\find(wellFormed(EQ))
   	\sameUpdateLevel
        \succedentPolarity
        \varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))
   	
   	\replacewith(wellFormed(h))
   	             
   	\heuristics(concrete)
    };
    
    
    wellFormedAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
	\schemaVar \term Heap EQ;        
	
	\assumes(anon(h, s, h2) = EQ ==>)	
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & wellFormed(h2))
	
        \heuristics(concrete)    
    };    
    
    
    wellFormedMemsetObjectEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term deltaObject x;
	\schemaVar \term Heap EQ;
	
	\assumes(memset(h, s, x) = EQ ==>)		
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

   	\replacewith(wellFormed(h) & x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE)
                     
        \heuristics(simplify_enlarging)
    };  
    
    
    wellFormedMemsetLocSetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s, x;
	\schemaVar \term Heap EQ;
	
	\assumes(memset(h, s, x) = EQ ==>)		
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

   	\replacewith(wellFormed(h) & createdInHeap(x, h))
                     
        \heuristics(simplify_enlarging)
    };      
    
    
    wellFormedMemsetPrimitiveEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term beta x;
	\schemaVar \term Heap EQ;        
	
	\assumes(memset(h, s, x) = EQ ==>)		
        \find(wellFormed(EQ))
   	\sameUpdateLevel
        \succedentPolarity
        \varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))
        
   	\replacewith(wellFormed(h))
                     
        \heuristics(concrete)
    };    
    
    
    
    //--------------------------------------------------------------------------
    //axioms for observer symbols
    //--------------------------------------------------------------------------    

    onlyCreatedObjectsAreObserved {
        \schemaVar \term Heap h;
        \schemaVar \term deltaObject obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \find(obs) \sameUpdateLevel
        \varcond(\isObserver(obs, h))
         
        \add(obs = null
             | boolean::select(h, obs, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };
    
    
    onlyCreatedObjectsAreObservedInLocSets {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \find(elementOf(o, f, obs) ==>)
        \varcond(\isObserver(obs, h))
         
        \add(o = null
             | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };
    
    
    onlyCreatedObjectsAreObservedInLocSetsEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs, EQ;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \assumes(obs = EQ ==>)
        \find(elementOf(o, f, EQ) ==>)
        \varcond(\isObserver(obs, h))        
        
        \add(o = null  
             | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
             
        \heuristics(inReachableStateImplication)
    };

    //--------------------------------------------------------------------------
    //axioms based on definition of semantics for casts
    //--------------------------------------------------------------------------

    narrowSelectType {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

	\assumes( wellFormed(h) ==> )

        \find(beta::select(h,o,f))

        \varcond(\fieldType(f, alpha),
                 \strict\sub(alpha, beta))
        
        \replacewith(alpha::select(h,o,f))

	\heuristics(simplify)
    };

    narrowSelectArrayType {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;

	\assumes( wellFormed(h) ==> )

        \find(beta::select(h,o,arr(idx)))

        \varcond(\hasSort(\elemSort(o), alpha),
                 \strict\sub(alpha, beta))
        
        \replacewith(alpha::select(h,o,arr(idx)))

	\heuristics(simplify)
    };

    
    castTrueImpliesOriginalTrue {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
         
        \assumes(boolean::select(h, o, f) = TRUE ==>)
        \find(==> any::select(h, o, f) = TRUE)
        
        \replacewith(==> true)
             
        \heuristics(concrete)
    };
}

\rules(programRules:Java,JavaCard:on) {

    arrayLengthIsAShort {
        \schemaVar \term Object o;
        
        \find(length(o)) \sameUpdateLevel
        
        \add(inShort(length(o)) ==>)
        
	\heuristics(inReachableStateImplication)
    };
}

\rules(programRules:Java,JavaCard:off) {

    arrayLengthIsAnInt {
        \schemaVar \term Object o;
        
        \find(length(o)) \sameUpdateLevel
        
        \add(inInt(length(o)) ==>)
        
	\heuristics(inReachableStateImplication)
    };
}
