\sorts {
    LocSet;
}

\functions {
    LocSet empty;
    LocSet allLocs;    
    LocSet singleton(Object, Field);
    LocSet union(LocSet, LocSet);
    LocSet intersect(LocSet, LocSet);
    LocSet setMinus(LocSet, LocSet);
    LocSet infiniteUnion{true}(LocSet);    
    LocSet allFields(Object);
    LocSet allObjects(Field);
    LocSet arrayRange(Object, int, int);
    LocSet freshLocs(Heap);
}

\predicates {
    elementOf(Object, Field, LocSet);
    subset(LocSet, LocSet);
    disjoint(LocSet, LocSet);
    createdInHeap(LocSet, Heap);
}


\rules {
 
    //--------------------------------------------------------------------------
    //axioms for elementOf
    //--------------------------------------------------------------------------
   
    elementOfEmpty {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        
        \find(elementOf(o, f, empty))
        
        \replacewith(false)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllLocs {
        \schemaVar \term Object o;
	\schemaVar \term Field f;        
        
        \find(elementOf(o, f, allLocs))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };    
    

    elementOfSingleton {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        
        \find(elementOf(o, f, singleton(o2, f2)))
        
        \replacewith(o = o2 & f = f2)
        
        \heuristics(simplify)
    };
    
    
    elementOfUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        
        \find(elementOf(o, f, union(s, s2)))
        
        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))
        
        \heuristics(simplify_enlarging)
    };
    
    
    elementOfIntersect {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        
        \find(elementOf(o, f, intersect(s, s2)))
        
        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))
        
        \heuristics(simplify_enlarging)
    };
    
        
    elementOfSetMinus {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        
        \find(elementOf(o, f, setMinus(s, s2)))
        
        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))
        
        \heuristics(simplify_enlarging)
    };
       
    
    elementOfInfiniteUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \term LocSet s;
        
        \find(elementOf(o, f, infiniteUnion{av;}(s)))
        \varcond(\notFreeIn(av, o, f))
        
        \replacewith(\exists av; elementOf(o, f, s))
        
        \heuristics(simplify)
    };
    
            
    elementOfInfiniteUnion2Vars {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \variables beta bv;
	\schemaVar \term LocSet s;
        
        \find(elementOf(o, f, infiniteUnion{av, bv;}(s)))
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))
        
        \replacewith(\exists av; \exists bv; elementOf(o, f, s))
        
        \heuristics(simplify)
    };    
    

    elementOfAllFields {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;        
        
        \find(elementOf(o, f, allFields(o2)))
        
        \replacewith(o = o2)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllObjects {
        \schemaVar \term Object o;
	\schemaVar \term Field f, f2;        
        
        \find(elementOf(o, f, allObjects(f2)))
        
        \replacewith(f = f2)
        
        \heuristics(concrete)
    };
    
    
    elementOfArrayRange {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term int lower, upper;
	\schemaVar \variables int iv;
        
        \find(elementOf(o, f, arrayRange(o2, lower, upper)))
        \varcond(\notFreeIn(iv, f, lower, upper))        
        
        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))
        
        \heuristics(simplify)
    };
    
    
    elementOfFreshLocs {
        \schemaVar \term Object o;
	\schemaVar \term Field f;  
	\schemaVar \term Heap h;      
        
        \find(elementOf(o, f, freshLocs(h)))
        
        \replacewith(!o=null & !boolean::select(h,o,java.lang.Object::<created>)=TRUE)
        
        \heuristics(concrete)
    };
    
            
    

    //--------------------------------------------------------------------------
    //EQ versions of axioms (these are lemmata)
    //--------------------------------------------------------------------------
       
    elementOfEmptyEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;
        
        \assumes(empty = EQ ==>)        
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        
        \replacewith(false)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllLocsEQ {
        \schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term LocSet EQ;        
        
        \assumes(allLocs = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
                
        \replacewith(true)
        
        \heuristics(concrete)
    };
    

    elementOfSingletonEQ {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term LocSet EQ;
        
        \assumes(singleton(o2, f2) = EQ ==>)
        \find(elementOf(o, f, EQ))        
        \sameUpdateLevel
        
        \replacewith(o = o2 & f = f2)
        
        \heuristics(simplify)
    };
    
    
    elementOfUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;
        
        \assumes(union(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))               
        \sameUpdateLevel
        
        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))
        
        \heuristics(simplify_enlarging)
    };
    
    
    elementOfIntersectEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;
        
        \assumes(intersect(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        
        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))
        
        \heuristics(simplify_enlarging)
    };
    
        
    elementOfSetMinusEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;
        
        \assumes(setMinus(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))        
        \sameUpdateLevel
        
        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))
        
        \heuristics(simplify_enlarging)
    };
    
    
    elementOfInfiniteUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \term LocSet s;
        \schemaVar \term LocSet EQ;	
        
        \assumes(infiniteUnion{av;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel        
        \varcond(\notFreeIn(av, o, f))
                
        \replacewith(\exists av; elementOf(o, f, s))
        
        \heuristics(simplify)
    };    
    
    
    elementOfInfiniteUnion2VarsEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \variables beta bv;
	\schemaVar \term LocSet s;
	\schemaVar \term LocSet EQ;
        
        \assumes(infiniteUnion{av, bv;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel        
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))
        
        \replacewith(\exists av; \exists bv; elementOf(o, f, s))
        
        \heuristics(simplify)
    };        
    
    
    elementOfAllFieldsEQ {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;   
	\schemaVar \term LocSet EQ;     
        
        \assumes(allFields(o2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        
        \replacewith(o = o2)
        
        \heuristics(concrete)
    };
    
    
    elementOfAllObjectsEQ {
        \schemaVar \term Object o;
	\schemaVar \term Field f, f2;   
	\schemaVar \term LocSet EQ;     
        
        \assumes(allObjects(f2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        
        \replacewith(f = f2)
        
        \heuristics(concrete)
    };    
    
    
    elementOfArrayRangeEQ {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term int lower, upper;
	\schemaVar \variables int iv;
	\schemaVar \term LocSet EQ;     	
        
        \assumes(arrayRange(o2, lower, upper) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(iv, f, lower, upper))        
        
        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))
        
        \heuristics(simplify)
    };    
    
    
    elementOfFreshLocsEQ {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term Heap h;
	\schemaVar \term LocSet EQ;     	
        
        \assumes(freshLocs(h) = EQ ==>)
        \find(elementOf(o, f, EQ))      
        \sameUpdateLevel  
        
        \replacewith(!o=null & !boolean::select(h,o,java.lang.Object::<created>)=TRUE)
        
        \heuristics(concrete)
    };
        
        
    
    //--------------------------------------------------------------------------
    //axioms for set predicates (reduce to elementOf)
    //--------------------------------------------------------------------------
    
    equalityToElementOf {
    	\schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;    	
    	
    	\find(s = s2)
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))
	
    	\replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))
    };


    subsetToElementOf {
        \schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;    	
        
        \find(subset(s, s2))
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))
	
	\replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))
	
        \heuristics(simplify)
    };

    
    disjointToElementOf {
        \schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;
        
        \find(disjoint(s, s2))
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))
	
        \replacewith(\forall ov; \forall fv; (!elementOf(ov, fv, s) | !elementOf(ov, fv, s2)))
        
        \heuristics(simplify)
    };
    
    
    createdInHeapToElementOf {
    	\schemaVar \term LocSet s;
    	\schemaVar \term Heap h;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;
        
        \find(createdInHeap(s, h))
	\varcond(\notFreeIn(ov, s, h), \notFreeIn(fv, s, h))
	
        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) 
                                              -> ov = null 
                                                 | boolean::select(h, ov, java.lang.Object::<created>) = TRUE))
        \heuristics(classAxiom)
    };


    
    //--------------------------------------------------------------------------
    //lemmata for empty and allLocs
    //--------------------------------------------------------------------------
    
    unionWithEmpty1 {
        \schemaVar \term LocSet s;
        
        \find(union(s, empty))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };
    
    
    unionWithEmpty2 {
        \schemaVar \term LocSet s;
        
        \find(union(empty, s))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };
    
    
    unionWithAllLocs1 {
        \schemaVar \term LocSet s;
        
        \find(union(s, allLocs))
        
        \replacewith(allLocs)
        
        \heuristics(concrete)
    };
    
    
    unionWithAllLocs2 {
        \schemaVar \term LocSet s;
        
        \find(union(allLocs, s))
        
        \replacewith(allLocs)
        
        \heuristics(concrete)
    };    
    
    
    intersectWithEmpty1 {
        \schemaVar \term LocSet s;
        
        \find(intersect(s, empty))
        
        \replacewith(empty)
        
        \heuristics(concrete)
    };


    intersectWithEmpty2 {
        \schemaVar \term LocSet s;
        
        \find(intersect(empty, s))
        
        \replacewith(empty)
        
        \heuristics(concrete)
    };
    
    
    intersectWithAllLocs1 {
        \schemaVar \term LocSet s;
        
        \find(intersect(s, allLocs))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };


    intersectWithAllLocs2 {
        \schemaVar \term LocSet s;
        
        \find(intersect(allLocs, s))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };    


    setMinusWithEmpty1 {
        \schemaVar \term LocSet s;
        
        \find(setMinus(s, empty))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };


    setMinusWithEmpty2 {
        \schemaVar \term LocSet s;
        
        \find(setMinus(empty, s))
        
        \replacewith(empty)
        
        \heuristics(concrete)
    };
    
    
    setMinusWithAllLocs {
        \schemaVar \term LocSet s;
        
        \find(setMinus(s, allLocs))
        
        \replacewith(empty)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for subset
    //--------------------------------------------------------------------------
    
    subsetWithEmpty {
        \schemaVar \term LocSet s;
        
        \find(subset(empty, s))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    subsetWithAllLocs {
        \schemaVar \term LocSet s;
        
        \find(subset(s, allLocs))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for disjoint
    //--------------------------------------------------------------------------   
    
    disjointWithEmpty1 {
        \schemaVar \term LocSet s;
        
        \find(disjoint(empty, s))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    disjointWithEmpty2 {
        \schemaVar \term LocSet s;
        
        \find(disjoint(s, empty))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for createdInHeap
    //--------------------------------------------------------------------------       
        
    createdInHeapWithEmpty {
        \schemaVar \term Heap h;
        
        \find(createdInHeap(empty, h))
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
        
    
    createdInHeapWithSingleton {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        
        \find(createdInHeap(singleton(o, f), h))
        
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        
        \heuristics(simplify_enlarging)
    };
    
    
    createdInHeapWithUnion {
        \schemaVar \term LocSet s, s2;    
        \schemaVar \term Heap h;
        
        \find(==> createdInHeap(union(s, s2), h))
	
        \replacewith(==> createdInHeap(s, h));
        \replacewith(==> createdInHeap(s2, h))
        
        \heuristics(simplify_enlarging)
    };
    
    
    createdInHeapWithSetMinusFreshLocs {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        
        \find(createdInHeap(setMinus(s, freshLocs(h)), h))
	
        \replacewith(true)
        
        \heuristics(concrete)
    };
    

    createdInHeapWithAllFields {
    	\schemaVar \term Object o;
        \schemaVar \term Heap h;
        
        \find(createdInHeap(allFields(o), h))
	
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        
        \heuristics(simplify_enlarging)
    };    
    
    
    createdInHeapWithArrayRange {
    	\schemaVar \term Object o;
	\schemaVar \term int lower, upper;    
        \schemaVar \term Heap h;
        
        \find(createdInHeap(arrayRange(o, lower, upper), h))
	
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)
        
        \heuristics(simplify_enlarging)
    };
    
    
    createdInHeapWithSelect {
    	\schemaVar \term Object o;
	\schemaVar \term Field f;    
        \schemaVar \term Heap h, h2;
        
        \find(==> createdInHeap(LocSet::select(h2, o, f), h))
	
        \replacewith(==> wellFormed(h2))
        
        \heuristics(concrete)
    };
    
    
    createdInHeapWithObserver {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;
         
        \find(==> createdInHeap(obs, h))
        \varcond(\isObserver(obs, h))
         
        \replacewith(==> wellFormed(h))
             
        \heuristics(concrete)
    };
    
    
    //--------------------------------------------------------------------------
    //EQ versions of lemmata for createdInHeap
    //--------------------------------------------------------------------------       
    
    createdInHeapWithEmptyEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
        
        \assumes(empty = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel
        
        \replacewith(true)
        
        \heuristics(concrete)
    };
    
    
    createdInHeapWithSingletonEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
        
        \assumes(singleton(o, f) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel
        
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        
        \heuristics(simplify_enlarging)
    };
    
    
    createdInHeapWithUnionEQ {
        \schemaVar \term LocSet s, s2;    
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
        
        \assumes(union(s, s2) = EQ ==>)
        \find(==> createdInHeap(EQ, h))
	
        \replacewith(==> createdInHeap(s, h));
        \replacewith(==> createdInHeap(s2, h))
        
        \heuristics(simplify_enlarging)
    };
    
    
    createdInHeapWithSetMinusFreshLocsEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
        
        \assumes(setMinus(s, freshLocs(h)) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel
	
        \replacewith(true)
        
        \heuristics(concrete)
    };
    

    createdInHeapWithAllFieldsEQ {
    	\schemaVar \term Object o;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
        
        \assumes(allFields(o) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel
	
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        
        \heuristics(simplify_enlarging)
    };    
    
    
    createdInHeapWithArrayRangeEQ {
    	\schemaVar \term Object o;
	\schemaVar \term int lower, upper;    
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
        
        \assumes(arrayRange(o, lower, upper) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel
	
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)
        
        \heuristics(simplify_enlarging)
    };
    
    
    createdInHeapWithSelectEQ {
    	\schemaVar \term Object o;
	\schemaVar \term Field f;    
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet EQ;
        
        \assumes(LocSet::select(h2, o, f) = EQ ==>)
        \find(==> createdInHeap(EQ, h))
	
        \replacewith(==> wellFormed(h2))
        
        \heuristics(concrete)
    };
    
    
    createdInHeapWithObserverEQ {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;
         
        \assumes(obs = EQ ==>)
        \find(==> createdInHeap(EQ, h))
        \varcond(\isObserver(obs, h))
         
        \replacewith(==> wellFormed(h))
             
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //other lemmata for proving createdness
    //--------------------------------------------------------------------------       
    
    referencedObjectIsCreatedRight {
    	\schemaVar \term Heap h;	
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        
        \assumes(==> deltaObject::select(h, o, f) = null)        
        \find(==> boolean::select(h, 
                                  deltaObject::select(h, o, f), 
                                  java.lang.Object::<created>) = TRUE) 
        
        \replacewith(==> wellFormed(h))
        
	\heuristics(concrete)
    };
    
    
    referencedObjectIsCreatedRightEQ {
    	\schemaVar \term Heap h;	
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;
        
        \assumes(deltaObject::select(h, o, f) = EQ ==> EQ = null)
        \find(==> boolean::select(h, 
                                  EQ, 
                                  java.lang.Object::<created>) = TRUE) 
        
        \replacewith(==> wellFormed(h))
        
	\heuristics(concrete)
    };    
    
    
    
    
        
    //--------------------------------------------------------------------------
    //some other lemmata
    //--------------------------------------------------------------------------
    
    unionWithItself {
        \schemaVar \term LocSet s;
        
        \find(union(s, s))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };
    
    
    intersectWithItself {
        \schemaVar \term LocSet s;
        
        \find(intersect(s, s))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };    
    
    
    setMinusItself {
        \schemaVar \term LocSet s;
        
        \find(setMinus(s, s))
        
        \replacewith(empty)
        
        \heuristics(concrete)
    };
    
    
    infiniteUnionUnused {
	\schemaVar \variables alpha av;	
	\schemaVar \term LocSet s;
        
        \find(infiniteUnion{av;}(s))
        \varcond(\notFreeIn(av, s))
        
        \replacewith(s)
        
        \heuristics(concrete)
    };
    
    
    subsetOfItself {
        \schemaVar \term LocSet s;
        
        \find(subset(s, s))
        
        \replacewith(true)
        
        \heuristics(concrete)    
    };
    
    
    elementOfGuardedSet {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \formula phi;
        \schemaVar \term LocSet s;
        
        \find(elementOf(o, f, \if(phi)\then(s)\else(empty)))
        
        \replacewith(phi & elementOf(o, f, s))
        
        \heuristics(concrete)
    };
}
