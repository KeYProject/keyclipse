// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


/** Additional taclets for abstract data type map.
 * @author Kai Wallisch
 */

\sorts {
    Free;
}

\schemaVariables {
	\term Free m, m0, m1;
	\term any key, value, x;
	\term Seq s;
	\variables any vy;
}

\functions{
    //getters
    int mapSize(Free); 
    \unique int mapSizeUndefined; // mapSize for infinite maps
    
    //constructors
    Free mapUpdate(Free, any, any);
    Free mapRemove(Free, any);
}

\predicates {
    isFinite(Free);
}

\rules {

    //--------------------------------------------------------------------------
    //definitions (conservative extensions)
    //--------------------------------------------------------------------------
    
    // Added by Kai Wallisch
	defMapUpdate{
		\schemaVar \skolemTerm Free mapUpdateResult;
		\find(mapUpdate(m,key,value))
		\varcond(\notFreeIn(vy,m,key,value))
		\replacewith(mapForeach{vy;}(
			\if(inDomain(m,vy) | vy = key)
				\then(TRUE)
				\else(FALSE),
			\if(vy = key)
				\then(value)
				\else(mapGet(m,vy)) 
		))
	};
	
    // Added by Kai Wallisch
	defMapRemove{
		\find(mapRemove(m,key))
		\varcond(\notFreeIn(vy,m,key))
		\replacewith(mapForeach{vy;}(
			\if(inDomain(m,vy) & vy != key)
				\then(TRUE)
				\else(FALSE),
			\if(vy = key)
				\then(mapUndef)
				\else(mapGet(m,vy))
		))
	};
	
    //--------------------------------------------------------------------------
    //inDomain taclets
    //--------------------------------------------------------------------------
    
        
    // Added by Kai Wallisch
    inDomainOfMapUpdate {
        \find(inDomain(mapUpdate(m,key,value),x))
        \replacewith(inDomain(m,x)|(x=key))
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    inDomainOfMapRemove {
        \find(inDomain(mapRemove(m,key),x))
        \replacewith(inDomain(m,x)&!(x=key))
        \heuristics(simplify)
    };
    
	// Added by Kai Wallisch (can be left out maybe)
	notInDomain{
		\find(==> inDomain(m,x))
		\add(mapGet(m,x) = mapUndef ==>)
        \heuristics(inReachableStateImplication)
	};
    
    //--------------------------------------------------------------------------
    //mapGet taclets
    //--------------------------------------------------------------------------
    
    // Added by Kai Wallisch
    getOfMapEmpty {
        \find(mapGet(mapEmpty,x))
        \sameUpdateLevel
        \replacewith(mapUndef)
        \heuristics(simplify)
    };
        
    // Added by Kai Wallisch
    getOfMapUpdate {
        \find(mapGet(mapUpdate(m,key,value),x))
        \sameUpdateLevel
        \replacewith(\if(x=key)\then(value)\else(mapGet(m,x)))
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    getOfMapRemove {
        \find(mapGet(mapRemove(m,key),x))
        \sameUpdateLevel
        \replacewith(\if(x=key)\then(mapUndef)\else(mapGet(m,x)))
        \heuristics(simplify)
    };
    
	//--------------------------------------------------------------------------
    //isFinite taclets
    //--------------------------------------------------------------------------
    
    // Added by Kai Wallisch
    isFiniteOfMapEmpty {
        \find(isFinite(mapEmpty))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

	// Added by Kai Wallisch
    isFiniteOfMapSingleton {
        \find(isFinite(mapSingleton(key,value)))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    isFiniteOfSeq2Map {
        \find(isFinite(seq2map(s)))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    isFiniteOfMapUpdate {
        \find(isFinite(mapUpdate(m,key,value)))
        \sameUpdateLevel
        \replacewith(isFinite(m))
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    isFiniteOfMapRemove {
        \find(isFinite(mapRemove(m,key)))
        \sameUpdateLevel
        \replacewith(isFinite(m))
        \heuristics(simplify)
    };
    
    //--------------------------------------------------------------------------
    //mapSize taclets
    //--------------------------------------------------------------------------
    
    // Added by Kai Wallisch
    sizeOfMapEmpty {
        \find(mapSize(mapEmpty))
        \sameUpdateLevel
        \replacewith(0)
        \heuristics(simplify)
    };

	// Added by Kai Wallisch
    sizeOfMapSingleton {
        \find(mapSize(mapSingleton(key,value)))
        \sameUpdateLevel
        \replacewith(1)
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    sizeOfSeq2Map {
        \find(mapSize(seq2map(s)))
        \sameUpdateLevel
        \replacewith(seqLen(s))
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    sizeOfMapUpdate {
        \find(mapSize(mapUpdate(m,key,value)))
        \sameUpdateLevel
        \replacewith(\if(isFinite(m))
        	\then(\if(inDomain(m,key))\then(mapSize(m))\else(mapSize(m) + 1))
        	\else(mapSizeUndefined)
        )
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    sizeOfMapRemove {
        \find(mapSize(mapRemove(m,key)))
        \sameUpdateLevel
        \replacewith(\if(isFinite(m))
        	\then(\if(inDomain(m,key))\then(mapSize(m) - 1)\else(mapSize(m)))
        	\else(mapSizeUndefined)
        )
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
	sizeZeroImpliesMapEmpty{
		\find(mapSize(m) = 0 ==> )
		\replacewith(m = mapEmpty ==> )
        \heuristics(simplify_enlarging)
	};
	
	// Added by Kai Wallisch
	mapSizeNotNegativeForFiniteMaps{
		\find(mapSize(m))
		\add(isFinite(m)->(mapSize(m)>=0) ==> )
        \heuristics(inReachableStateImplication)
	};

	inDomainImpliesCreated {
		\schemaVar \term Object o;
		\find(inDomain(m, o) ==> )
		\add(boolean::select(heap, o, java.lang.Object::<created>) = TRUE ==>)
		\heuristics(inReachableStateImplication)
	};
	
    //--------------------------------------------------------------------------
    //map equality taclets
    //--------------------------------------------------------------------------
    
    defMapEquality {
		\find(m0=m1)
		\varcond(\notFreeIn(vy,m0,m1))
		\replacewith( \forall vy; ( inDomain(m0, vy)<->inDomain(m1, vy) & 
				(inDomain(m0, vy) -> mapGet(m0, vy)=mapGet(m1, vy)) ) )
	};
   
   mapEqualityLeft {
		\find(m0=m1 ==> )
		\varcond(\notFreeIn(vy,m0,m1))
		\add(\forall vy; ( inDomain(m0, vy)<->inDomain(m1, vy) & 
				(inDomain(m0, vy) -> mapGet(m0, vy)=mapGet(m1, vy)) ) ==>)
		\heuristics(inReachableStateImplication)
	};
	
	mapEqualityRight {
		\find( ==> m0=m1)
		\varcond(\notFreeIn(vy,m0,m1))
		\add( ==> \forall vy; ( inDomain(m0, vy)<->inDomain(m1, vy) & 
				(inDomain(m0, vy) -> mapGet(m0, vy)=mapGet(m1, vy)) ) )
		\heuristics(inReachableStateImplication)
	};
   
   mapUpdateUnchanged {
   	\find(mapUpdate(m, key, value)=m ==> )
   	\replacewith(inDomain(m, key) ==> )
   	\add(mapGet(m, key)=value ==> )
	\heuristics(simplify)
   };
   
   mapRemoveUnchanged {
   	\find(mapRemove(m, key)=m ==> )
   	\replacewith( ==> inDomain(m, key))
   	\add(mapGet(m, key)=mapUndef ==> )
	\heuristics(simplify)
   };
   
}
