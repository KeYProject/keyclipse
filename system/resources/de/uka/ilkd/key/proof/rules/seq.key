// This file contains the new rule set for the sequence data type
// In case a new taclet is a modification of an old taclet
// the old taclet is contained as a comment.
//
// A version this file but without comments on the
// old taclets is file seqStandard-new-WOC.key
//
// 
// This file is the union of previous files
//  seqCore0.key
//  seqCore.key
//  seqCorePI.key
//  seqCorePIX.key
//  seqCoreP.key


\sorts {
    Seq;
}

\predicates {
     seqPerm(Seq,Seq);
     seqNPerm(Seq);
}

\functions {
    //getters      
    alpha alpha::seqGet(Seq, int);
    int seqLen(Seq);
    int seqIndexOf(Seq, any);
    any seqGetOutside;
    
    //constructors
    Seq seqEmpty;
    Seq seqSingleton(any);
    Seq seqConcat(Seq, Seq);
    Seq seqSub(Seq, int, int);
    Seq seqReverse(Seq);
    Seq seqDef{false,false,true}(int, int, any);

    Seq seqSwap(Seq,int,int);
    Seq seqRemove(Seq,int);
    Seq seqNPermInv(Seq);

    
    // placeholder for values in enhanced for loop
    Seq values;
}


\rules {

    //===============================================================
    //  Core axioms
    //  (4 in total)
    //===============================================================
 
   //--------------------------------------------------------------------
    // Core axioms for equality of sequences
    //--------------------------------------------------------------------


    lenNonNegative {
	\schemaVar \term Seq seq;
   
	\find(seqLen(seq)) \sameUpdateLevel
	
	\add(0 <= seqLen(seq) ==>)
                     
      	\heuristics(inReachableStateImplication)
    };     


   equalityToSeqGetAndSeqLen {
     \schemaVar \term Seq s, s2;
     \schemaVar \variables int iv;    	
    	
    \find(s = s2)
    \varcond(\notFreeIn(iv, s, s2))
	
    \replacewith(seqLen(s) = seqLen(s2) 
     & \forall iv; (0 <= iv & iv < seqLen(s) 
           -> any::seqGet(s, iv) = any::seqGet(s2, iv)))

    };    

     
   //--------------------------------------------------------------------
    // Core axioms for sequence definition
    //--------------------------------------------------------------------


 getOfSeqDef {
	\schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;
   
	\find(alpha::seqGet(seqDef{uSub;} (from, to, t), idx))
	\varcond ( \notFreeIn(uSub, from), 
                   \notFreeIn(uSub, to))
	\replacewith(\if(0 <= idx & idx < (to - from))
	             \then( {\subst uSub; (idx + from)}t)
	             \else(seqGetOutside))
                     
      	\heuristics(simplify)
    };

//    getOfSeqDef {
//	\schemaVar \term int idx, from, to;
//        \schemaVar \term any t;
//        \schemaVar \variables int uSub, uSub1, uSub2;
//   
//	\find(beta::seqGet(seqDef{uSub;} (from, to, t), idx))
//	\varcond ( \notFreeIn(uSub, from), 
//                   \notFreeIn(uSub, to))
//	\replacewith(\if(0 <= idx & idx < (to - from))
//	             \then((beta) {\subst uSub; (idx + from)}t)
//	             \else(beta::seqGet(seqEmpty, 0)))
//                     
//      	\heuristics(simplify)
//    };


  lenOfSeqDef {
	\schemaVar \term int from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

   
	\find(seqLen(seqDef{uSub;} (from, to, t)))
	
	\replacewith(\if(from < to)\then((to - from))\else(0))
                     
      	\heuristics(simplify_enlarging)
    };


//   lenOfSeqDef {
//	\schemaVar \term int from, to;
//        \schemaVar \term any t;
//        \schemaVar \variables int uSub, uSub1, uSub2;
//
//   
//	\find(seqLen(seqDef{uSub;} (from, to, t)))
//	
//	\replacewith(\if(from <= to)\then((to - from))\else(0))
//                     
//      	\heuristics(simplify_enlarging)
//    };




    //--------------------------------------------------------------------
    // The core taclets for Seq end here.
    // Consistency of the core theory has to be guaranteed by external means,
    //  e.g. by presenting a model for it.
    // 
    //--------------------------------------------------------------------


    //--------------------------------------------------------------------------
    //  corePIX theory, extensions by Definitions 
    //  These taclets were not part of the original Seq axiomatization by
    //  B.Weiss
    //  These taclets extend the signature of the core theory by indroducing 
    //  function  symbols via explicit definition. 
    //  Consistency of the extended theory is thus guaranteed. 
    //  (Theorem on  conservative extentions)
    //--------------------------------------------------------------------------


    //--------------------------------------------------------------------
    // rule for generic types
    //--------------------------------------------------------------------


      castedGetAny {
	\schemaVar \term Seq seq;    
	\schemaVar \term int idx;	
   
	\find((beta)any::seqGet(seq, idx))
	
	\replacewith(beta::seqGet(seq, idx))
                     
      	\heuristics(simplify)
    };    


       seqGetAlphaCast {
	\schemaVar \term Seq seq;
	\schemaVar \term int at;
 
       \find( alpha::seqGet(seq,at) )
        \add( (alpha)any::seqGet(seq,at) = alpha::seqGet(seq,at) ==>)
        
       };





 defOfEmpty {
	\schemaVar \term any te;
        \schemaVar \variables int uSub;

        \find(seqEmpty)

        \varcond ( \notFreeIn(uSub, te)) 
	\replacewith(seqDef{uSub;}(0, 0, te))
    };
  
    defOfSeqSingleton {
	\schemaVar \term any x;
        \schemaVar \variables int uSub;

	\find(seqSingleton(x))

	\varcond ( \notFreeIn(uSub, x)) 
	\replacewith(seqDef{uSub;}(0,1,x))
                     
    };
    
    
    defOfSeqConcat {
	\schemaVar \term Seq seq1, seq2;
        \schemaVar \variables int uSub;

   
	\find(seqConcat(seq1, seq2))

	\varcond (\notFreeIn(uSub, seq1),
                \notFreeIn(uSub, seq2))
	\replacewith(seqDef{uSub;}(0,seqLen(seq1)+seqLen(seq2),
           \if (uSub < seqLen(seq1))
             \then (any::seqGet(seq1,uSub))
             \else (any::seqGet(seq2, uSub - seqLen(seq1)))))
                     
      };


    
//--------------------------------------------------------------------
//  The next definition differs from the original semantics of seqSub!
//  Now seqSub(seq,from,from) is the empty sequence, previously it
//  was the singleton <seq(from)>.
//  The new semantics however is in line with all other definitions
//  involving a lower and and upper bound. The upper bound is always
//  strict. 
//--------------------------------------------------------------------

    defOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
        \schemaVar \variables int uSub;

	\find(seqSub(seq, from, to))
        \varcond (\notFreeIn(uSub, seq),
               \notFreeIn(uSub, from),  \notFreeIn(uSub, to))
	\replacewith(seqDef{uSub;}(from,to,any::seqGet(seq,uSub)))
                     
     };
    
    
    defOfSeqReverse {
        \schemaVar \term Seq seq;
        \schemaVar \variables int uSub;

	\find(seqReverse(seq))

	\varcond (\notFreeIn(uSub, seq))
	\replacewith(seqDef{uSub;}(0,seqLen(seq),any::seqGet(seq,seqLen(seq)-uSub-1)))
                     
    };
    

    //--------------------------------------------------------------------
    // rule for seqIndexOf
    // This is logically equivalent to a conditional (partial)
    // definition of  seqIndexOf
    //--------------------------------------------------------------------

   seqIndexOf {
    \schemaVar \term Seq s;
    \schemaVar \term any t;
    \schemaVar \skolemTerm int jsk;
    \schemaVar \variables int n, m;

   \find(seqIndexOf(s,t))
   \varcond ( \new(jsk, \dependingOn(t)),  
          \notFreeIn(n, s), \notFreeIn(n, t),
          \notFreeIn(m, s), \notFreeIn(m, t))
   \replacewith(jsk)
   \add( 0 <= jsk & jsk < seqLen(s) & any::seqGet(s,jsk)=t & 
         \forall m;((0 <= m & m < jsk) -> any::seqGet(s,m)!=t) ==> );
   \add( ==> \exists n;( 0 <= n & n < seqLen(s) & any::seqGet(s,n) = t ))


   };



    //====================================================================
    //  
    //  Derived taclets
    //  All the following taclets can be derived from the taclets occuring prior
    //  to this point in this file.
    //  The taclets differ from the original axiomatization by
    //   (1) the right hand bound in seqDef is now strict
    //   (2) the default value is explicitely given by  seqGetOutside 
    //       instead of   any::seqGet(seqEmpty, 0)
    //   (3) generic types "alpha", "beta" are replaced by the constant 
    //       "any". This does not cause a loss of generality because of
    //       taclets  seqGetAlphaCast and  seqGetAlphaCast.
    //
    //  For transparency we give the old version, where applicable,
    //  as comments.
    //====================================================================


//
// The next two taclets have no counterpart invariants 
// in the old exiomatization. They can be derived from  seqCore
//

     seqSelfDefinition {
      \schemaVar \term Seq seq;
      \schemaVar \variables Seq s;
      \schemaVar \variables int u;
      \find(seq )
      \add(\forall s;(s = seqDef{u;}(0,seqLen(s),any::seqGet(s,u)))   ==>)

    };

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

      seqOutsideValue {
        \schemaVar \variables Seq s;
        \schemaVar \variables int iv;
      \find(seqGetOutside   )
      \add( \forall s;(\forall iv;((iv < 0 | seqLen(s)<= iv) 
               -> alpha::seqGet(s,iv) = (alpha)seqGetOutside)) ==>)

    };

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

 getOfSeqSingleton {
	\schemaVar \term any x;
	\schemaVar \term int idx;	
   
	\find(alpha::seqGet(seqSingleton(x), idx))
	
	\replacewith(\if(idx = 0)
                     \then( (alpha)x )
                     \else(  (alpha)seqGetOutside ))
                     
      	\heuristics(simplify)
    };
    

//    getOfSeqSingleton {
//	\schemaVar \term alpha x;
//	\schemaVar \term int idx;	
//   
//	\find(beta::seqGet(seqSingleton(x), idx))
//	
//	\replacewith(\if(idx = 0)
//                     \then((beta)x)
//                     \else(beta::seqGet(seqEmpty, 0)))
//                     
//      	\heuristics(simplify)
//    };
    
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

  getOfSeqConcat {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term int idx;
   
	\find(alpha::seqGet(seqConcat(seq, seq2), idx))
	
	\replacewith(\if(idx < seqLen(seq))
                     \then(alpha::seqGet(seq, idx))
                     \else(alpha::seqGet(seq2, idx - seqLen(seq))))
                     
      	\heuristics(simplify_enlarging)
    };

   
//    getOfSeqConcat {
//	\schemaVar \term Seq seq, seq2;
//	\schemaVar \term int idx;
//   
//	\find(beta::seqGet(seqConcat(seq, seq2), idx))
//	
//	\replacewith(\if(idx < seqLen(seq))
//                     \then(beta::seqGet(seq, idx))
//                     \else(beta::seqGet(seq2, idx - seqLen(seq))))
//                    
//      	\heuristics(simplify_enlarging)
//    };
   
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

  getOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int idx, from, to;
   
	\find(alpha::seqGet(seqSub(seq, from, to), idx))
	
	\replacewith(\if(0 <= idx & idx < (to - from))
	             \then(alpha::seqGet(seq, idx + from))
	             \else( (alpha)seqGetOutside ))
                     
      	\heuristics(simplify)
    };
   
//    getOfSeqSub {
//	\schemaVar \term Seq seq;
//	\schemaVar \term int idx, from, to;
//   
//	\find(beta::seqGet(seqSub(seq, from, to), idx))
//	
//	\replacewith(\if(0 <= idx & idx < (to - from) + 1)
//	             \then(beta::seqGet(seq, idx + from))
//	             \else(beta::seqGet(seqEmpty, 0)))
//                     
//      	\heuristics(simplify)
//    };
    
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//  
 
  getOfSeqReverse {
        \schemaVar \term Seq seq;
	\schemaVar \term int idx;        
   
	\find(alpha::seqGet(seqReverse(seq), idx))
	
	\replacewith(alpha::seqGet(seq, seqLen(seq) - 1 - idx))
                     
      	\heuristics(simplify_enlarging)
    };
        
//    getOfSeqReverse {
//        \schemaVar \term Seq seq;
//	\schemaVar \term int idx;        
//   
//	\find(beta::seqGet(seqReverse(seq), idx))
//	
//	\replacewith(beta::seqGet(seq, seqLen(seq) - 1 - idx))
//                     
//      	\heuristics(simplify_enlarging)
//    };
    
    
    
    
  lenOfSeqEmpty {
	\find(seqLen(seqEmpty))
	
	\replacewith(0)
                     
      	\heuristics(concrete)
    };
    
    
  lenOfSeqSingleton {
	\schemaVar \term alpha x;
   
	\find(seqLen(seqSingleton(x)))
	
	\replacewith(1)
                     
      	\heuristics(concrete)
    };
    
    
  lenOfSeqConcat {
	\schemaVar \term Seq seq, seq2;
   
	\find(seqLen(seqConcat(seq, seq2)))
	
	\replacewith(seqLen(seq) + seqLen(seq2))
                     
      	\heuristics(simplify)
    };
    
    lenOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
   
	\find(seqLen(seqSub(seq, from, to)))
	
	\replacewith(\if(from < to)\then(to - from)\else(0))
                     
      	\heuristics(simplify_enlarging)
    };   
    
//  lenOfSeqSub {
//	\schemaVar \term Seq seq;
//	\schemaVar \term int from, to;
//   
//	\find(seqLen(seqSub(seq, from, to)))
//	
//	\replacewith(\if(from <= to)\then((to - from) + 1)\else(0))
//                     
//      	\heuristics(simplify_enlarging)
//    };
    
    
  lenOfSeqReverse {
	\schemaVar \term Seq seq;
   
	\find(seqLen(seqReverse(seq)))
	
	\replacewith(seqLen(seq))
                     
      	\heuristics(simplify)    
    };
    
  equalityToSeqGetAndSeqLenLeft {
    \schemaVar \term Seq s, s2;
    \schemaVar \variables int iv;    	
    	
    \find(s = s2 ==>)
    \varcond(\notFreeIn(iv, s, s2))
	
    \add(seqLen(s) = seqLen(s2) 
    & \forall iv; (0 <= iv & iv < seqLen(s) 
           -> any::seqGet(s, iv) = any::seqGet(s2, iv)) ==>)
    	
    	\heuristics(inReachableStateImplication)
    };    


  equalityToSeqGetAndSeqLenRight {
    \schemaVar \term Seq s, s2;
    \schemaVar \variables int iv;    	
    	
    \find(==> s = s2)
    \varcond(\notFreeIn(iv, s, s2))
	
    \replacewith(==> seqLen(s) = seqLen(s2) 
   & \forall iv; (0 <= iv & iv < seqLen(s) 
        -> any::seqGet(s, iv) = any::seqGet(s2, iv)))
    	
    	\heuristics(simplify_enlarging)
    }; 
  
  

    //--------------------------------------------------------------------------
    // derived EQ versions 
    // again we give the old version, where applicable,
    //  as comments.
    //--------------------------------------------------------------------------
 
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//
    
  getOfSeqSingletonEQ{
	\schemaVar \term any x;
	\schemaVar \term int idx;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSingleton(x) = EQ ==>)   
	\find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(\if(idx = 0)
                     \then( (alpha)x)
                     \else( (alpha)seqGetOutside))
                     
      	\heuristics(simplify)
    };

//   getOfSeqSingletonEQ {
//	\schemaVar \term alpha x;
//	\schemaVar \term int idx;
//	\schemaVar \term Seq EQ;
//   
//        \assumes(seqSingleton(x) = EQ ==>)   
//	\find(beta::seqGet(EQ, idx))
//        \sameUpdateLevel	
//	
//	\replacewith(\if(idx = 0)
//                     \then((beta)x)
//                     \else(beta::seqGet(seqEmpty, 0)))
//                     
//      	\heuristics(simplify)
//    };
    
 
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

   getOfSeqConcatEQ {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term int idx;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqConcat(seq, seq2) = EQ ==>)      
	\find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(\if(idx < seqLen(seq))
                     \then(alpha::seqGet(seq, idx))
                     \else(alpha::seqGet(seq2, idx - seqLen(seq))))
                     
      	\heuristics(simplify_enlarging)
    };

   
//    getOfSeqConcatEQ {
//	\schemaVar \term Seq seq, seq2;
//	\schemaVar \term int idx;
//	\schemaVar \term Seq EQ;	
//   
//        \assumes(seqConcat(seq, seq2) = EQ ==>)      
//	\find(beta::seqGet(EQ, idx))
//       \sameUpdateLevel	
//	
//	\replacewith(\if(idx < seqLen(seq))
//                     \then(beta::seqGet(seq, idx))
//                     \else(beta::seqGet(seq2, idx - seqLen(seq))))
//                     
//      	\heuristics(simplify_enlarging)
//    };
    
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//
    getOfSeqSubEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term int idx, from, to;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSub(seq, from, to) = EQ ==>)
	\find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel
	
	\replacewith(\if(0 <= idx & idx < (to - from))
	             \then(alpha::seqGet(seq, idx + from))
	             \else((alpha)seqGetOutside))
                     
      	\heuristics(simplify)
    };

    
//   getOfSeqSubEQ {
//	\schemaVar \term Seq seq;
//	\schemaVar \term int idx, from, to;
//	\schemaVar \term Seq EQ;
//   
//        \assumes(seqSub(seq, from, to) = EQ ==>)
//	\find(beta::seqGet(EQ, idx))
//        \sameUpdateLevel
//	
//	\replacewith(\if(0 <= idx & idx < (to - from) + 1)
//	             \then(beta::seqGet(seq, idx + from))
//	             \else(beta::seqGet(seqEmpty, 0)))
//                     
//      	\heuristics(simplify)
//    };

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//  
       getOfSeqReverseEQ {
        \schemaVar \term Seq seq;
	\schemaVar \term int idx;        
	\schemaVar \term Seq EQ;        
   
        \assumes(seqReverse(seq) = EQ ==>)   
	\find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(alpha::seqGet(seq, seqLen(seq) - 1 - idx))
                     
      	\heuristics(simplify_enlarging)
    };

    
//    getOfSeqReverseEQ {
//        \schemaVar \term Seq seq;
//	\schemaVar \term int idx;        
//	\schemaVar \term Seq EQ;        
//   
//        \assumes(seqReverse(seq) = EQ ==>)   
//	\find(beta::seqGet(EQ, idx))
//        \sameUpdateLevel	
//	
//	\replacewith(beta::seqGet(seq, seqLen(seq) - 1 - idx))
//                     
//      	\heuristics(simplify_enlarging)
//    };
    
    
    lenOfSeqEmptyEQ {
	\schemaVar \term alpha x;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqEmpty = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel	
	\replacewith(0)

      	\heuristics(concrete)
    };    
    
    
    lenOfSeqSingletonEQ {
	\schemaVar \term alpha x;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqSingleton(x) = EQ ==>)   
	\find(seqLen(EQ))
        \sameUpdateLevel
	\replacewith(1)
                     
      	\heuristics(concrete)
    };
    
    
    lenOfSeqConcatEQ {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqConcat(seq, seq2) = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel
	
	\replacewith(seqLen(seq) + seqLen(seq2))
                     
      	\heuristics(simplify)
    };
    
     lenOfSeqSubEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSub(seq, from, to) = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel	
	
	\replacewith(\if(from < to)\then(to - from)\else(0))
                     
      	\heuristics(simplify_enlarging)
    };  

//    lenOfSeqSubEQ {
//	\schemaVar \term Seq seq;
//	\schemaVar \term int from, to;
//	\schemaVar \term Seq EQ;
//   
//        \assumes(seqSub(seq, from, to) = EQ ==>)
//	\find(seqLen(EQ))
//        \sameUpdateLevel	
//	
//	\replacewith(\if(from <= to)\then((to - from) + 1)\else(0))
//                    
//      	\heuristics(simplify_enlarging)
//    };    
    
    
    lenOfSeqReverseEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term Seq EQ;
   
  	\assumes(seqReverse(seq) = EQ ==>)
	\find(seqLen(EQ))
	\sameUpdateLevel
	
	\replacewith(seqLen(seq))
                     
      	\heuristics(simplify)    
    };
    
//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

  getOfSeqDefEQ {
	\schemaVar \term int idx, from, to;
        \schemaVar \term Seq EQ;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

   
        \assumes(seqDef{uSub;} (from, to, t) = EQ ==>)
	\find(alpha::seqGet(EQ, idx))
	\varcond ( \notFreeIn(uSub, from), 
                   \notFreeIn(uSub, to))
	\replacewith(\if(0 <= idx & idx < (to - from))
	             \then((alpha){\subst uSub; (idx + from)}t)
	             \else ( (alpha)seqGetOutside))
                     
      	\heuristics(simplify)
    };



//   getOfSeqDefEQ {
//	\schemaVar \term int idx, from, to;
//        \schemaVar \term Seq EQ;
//        \schemaVar \term any t;
//        \schemaVar \variables int uSub, uSub1, uSub2;
//
//        \assumes(seqDef{uSub;} (from, to, t) = EQ ==>)
//	\find(beta::seqGet(EQ, idx))
//	\varcond ( \notFreeIn(uSub, from), 
//                   \notFreeIn(uSub, to))
//	\replacewith(\if(0 <= idx & idx < (to - from))
//	             \then((beta) {\subst uSub; (idx + from)}t)
//	             \else(beta::seqGet(seqEmpty, 0)))
//                     
//      	\heuristics(simplify)
//    };

 lenOfSeqDefEQ {
	\schemaVar \term int from, to;
        \schemaVar \term Seq EQ;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

   
        \assumes(seqDef{uSub;} (from, to, t) = EQ ==>)
	\find(seqLen(EQ))
        
	\replacewith(\if(from <= to)\then((to - from))\else(0))
                     
      	\heuristics(simplify_enlarging)
    };

     
    //--------------------------------------------------------------------------
    // derived taclets involving  seqEmpty
    //--------------------------------------------------------------------------
    
    seqConcatWithSeqEmpty1 {
        \schemaVar \term Seq seq;
        
        \find(seqConcat(seq, seqEmpty))
        
        \replacewith(seq)
        
        \heuristics(concrete)
    };
    
    
    seqConcatWithSeqEmpty2 {
        \schemaVar \term Seq seq;
        
        \find(seqConcat(seqEmpty, seq))
        
        \replacewith(seq)
        
        \heuristics(concrete)
    };
    

    seqReverseOfSeqEmpty {
        \find(seqReverse(seqEmpty))
        
        \replacewith(seqEmpty)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    // derived taclets for special instantiations
    //--------------------------------------------------------------------------

     subSeqComplete {
	\schemaVar \term Seq seq;
   
	\find(seqSub(seq, 0, seqLen(seq)))
	
	\replacewith(seq)
                     
      	\heuristics(concrete)
    };   


//    subSeqComplete {
//	\schemaVar \term Seq seq;
//   
//	\find(seqSub(seq, 0, seqLen(seq) - 1))
//	
//	\replacewith(seq)
//                     
//      \heuristics(concrete)
//    };    
    
    subSeqTail {
	\schemaVar \term Seq seq;
	\schemaVar \term any x;	
   
	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, seqLen(seq)+1))
	
	\replacewith(seq)
                     
      	\heuristics(concrete)
    };
    
    subSeqTail2 {
	\schemaVar \term Seq seq;
	\schemaVar \term any x;	
   
	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, 1+seqLen(seq)))
	
	\replacewith(seq)
        
        \displayname "subSeqTail"
      	\heuristics(concrete)
    };
    
//    subSeqTail {
//	\schemaVar \term Seq seq;
//	\schemaVar \term any x;	
//   
//	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, seqLen(seq)))
//	
//	\replacewith(seq)
//                     
//      \heuristics(concrete)
//    };
  
    subSeqTailEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term any x;
	\schemaVar \term int EQ;
   
   	\assumes(seqLen(seq) = EQ ==>)
	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, EQ+1))
	\sameUpdateLevel
	
	\replacewith(seq)
                     
      	\heuristics(concrete)
    };  
  
    
//    subSeqTailEQ {
//	\schemaVar \term Seq seq;
//	\schemaVar \term any x;
//	\schemaVar \term int EQ;
//   
//   	\assumes(seqLen(seq) = EQ ==>)
//	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, EQ))
//	\sameUpdateLevel
//	
//	\replacewith(seq)
//                     
//     	\heuristics(concrete)
//    };      
    
    
  
  
   
  //--------------------------------------------------------------------------
  // other derived taclets 
  //--------------------------------------------------------------------------


    seqDef_split {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))
        \varcond ( \notFreeIn(uSub1, from), 
                \notFreeIn(uSub1, idx),
                \notFreeIn(uSub1, to),
                \notFreeIn(uSub, from), 
                \notFreeIn(uSub, idx),
                \notFreeIn(uSub, to),
                \notFreeIn(uSub1, t) )
        \replacewith(\if(from <=idx & idx < to)
           \then(seqConcat(
                    seqDef{uSub;}(from, idx, t), 
                    seqDef{uSub1;}(idx,to,{\subst uSub; uSub1}t)))
           \else(seqDef{uSub;}(from, to, t)))
    };
   

//  seqDef_split {
//    \schemaVar \term int idx, from, to;
//    \schemaVar \term any t;
//    \schemaVar \variables int uSub, uSub1, uSub2;
//
//    \find(seqDef{uSub;} (from, to, t))
//    \varcond (\notFreeIn(uSub1, from), 
//              \notFreeIn(uSub1, idx),
//              \notFreeIn(uSub1, to),
//              \notFreeIn(uSub, from), 
//              \notFreeIn(uSub, idx),
//              \notFreeIn(uSub, to),
//              \notFreeIn(uSub1, t) )
//    \replacewith(\if(from<=idx & idx<=to)
//         \then(seqConcat(
//              seqDef{uSub;}(from, idx, t), 
//              seqDef{uSub1;}(idx,to,{\subst uSub; uSub1}t)))
//        \else(seqDef{uSub;}(from, to, t)))
//    };




    seqDef_induction_upper {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))
        \varcond ( \notFreeIn(uSub, from), 
                \notFreeIn(uSub, to))
        \replacewith(seqConcat(
            seqDef{uSub;} (from, to-1, t), 
            \if(from<to)\then(seqSingleton({\subst uSub; (to-1)}t))
                        \else(seqEmpty)))
    };

  seqDef_induction_upper_concrete {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, 1+to, t))
        \varcond ( \notFreeIn(uSub, from), 
                   \notFreeIn(uSub, to))
        \replacewith(seqConcat(
           seqDef{uSub;} (from, to, t), 
         \if(from<=to)\then(seqSingleton({\subst uSub; (to)}t))
                       \else(seqEmpty)))
        \heuristics(simplify)
    };

//    seqDef_induction_upper_concrete {
//        \schemaVar \term int idx, from, to;
//        \schemaVar \term any t;
//        \schemaVar \variables int uSub, uSub1, uSub2;
//
//        \find(seqDef{uSub;} (from, 1+to, t))
//        \varcond ( \notFreeIn(uSub, from), 
//                   \notFreeIn(uSub, to))
//        \replacewith(seqConcat(
//           seqDef{uSub;} (from, to, t), 
//          \if(from<=to)\then(seqSingleton({\subst uSub; (to)}t))
//                       \else(seqEmpty)))
//        \heuristics(simplify)
//    };


    seqDef_induction_lower {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))
        \varcond ( \notFreeIn(uSub, from), 
                   \notFreeIn(uSub, to))
        \replacewith(seqConcat(
             \if(from<to)\then(seqSingleton({\subst uSub; (from)}t))
                         \else(seqEmpty), 
             seqDef{uSub;} (from+1, to, t)))
    };

    seqDef_induction_lower_concrete {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (-1+from, to, t))
        \varcond ( \notFreeIn(uSub, from), 
                \notFreeIn(uSub, to))
        \replacewith(seqConcat(
            \if(-1+from<to)\then(seqSingleton({\subst uSub; (-1+from)}t))
                           \else(seqEmpty), 
            seqDef{uSub;} (from, to, t)))
        \heuristics(simplify)
    };


  seqDef_split_in_three {
    \schemaVar \term int idx, from, to;
    \schemaVar \term any t;
    \schemaVar \variables int uSub, uSub1, uSub2;

    \find(seqDef{uSub;} (from, to, t)) \sameUpdateLevel
    \varcond (\notFreeIn(uSub, idx), 
              \notFreeIn(uSub1, t),
              \notFreeIn(uSub1, idx),
              \notFreeIn(uSub, from),
              \notFreeIn(uSub1, to))
  "Precondition":    \add(==> (from<=idx & idx<to));
  "Splitted SeqDef": \replacewith(
     seqConcat(seqDef{uSub;} (from, idx, t),
                seqConcat(seqSingleton({\subst uSub;  idx} t),
                          seqDef{uSub1;} (idx+1, to, {\subst uSub; uSub1}t))))
    };



    seqDef_empty {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, idx, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, from),
                  \notFreeIn(uSub, idx))
        "Precondition": \add(==> idx<=from);
        "Empty SeqDef": \replacewith(seqEmpty)
    };

    seqDef_one_summand {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, idx, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, from),
                \notFreeIn(uSub, idx))
        \replacewith(\if(from+1=idx)
                       \then(seqSingleton({\subst uSub;  from}t))
                       \else(seqDef{uSub;} (from, idx, t)))
    };
/// exception occurs during proof attempt
/// Since it was also unclear how useful this taclet
/// is it has been removed.

//    seqDef_empty_concrete1 {
//        \schemaVar \term int idx, from, to;
//        \schemaVar \term any t;
//        \schemaVar \variables int uSub, uSub1, uSub2;
//
//        \find(==>seqDef{uSub;} ( Z(iz),  Z(jz), t)=seqEmpty)
//        \varcond (\notFreeIn(uSub, iz),
//                \notFreeIn(uSub, jz))
//        \add(==> Z(jz)<=Z(iz))
//        \heuristics(simplify)
//    };

/// exception occurs during proof attempt
/// Since it was also unclear how useful this taclet
/// is it has been removed.

//    seqDef_empty_concrete2 {
//        \schemaVar \term int idx, from, to;
//        \schemaVar \term any t;
//        \schemaVar \variables int uSub, uSub1, uSub2;
//
//
//
//        \find(seqDef{uSub;} ( Z(iz), Z(neglit(jz)), t))
//        \varcond (\notFreeIn(uSub, iz),
//                \notFreeIn(uSub, jz))
//        \replacewith(\if(Z(neglit(jz))<=Z(iz))
//                       \then(seqEmpty)
//                        \else(seqDef{uSub;} ( Z(iz), Z(neglit(jz)), t)))
//        \heuristics(simplify)
//    };

    seqDef_lower_equals_upper {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (idx, idx, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, idx))
        \replacewith(seqEmpty)
        \heuristics(simplify)
    };


 
  //--------------------------------------------------------------------------
  // derived taclets for seqIndexOf
  //--------------------------------------------------------------------------   



    indexOfSeqSingleton {
    	\schemaVar \term any x;
    	\find(seqIndexOf(seqSingleton(x),x))
    	\sameUpdateLevel
    	\replacewith(0)
    	\heuristics(concrete)
    };

  indexOfSeqConcatFirst {
    	\schemaVar \term Seq s1, s2;
    	\schemaVar \term any x;
    	\schemaVar \variables int idx;
    	\find(seqIndexOf(seqConcat(s1,s2),x))
    	\sameUpdateLevel
    	\varcond(\notFreeIn(idx,s1,s2,x))
  \replacewith(seqIndexOf(s1,x));
  \add(==> \exists idx; (0 <= idx & idx < seqLen(s1) & 
                         any::seqGet(s1,idx) = x))
    };

 indexOfSeqConcatSecond {
    	\schemaVar \term Seq s1, s2;
    	\schemaVar \term any x;
    	\schemaVar \variables int idx;
    	\find(seqIndexOf(seqConcat(s1,s2),x))
    	\sameUpdateLevel
    	\varcond(\notFreeIn(idx,s1,s2,x))
  \replacewith(add(seqIndexOf(s2,x),seqLen(s1))) ;
  \add(==> (!\exists idx; 
              (0 <= idx & idx < seqLen(s1) & any::seqGet(s1,idx) = x)
    	   & \exists idx; 
     (0 <= idx & idx < seqLen(s2) & any::seqGet(s2,idx) = x)) )
    };
    
// indexOfSeqConcatSecond {
//   \schemaVar \term Seq s1, s2;
//   \schemaVar \term any x;
//   \schemaVar \variables int idx;
//   \find(seqIndexOf(seqConcat(s1,s2),x))
//   \sameUpdateLevel
//   \varcond(\notFreeIn(idx,s1,s2,x))
//   \replacewith(add(seqIndexOf(s2,x),seqLen(s1))) ;
//   \add(==> (!\exists idx; (0 <= idx & idx < seqLen(s1) & 
//                             any::seqGet(s1,idx) = x)
//    	      & \exists idx; (0 <= idx & idx < seqLen(s2) & 
//                      any::seqGet(s2,add(seqLen(s1),idx)) = x)) )
//    };

 indexOfSeqSub {
    	\schemaVar \term Seq s;
    	\schemaVar \term int from, to, n;
    	\schemaVar \term any x;
	\schemaVar \variables int nx;

    	\find(seqIndexOf(seqSub(s,from,to),x))
	\sameUpdateLevel
        \varcond (\notFreeIn(nx, s),    \notFreeIn(nx, x), 
                  \notFreeIn(nx, from), \notFreeIn(nx, to))
       	\replacewith(sub(seqIndexOf(s,x),from));
    	\add(==> from <= seqIndexOf(s,x) & seqIndexOf(s,x) < to & 0 <= from &
             \exists nx;((0 <= nx & nx < seqLen(s) & any::seqGet(s,nx) = x)))
    };

//    indexOfSeqSub {
//    	\schemaVar \term Seq s;
//    	\schemaVar \term int from, to;
//    	\schemaVar \term any x;
//    	\find(seqIndexOf(seqSub(s,from,to),x))
//    	\sameUpdateLevel
//    	\replacewith(sub(seqIndexOf(s,x),from));
//    	\add(==> from <= seqIndexOf(s,x) & seqIndexOf(s,x) <= to)
//    };
 
//
//    Since seqIndexOf(s,x) is the first index i with 
//          s[i] = x the following taclet is incorrect
//    No fix could be found.
// 
//
//    indexOfSeqReverse {
//    	\schemaVar \term Seq s;
//    	\schemaVar \term any x;
//    	\find(seqIndexOf(seqReverse(s),x))
//    	\replacewith(sub(seqLen(s),seqIndexOf(s,x)))
//    	\heuristics(simplify_enlarging)
//    };



   //--------------------------------------------------------------------------
    //  Second Extensions by Definitions 
    //  These taclets were not part of the original Seq axiomatization by
    //  B.Weiss
    //  These taclets extend the signature of corePIX by indroducing 
    //  the relation symbols 
    //            seqPerm(Seq,Seq), seqNPerm(Seq) 
    //  and the function symbols
    //           Seq seqSwap(Seq,int,int)
    //           Seq seqRemove(Seq,int)
    //  by direct definitions.
    //  Consistency of the extended theory is thus guaranteed. 
    //  (Theorem on  conservative extentions)
    //  Note, that the function Seq NPermInv(Seq)
    //  has already been aziomatized in seqCorePIX. It cannot be introduced
    //  by direct definitions (at least as long as epsilon terms are 
    //  not allowed)
    //--------------------------------------------------------------------------



   seqNPermDefLeft{
    \schemaVar \term Seq s1;
    \schemaVar \variables int iv,jv;

    \find(seqNPerm(s1) ==> )
    \varcond (\notFreeIn (iv,s1), \notFreeIn (jv,s1))

    \add(
     (\forall iv; (0 <= iv &  iv <seqLen(s1) ->  
        \exists jv; (0 <= jv &  jv<seqLen(s1) & int::seqGet(s1,jv)=iv))) ==> )
     };

 seqNPermDefReplace{
    \schemaVar \term Seq s1;
    \schemaVar \variables int iv,jv;

    \find(seqNPerm(s1))
    \varcond (\notFreeIn (iv,s1), \notFreeIn (jv,s1))

    \replacewith(
     (\forall iv; (0 <= iv &  iv<seqLen(s1) ->  
           \exists jv; (0 <= jv &  jv<seqLen(s1) & int::seqGet(s1,jv)=iv))))
     };

seqPermDefLeft{
   \schemaVar \term Seq s1, s2, s3;
   \schemaVar \variables int iv;
   \schemaVar \variables Seq s;

   \find(seqPerm(s1,s2) ==> )
  
   \varcond (\notFreeIn (iv,s1,s2), 
             \notFreeIn (s,s1,s2))

   \add(
      seqLen(s1) = seqLen(s2) & 
    (\exists s; (seqLen(s) = seqLen(s1)  & seqNPerm(s) & 

       (\forall iv; (0 <= iv &  iv < seqLen(s) ->  
           any::seqGet(s1,iv) = any::seqGet(s2,int::seqGet(s,iv))))))
        ==> )  
    };

 seqPermDef{
   \schemaVar \term Seq s1, s2, s3;
   \schemaVar \variables int iv;
   \schemaVar \variables Seq s;

   \find(seqPerm(s1,s2))
  
   \varcond (\notFreeIn (iv,s1,s2), 
             \notFreeIn (s,s1,s2))

   \replacewith(
      seqLen(s1) = seqLen(s2) & 
    (\exists s; (seqLen(s) = seqLen(s1)  & seqNPerm(s) & 

       (\forall iv; (0 <= iv &  iv < seqLen(s) ->  
           any::seqGet(s1,iv) = any::seqGet(s2,int::seqGet(s,iv))))))
              )  
    };


    defOfSeqSwap {
	\schemaVar \term Seq s;
	\schemaVar \term int iv,jv;
        \schemaVar \variables int uSub;

	\find(seqSwap(s,iv,jv))

	\varcond ( \notFreeIn(uSub, s),
                   \notFreeIn(uSub, iv),
                   \notFreeIn(uSub, jv) )
	\replacewith(seqDef{uSub;}(0,seqLen(s),
             \if (!(0<= iv & 0<= jv & iv<seqLen(s) & jv < seqLen(s)))
             \then (any::seqGet(s,uSub))
             \else ( \if(uSub = iv)
                     \then(any::seqGet(s,jv))
                     \else(\if(uSub = jv)
                           \then(any::seqGet(s,iv))
                           \else(any::seqGet(s,uSub))))))      
                     
    };

   defOfSeqRemove {
	\schemaVar \term Seq s;
	\schemaVar \term int iv;
        \schemaVar \variables int uSub;

       \find(seqRemove(s,iv))
         \varcond ( \notFreeIn(uSub, s),
                    \notFreeIn(uSub, iv) )
      
       \replacewith( 
            \if (iv < 0 | seqLen(s) <= iv )
            \then (s)
            \else (seqDef{uSub;}(0,seqLen(s)-1,
                  \if (uSub < iv)
                  \then (any::seqGet(s,uSub))
                  \else (any::seqGet(s,uSub+1)))))
     };



    //--------------------------------------------------------------------
    // rule for seqNPermInv
    // These rules are new. They are needed since the inverse
    // of a permutation of integers cannot be defined explicitely,
    // epsilon terms would be needed for this.
    //--------------------------------------------------------------------


 lenOfNPermInv {
    \schemaVar \term Seq s1;
        \find(seqLen(seqNPermInv(s1)))
    \replacewith(seqLen(s1))

    \heuristics(simplify)
  };

   getOfNPermInv {
    \schemaVar \term Seq s1;
    \schemaVar \term int i3;
    \schemaVar \skolemTerm int jsk;
    
    \find(int::seqGet(seqNPermInv(s1), i3))
     \varcond ( \new(jsk, \dependingOn(i3)) )
     \replacewith(jsk)
     \add (int::seqGet(s1,jsk) = i3 & 0 <= jsk & jsk < seqLen(s1) ==> );
     \add ( ==> 0<= i3 & i3 < seqLen(s1))

    \heuristics(simplify)
  };

    //==================================================================
    //  derived taclets involving the functions seqSwap, seqRemove,
    //  and seqNPermInv
    //  
    //==================================================================


    lenOfSwap {
    \schemaVar \term Seq s1;
    \schemaVar \term int iv1, iv2;
    \find(seqLen(seqSwap(s1, iv1, iv2)))
    \replacewith(seqLen(s1))

    \heuristics(simplify)
  };

  getOfSwap {
    \schemaVar \term Object o;
    \schemaVar \term Seq s1;
    \schemaVar \term int iv, jv, idx;
    \schemaVar \term Heap h;

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

    \find(alpha::seqGet(seqSwap(s1,iv,jv), idx))
    \replacewith( \if (!(0<= iv & 0<= jv & iv <seqLen(s1) & jv < seqLen(s1)))
             \then (alpha::seqGet(s1,idx))
             \else ( \if(idx = iv)
                     \then(alpha::seqGet(s1,jv))
                     \else(\if(idx = jv)
                           \then(alpha::seqGet(s1,iv))
                           \else(alpha::seqGet(s1,idx)))))

    \heuristics(simplify)
  };

 lenOfRemove {
    \schemaVar \term Seq s1;
    \schemaVar \term int iv1;

    \find(seqLen(seqRemove(s1,iv1)))
    \replacewith(
           \if (0<= iv1 & iv1 < seqLen(s1)) 
           \then (seqLen(s1)-1) 
           \else (seqLen(s1)))

    \heuristics(simplify)
  };

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

  getOfRemoveAny {
    \schemaVar \term Seq s1;
    \schemaVar \term int i3,i2;
    
    \find(alpha::seqGet(seqRemove(s1,i2), i3))
     \replacewith(\if (i2 < 0 | seqLen(s1) <= i2) 
                  \then (alpha::seqGet(s1,i3)) 
                  \else ( \if(i3 < i2)
                          \then (alpha::seqGet(s1,i3)) 
                          \else( \if (i2 <= i3 & i3 <seqLen(s1)-1) 
                                 \then (alpha::seqGet(s1,i3+1))
                                 \else ((alpha)seqGetOutside))))

    \heuristics(simplify)
  };


  getOfRemoveInt {
    \schemaVar \term Seq s1;
    \schemaVar \term int i3,i2;
    
    \find(int::seqGet(seqRemove(s1,i2), i3))
     \replacewith(\if (i2 < 0 | seqLen(s1) <= i2) 
                  \then (int::seqGet(s1,i3)) 
                  \else ( \if(i3 < i2)
                          \then (int::seqGet(s1,i3)) 
                          \else( \if (i2 <= i3 & i3 <seqLen(s1)-1) 
                                 \then (int::seqGet(s1,i3+1))
                                 \else ((int)seqGetOutside))))

    \heuristics(simplify)
  };

 lenOfRemoveConcrete1 {
    \schemaVar \term Seq s1;

    \assumes(seqLen(s1)>= 1 ==>)
    \find(seqLen(seqRemove(s1,seqLen(s1)-1)))
    \replacewith(seqLen(s1)-1)

    \heuristics(simplify)
  };

lenOfRemoveConcrete2 {
    \schemaVar \term Seq s1;

    \assumes(seqLen(s1)>= 1 ==> )
    \find(seqLen(seqRemove(s1,0)))
    \replacewith(seqLen(s1)-1)

    \heuristics(simplify)
  };

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

  getOfRemoveAnyConcrete1 {
    \schemaVar \term Seq s1;
    \schemaVar \term int i3,i2;
    \assumes(seqLen(s1)>= 1 ==>)
    \find(alpha::seqGet(seqRemove(s1,seqLen(s1)-1), i3))
     \replacewith(\if   (i3 < seqLen(s1)-1)
                  \then (alpha::seqGet(s1,i3)) 
                  \else ((alpha)seqGetOutside))

    \heuristics(simplify)
  };

//  Differs from seqOutsideValue in seqStandard-new-verify.key
//

getOfRemoveAnyConcrete2 {
    \schemaVar \term Seq s1;
    \schemaVar \term int i3,i2;
    \assumes(seqLen(s1) >= 1 ==> )
    \find(alpha::seqGet(seqRemove(s1,0), i3))
     \replacewith(\if   (0 <= i3 & i3 < seqLen(s1)-1)
                  \then (alpha::seqGet(s1,i3+1)) 
                  \else ((alpha)seqGetOutside))

    \heuristics(simplify)
  };



    //--------------------------------------------------------------------------
    //  derived basic properties of permutations on natural
    //  numbers
    //  
    //--------------------------------------------------------------------------



//
//  The following taclet formalizes a kind of pidgeon hole principle
//  It is the only taclet whose derivation requires induction
//

 seqNPermRange {
        \schemaVar \term Seq s;
        \schemaVar \variables int iv;
      \find(seqNPerm(s) ==> )
      \varcond( \notFreeIn (iv,s)  )
      \add(\forall iv;((0 <= iv & iv <  seqLen(s)) 
         ->  (0 <= int::seqGet(s,iv) &  int::seqGet(s,iv) < seqLen(s))) ==>)

    };

//
//  The following taclet formalizes the mathematical fact
//  that every sujective function from a finite set into
//  itself is injective.
//  It can be proved using the previous taclet without induction.
//

 seqNPermInjective {
        \schemaVar \term Seq s;
        \schemaVar \variables int iv,jv;
      \find(seqNPerm(s) ==> )
      \varcond( \notFreeIn (iv,s), \notFreeIn (jv,s)  )
      \add(\forall iv;(\forall jv;(
       (0 <= iv & iv <  seqLen(s) & 0 <= jv & jv <  seqLen(s) 
        & int::seqGet(s,iv) = int::seqGet(s,jv) )
        ->  iv = jv )) ==>)

    };


 seqPermTrans{
    \schemaVar \term Seq s1, s2, s3;

        \assumes( seqPerm(s2,s3) ==>)
        \find(seqPerm(s1,s2) ==> )
        \add(seqPerm(s1,s3) ==>)
   };


 seqPermRefl{
    \schemaVar \term Seq s1;
     \add(seqPerm(s1,s1) ==>)
   };


  
   seqNPermSwapNPerm {
     \schemaVar \term Seq s1;
     \schemaVar \variables int iv,jv;

     \find( seqNPerm(s1) ==>)
     \varcond( \notFreeIn(iv, s1), \notFreeIn(jv, s1)   )   

     \add(\forall iv;(\forall jv;(
      ( 0 <= iv & 0 <= jv & iv < seqLen(s1) & jv < seqLen(s1) )
        -> seqNPerm(seqSwap(s1,iv,jv)))) ==>)

    };

   
    seqNPermEmpty {

    \find( ==> seqNPerm(seqEmpty))
    \replacewith ( ==>  true )

    \heuristics(simplify)
    };

  seqNPermSingletonConrete {

    \find( ==> seqNPerm(seqSingleton(0)))
    \replacewith ( ==>  true )

    \heuristics(simplify)
    };

 seqNPermSingleton {
   \schemaVar \term int si;

    \find( ==> seqNPerm(seqSingleton(si)))
    \replacewith ( ==> si=0 )

    \heuristics(simplify)
    };



   seqNPermComp {
    \schemaVar \term Seq s1,s2;
    \schemaVar \variables int u;
      \assumes(seqNPerm(s2) & seqLen(s1) = seqLen(s2) ==> )
      \find( seqNPerm(s1) ==>)
      \varcond( \notFreeIn(u, s1), \notFreeIn(u, s2)   ) 

      \add(seqNPerm(seqDef{u;}(0,seqLen(s1),
                          int::seqGet(s1,int::seqGet(s2,u)))) ==>)

   };

 seqGetSInvS {
      \schemaVar \term Seq s;
      \schemaVar \term int t;

  \find( int::seqGet(s,int::seqGet(seqNPermInv(s),t)))
  \replacewith ( t  );
  \add( ==> seqNPerm(s) & 0 <= t & t < seqLen(s))

  \heuristics(simplify)

  };

  seqNPermInvNPermLeft{
    \schemaVar \term Seq s1;

        \find(seqNPerm(s1) ==> )
        \add(seqNPerm(seqNPermInv(s1)) ==> )
   };


 seqPermSym{
    \schemaVar \term Seq s1,s2;

     \find(seqPerm(s1,s2) ==> )
     \add(seqPerm(s2,s1) ==>)
   };

 seqNPermInvNPermReplace{
    \schemaVar \term Seq s1;

        \find(seqNPerm(seqNPermInv(s1)))
        \replacewith(seqNPerm(s1))
   };


  seqPermConcatFW {
      \schemaVar \term Seq s1,s2,t1,t2;

      \assumes(seqPerm(s1,t1) ==> )
      \find(seqPerm(s2,t2) ==> )
      \add(seqPerm(seqConcat(s1,s2),seqConcat(t1,t2)) ==> )
   };

  seqPermConcatBW {
    \schemaVar \term Seq s1,s2,t1,t2;
 
    \assumes(seqPerm(s1,t1) ==> )
   \find(  ==> seqPerm(seqConcat(s1,s2),seqConcat(t1,t2)))
   \replacewith( ==> seqPerm(s2,t2))

    \heuristics(simplify)
   };


 seqnormalizeDef{
     \schemaVar \term Seq s1;
     \schemaVar \term int le,ri;
     \schemaVar \term any t;
     \schemaVar \variables int u;

    \find(seqDef{u;}(le,ri,t))
     \varcond( \notFreeIn(u, le), \notFreeIn(u, ri)) 
    \replacewith(\if   (le < ri )
                  \then (seqDef{u;}(0,(ri-le),({\subst u; (u + le)}t))) 
                  \else (seqEmpty ))  

  };
 
}
