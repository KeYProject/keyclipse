\sorts {
    Seq;
}


\functions {
    //getters
    alpha alpha::seqGet(Seq, int);
    int seqLen(Seq);
    int seqIndexOf(Seq, any);
    
    //constructors
    Seq seqEmpty;
    Seq seqSingleton(any);
    Seq seqConcat(Seq, Seq);
    Seq seqSub(Seq, int, int);
    Seq seqReverse(Seq);
    Seq seqDef{false,false,true}(int, int, any);
    
    // placeholder for values in enhanced for loop
    Seq values;
}


\rules {

    //--------------------------------------------------------------------------
    //axioms
    //--------------------------------------------------------------------------
    
    getOfSeqSingleton {
	\schemaVar \term alpha x;
	\schemaVar \term int idx;	
   
	\find(beta::seqGet(seqSingleton(x), idx))
	
	\replacewith(\if(idx = 0)
                     \then((beta)x)
                     \else(beta::seqGet(seqEmpty, 0)))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqConcat {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term int idx;
   
	\find(beta::seqGet(seqConcat(seq, seq2), idx))
	
	\replacewith(\if(idx < seqLen(seq))
                     \then(beta::seqGet(seq, idx))
                     \else(beta::seqGet(seq2, idx - seqLen(seq))))
                     
      	\heuristics(simplify_enlarging)
    };
    
    
    getOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int idx, from, to;
   
	\find(beta::seqGet(seqSub(seq, from, to), idx))
	
	\replacewith(\if(0 <= idx & idx < (to - from) + 1)
	             \then(beta::seqGet(seq, idx + from))
	             \else(beta::seqGet(seqEmpty, 0)))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqReverse {
        \schemaVar \term Seq seq;
	\schemaVar \term int idx;        
   
	\find(beta::seqGet(seqReverse(seq), idx))
	
	\replacewith(beta::seqGet(seq, seqLen(seq) - 1 - idx))
                     
      	\heuristics(simplify_enlarging)
    };
    
    
    lenNonNegative {
	\schemaVar \term Seq seq;
   
	\find(seqLen(seq)) \sameUpdateLevel
	
	\add(0 <= seqLen(seq) ==>)
                     
      	\heuristics(inReachableStateImplication)
    };    
    
    
    lenOfSeqEmpty {
	\find(seqLen(seqEmpty))
	
	\replacewith(0)
                     
      	\heuristics(concrete)
    };
    
    
    lenOfSeqSingleton {
	\schemaVar \term alpha x;
   
	\find(seqLen(seqSingleton(x)))
	
	\replacewith(1)
                     
      	\heuristics(concrete)
    };
    
    
    lenOfSeqConcat {
	\schemaVar \term Seq seq, seq2;
   
	\find(seqLen(seqConcat(seq, seq2)))
	
	\replacewith(seqLen(seq) + seqLen(seq2))
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
   
	\find(seqLen(seqSub(seq, from, to)))
	
	\replacewith(\if(from <= to)\then((to - from) + 1)\else(0))
                     
      	\heuristics(simplify_enlarging)
    };
    
    
    lenOfSeqReverse {
	\schemaVar \term Seq seq;
   
	\find(seqLen(seqReverse(seq)))
	
	\replacewith(seqLen(seq))
                     
      	\heuristics(simplify)    
    };
    
    
    equalityToSeqGetAndSeqLen {
    	\schemaVar \term Seq s, s2;
	\schemaVar \variables int iv;    	
    	
    	\find(s = s2)
	\varcond(\notFreeIn(iv, s, s2))
	
    	\replacewith(seqLen(s) = seqLen(s2) 
    	             & \forall iv; (0 <= iv & iv < seqLen(s) -> any::seqGet(s, iv) = any::seqGet(s2, iv)))
    };    
    
    
    equalityToSeqGetAndSeqLenLeft {
    	\schemaVar \term Seq s, s2;
	\schemaVar \variables int iv;    	
    	
    	\find(s = s2 ==>)
	\varcond(\notFreeIn(iv, s, s2))
	
    	\add(seqLen(s) = seqLen(s2) 
    	     & \forall iv; (0 <= iv & iv < seqLen(s) -> any::seqGet(s, iv) = any::seqGet(s2, iv)) ==>)
    	
    	\heuristics(inReachableStateImplication)
    };    


    equalityToSeqGetAndSeqLenRight {
    	\schemaVar \term Seq s, s2;
	\schemaVar \variables int iv;    	
    	
    	\find(==> s = s2)
	\varcond(\notFreeIn(iv, s, s2))
	
    	\replacewith(==> seqLen(s) = seqLen(s2) 
    	                 & \forall iv; (0 <= iv & iv < seqLen(s) -> any::seqGet(s, iv) = any::seqGet(s2, iv)))
    	
    	\heuristics(simplify_enlarging)
    };

    indexOfSeqSingleton {
    	\schemaVar \term any x;
    	\find(seqIndexOf(seqSingleton(x),x))
    	\sameUpdateLevel
    	\replacewith(0)
    	\heuristics(concrete)
    };
    
    indexOfSeqConcatFirst {
    	\schemaVar \term Seq s1, s2;
    	\schemaVar \term any x;
    	\schemaVar \variables int idx;
    	\find(seqIndexOf(seqConcat(s1,s2),x))
    	\sameUpdateLevel
    	\varcond(\notFreeIn(idx,s1,s2,x))
    	  \replacewith(seqIndexOf(s1,x));
    	  \add(==> \exists idx; (0 <= idx & idx < seqLen(s1) & any::seqGet(s1,idx) = x))
    };
     
    indexOfSeqConcatSecond {
    	\schemaVar \term Seq s1, s2;
    	\schemaVar \term any x;
    	\schemaVar \variables int idx;
    	\find(seqIndexOf(seqConcat(s1,s2),x))
    	\sameUpdateLevel
    	\varcond(\notFreeIn(idx,s1,s2,x))
    	  \replacewith(add(seqIndexOf(s2,x),seqLen(s1))) ;
    	  \add(==> (!\exists idx; (0 <= idx & idx < seqLen(s1) & any::seqGet(s1,idx) = x)
    	           & \exists idx; (0 <= idx & idx < seqLen(s2) & any::seqGet(s2,add(seqLen(s1),idx)) = x)) )
    };

    indexOfSeqSub {
    	\schemaVar \term Seq s;
    	\schemaVar \term int from, to;
    	\schemaVar \term any x;
    	\find(seqIndexOf(seqSub(s,from,to),x))
    	\sameUpdateLevel
    	\replacewith(sub(seqIndexOf(s,x),from));
    	\add(==> from <= seqIndexOf(s,x) & seqIndexOf(s,x) <= to)
    };
    
    indexOfSeqReverse {
    	\schemaVar \term Seq s;
    	\schemaVar \term any x;
    	\find(seqIndexOf(seqReverse(s),x))
    	\replacewith(sub(seqLen(s),seqIndexOf(s,x)))
    	\heuristics(simplify_enlarging)
    };
    
    

    //--------------------------------------------------------------------------
    //EQ versions of axioms (these are lemmata)
    //--------------------------------------------------------------------------
    
    getOfSeqSingletonEQ {
	\schemaVar \term alpha x;
	\schemaVar \term int idx;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSingleton(x) = EQ ==>)   
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(\if(idx = 0)
                     \then((beta)x)
                     \else(beta::seqGet(seqEmpty, 0)))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqConcatEQ {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term int idx;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqConcat(seq, seq2) = EQ ==>)      
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(\if(idx < seqLen(seq))
                     \then(beta::seqGet(seq, idx))
                     \else(beta::seqGet(seq2, idx - seqLen(seq))))
                     
      	\heuristics(simplify_enlarging)
    };
    
    
    getOfSeqSubEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term int idx, from, to;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSub(seq, from, to) = EQ ==>)
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel
	
	\replacewith(\if(0 <= idx & idx < (to - from) + 1)
	             \then(beta::seqGet(seq, idx + from))
	             \else(beta::seqGet(seqEmpty, 0)))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqReverseEQ {
        \schemaVar \term Seq seq;
	\schemaVar \term int idx;        
	\schemaVar \term Seq EQ;        
   
        \assumes(seqReverse(seq) = EQ ==>)   
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(beta::seqGet(seq, seqLen(seq) - 1 - idx))
                     
      	\heuristics(simplify_enlarging)
    };
    
    
    lenOfSeqEmptyEQ {
	\schemaVar \term alpha x;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqEmpty = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel	
	
	\replacewith(0)

      	\heuristics(concrete)
    };    
    
    
    lenOfSeqSingletonEQ {
	\schemaVar \term alpha x;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqSingleton(x) = EQ ==>)   
	\find(seqLen(EQ))
        \sameUpdateLevel
	
	\replacewith(1)
                     
      	\heuristics(concrete)
    };
    
    
    lenOfSeqConcatEQ {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqConcat(seq, seq2) = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel
	
	\replacewith(seqLen(seq) + seqLen(seq2))
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqSubEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSub(seq, from, to) = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel	
	
	\replacewith(\if(from <= to)\then((to - from) + 1)\else(0))
                     
      	\heuristics(simplify_enlarging)
    };    
    
    
    lenOfSeqReverseEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term Seq EQ;
   
  	\assumes(seqReverse(seq) = EQ ==>)
	\find(seqLen(EQ))
	\sameUpdateLevel
	
	\replacewith(seqLen(seq))
                     
      	\heuristics(simplify)    
    };
    
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for seqEmpty
    //--------------------------------------------------------------------------
    
    seqConcatWithSeqEmpty1 {
        \schemaVar \term Seq seq;
        
        \find(seqConcat(seq, seqEmpty))
        
        \replacewith(seq)
        
        \heuristics(concrete)
    };
    
    
    seqConcatWithSeqEmpty2 {
        \schemaVar \term Seq seq;
        
        \find(seqConcat(seqEmpty, seq))
        
        \replacewith(seq)
        
        \heuristics(concrete)
    };
    

    seqReverseOfSeqEmpty {
        \find(seqReverse(seqEmpty))
        
        \replacewith(seqEmpty)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //other lemmata
    //--------------------------------------------------------------------------
    
    subSeqComplete {
	\schemaVar \term Seq seq;
   
	\find(seqSub(seq, 0, seqLen(seq) - 1))
	
	\replacewith(seq)
                     
      	\heuristics(concrete)
    };    
    
    
    subSeqTail {
	\schemaVar \term Seq seq;
	\schemaVar \term any x;	
   
	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, seqLen(seq)))
	
	\replacewith(seq)
                     
      	\heuristics(concrete)
    };
    
    
    subSeqTailEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term any x;
	\schemaVar \term int EQ;
   
   	\assumes(seqLen(seq) = EQ ==>)
	\find(seqSub(seqConcat(seqSingleton(x), seq), 1, EQ))
	\sameUpdateLevel
	
	\replacewith(seq)
                     
      	\heuristics(concrete)
    };      
    
    
    castedGetAny {
	\schemaVar \term Seq seq;    
	\schemaVar \term int idx;	
   
	\find((beta)any::seqGet(seq, idx))
	
	\replacewith(beta::seqGet(seq, idx))
                     
      	\heuristics(simplify)
    }; 
    

    //--------------------------------------------------------------------
    // rules for sequence definition
    //--------------------------------------------------------------------

    getOfSeqDef {
	\schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;
   
	\find(beta::seqGet(seqDef{uSub;} (from, to, t), idx))
	\varcond ( \notFreeIn(uSub, from), 
                   \notFreeIn(uSub, to))
	\replacewith(\if(0 <= idx & idx < (to - from))
	             \then((beta) {\subst uSub; (idx + from)}t)
	             \else(beta::seqGet(seqEmpty, 0)))
                     
      	\heuristics(simplify)
    };

    getOfSeqDefEQ {
	\schemaVar \term int idx, from, to;
        \schemaVar \term Seq EQ;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

   
        \assumes(seqDef{uSub;} (from, to, t) = EQ ==>)
	\find(beta::seqGet(EQ, idx))
	\varcond ( \notFreeIn(uSub, from), 
                   \notFreeIn(uSub, to))
	\replacewith(\if(0 <= idx & idx < (to - from))
	             \then((beta) {\subst uSub; (idx + from)}t)
	             \else(beta::seqGet(seqEmpty, 0)))
                     
      	\heuristics(simplify)
    };

    lenOfSeqDef {
	\schemaVar \term int from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

   
	\find(seqLen(seqDef{uSub;} (from, to, t)))
	
	\replacewith(\if(from <= to)\then((to - from))\else(0))
                     
      	\heuristics(simplify_enlarging)
    };

    lenOfSeqDefEQ {
	\schemaVar \term int from, to;
        \schemaVar \term Seq EQ;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

   
        \assumes(seqDef{uSub;} (from, to, t) = EQ ==>)
	\find(seqLen(EQ))
        
	\replacewith(\if(from <= to)\then((to - from))\else(0))
                     
      	\heuristics(simplify_enlarging)
    };

    seqDef_split {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))
        \varcond ( \notFreeIn(uSub1, from), 
                \notFreeIn(uSub1, idx),
                \notFreeIn(uSub1, to),
                \notFreeIn(uSub, from), 
                \notFreeIn(uSub, idx),
                \notFreeIn(uSub, to),
                \notFreeIn(uSub1, t) )
        \replacewith(\if(from<=idx & idx<=to)
                    \then(seqConcat(seqDef{uSub;}(from, idx, t), seqDef{uSub1;}(idx,to,{\subst uSub; uSub1}t)))
                    \else(seqDef{uSub;}(from, to, t)))
    };


    seqDef_induction_upper {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))
        \varcond ( \notFreeIn(uSub, from), 
                \notFreeIn(uSub, to))
        \replacewith(seqConcat(seqDef{uSub;} (from, to-1, t), \if(from<to)\then(seqSingleton({\subst uSub; (to-1)}t))\else(seqEmpty)))
    };

    seqDef_induction_upper_concrete {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, 1+to, t))
        \varcond ( \notFreeIn(uSub, from), 
                \notFreeIn(uSub, to))
        \replacewith(seqConcat(seqDef{uSub;} (from, to, t), \if(from<=to)\then(seqSingleton({\subst uSub; (to)}t))\else(seqEmpty)))
        \heuristics(simplify)
    };

    seqDef_induction_lower {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))
        \varcond ( \notFreeIn(uSub, from), 
                \notFreeIn(uSub, to))
        \replacewith(seqConcat(\if(from<to)\then(seqSingleton({\subst uSub; (from)}t))\else(seqEmpty), seqDef{uSub;} (from+1, to, t)))
    };

    seqDef_induction_lower_concrete {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (-1+from, to, t))
        \varcond ( \notFreeIn(uSub, from), 
                \notFreeIn(uSub, to))
        \replacewith(seqConcat(\if(-1+from<to)\then(seqSingleton({\subst uSub; (-1+from)}t))\else(seqEmpty), seqDef{uSub;} (from, to, t)))
        \heuristics(simplify)
    };

    seqDef_split_in_three {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, to, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, idx), 
                \notFreeIn(uSub1, t),
                \notFreeIn(uSub1, idx),
                \notFreeIn(uSub, from),
                \notFreeIn(uSub1, to))
        "Precondition": \add(==> (from<=idx & idx<to));
        "Splitted SeqDef": \replacewith(seqConcat(seqDef{uSub;} (from, idx, t),
                                    seqConcat(seqSingleton({\subst uSub;  idx} t),
                                    seqDef{uSub1;} (idx+1, to, {\subst uSub; uSub1}t))))
    };

    seqDef_empty {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, idx, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, from),
                \notFreeIn(uSub, idx))
        "Precondition": \add(==> idx<=from);
        "Empty SeqDef": \replacewith(seqEmpty)
    };

    seqDef_one_summand {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (from, idx, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, from),
                \notFreeIn(uSub, idx))
        \replacewith(\if(from+1=idx)\then(seqSingleton({\subst uSub;  from} t))\else(seqDef{uSub;} (from, idx, t)))
    };

    seqDef_empty_concrete1 {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(==>seqDef{uSub;} ( Z(iz),  Z(jz), t)=seqEmpty)
        \varcond (\notFreeIn(uSub, iz),
                \notFreeIn(uSub, jz))
        \add(==> Z(jz)<=Z(iz))
        \heuristics(simplify)
    };

    seqDef_empty_concrete2 {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} ( Z(iz), Z(neglit(jz)), t))
        \varcond (\notFreeIn(uSub, iz),
                \notFreeIn(uSub, jz))
        \replacewith(\if(Z(neglit(jz))<=Z(iz))\then(seqEmpty)\else(seqDef{uSub;} ( Z(iz), Z(neglit(jz)), t)))
        \heuristics(simplify)
    };

    seqDef_lower_equals_upper {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;} (idx, idx, t))\sameUpdateLevel
        \varcond (\notFreeIn(uSub, idx))
        \replacewith(seqEmpty)
        \heuristics(simplify)
    };

}
