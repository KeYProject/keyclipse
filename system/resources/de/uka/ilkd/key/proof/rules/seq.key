\sorts {
    Seq;
}


\functions {
    //getters
    alpha alpha::seqGet(Seq, int);
    int seqLen(Seq);
    
    //constructors
    Seq seqEmpty;
    Seq seqSingleton(any);
    Seq seqConcat(Seq, Seq);
    Seq seqSub(Seq, int, int);
    Seq seqReverse(Seq);
}


\rules {

    //--------------------------------------------------------------------------
    //axioms
    //--------------------------------------------------------------------------
    
    getOfSeqSingleton {
	\schemaVar \term alpha x;
	\schemaVar \term int idx;	
   
	\find(beta::seqGet(seqSingleton(x), idx))
	
	\replacewith(\if(idx = 0)
                     \then((beta)x)
                     \else(beta::seqGet(seqEmpty, idx)))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqConcat {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term int idx;
   
	\find(beta::seqGet(seqConcat(seq, seq2), idx))
	
	\replacewith(\if(idx < seqLen(seq))
                     \then(beta::seqGet(seq, idx))
                     \else(beta::seqGet(seq2, idx - seqLen(seq))))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int idx, from, to;
   
	\find(beta::seqGet(seqSub(seq, from, to), idx))
	
	\replacewith(beta::seqGet(seq, idx + from))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqReverse {
        \schemaVar \term Seq seq;
	\schemaVar \term int idx;        
   
	\find(beta::seqGet(seqReverse(seq), idx))
	
	\replacewith(beta::seqGet(seq, seqLen(seq) - 1 - idx))
                     
      	\heuristics(simplify)
    };
    
    
    lenNonNegative {
	\schemaVar \term Seq seq;
   
	\find(seqLen(seq))
	
	\add(0 <= seqLen(seq) ==>)
                     
      	\heuristics(inReachableStateImplication)
    };    
    
    
    lenOfSeqEmpty {
	\find(seqLen(seqEmpty))
	
	\replacewith(0)
                     
      	\heuristics(simplify)
    };    
    
    
    lenOfSeqSingleton {
	\schemaVar \term alpha x;
   
	\find(seqLen(seqSingleton(x)))
	
	\replacewith(1)
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqConcat {
	\schemaVar \term Seq seq, seq2;
   
	\find(seqLen(seqConcat(seq, seq2)))
	
	\replacewith(seqLen(seq) + seqLen(seq2))
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqSub {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
   
	\find(seqLen(seqSub(seq, from, to)))
	
	\replacewith(\if(from <= to)\then(to - from)\else(0))
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqReverse {
	\schemaVar \term Seq seq;
   
	\find(seqLen(seqReverse(seq)))
	
	\replacewith(seqLen(seq))
                     
      	\heuristics(simplify)    
    };
    
    
    equalityToSeqGetAndSeqLen {
    	\schemaVar \term Seq s, s2;
	\schemaVar \variables int iv;    	
    	
    	\find(s = s2)
	\varcond(\notFreeIn(iv, s, s2))
	
    	\replacewith(seqLen(s) = seqLen(s2) 
    	             & \forall iv; (0 <= iv & iv < seqLen(s) -> any::seqGet(s, iv) = any::seqGet(s2, iv)))
    };    
    
    
    equalityToSeqGetAndSeqLenSucc {
    	\schemaVar \term Seq s, s2;
	\schemaVar \variables int iv;    	
    	
    	\find(==> s = s2)
	\varcond(\notFreeIn(iv, s, s2))
	
    	\replacewith(==> seqLen(s) = seqLen(s2) 
    	                 & \forall iv; (0 <= iv & iv < seqLen(s) -> any::seqGet(s, iv) = any::seqGet(s2, iv)))
    	
    	\heuristics(simplify)
    };

    
    

    //--------------------------------------------------------------------------
    //EQ versions of axioms (these are lemmata)
    //--------------------------------------------------------------------------
    
    getOfSeqSingletonEQ {
	\schemaVar \term alpha x;
	\schemaVar \term int idx;
  	\schemaVar \skolemTerm beta unspec;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSingleton(x) = EQ ==>)   
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel	
	\varcond(\new(unspec, \dependingOn(idx)))
	
	\replacewith(\if(idx = 0)
                     \then((beta)x)
                     \else(unspec))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqConcatEQ {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term int idx;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqConcat(seq, seq2) = EQ ==>)      
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(\if(idx < seqLen(seq))
                     \then(beta::seqGet(seq, idx))
                     \else(beta::seqGet(seq2, idx - seqLen(seq))))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqSubEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term int idx, from, to;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSub(seq, from, to) = EQ ==>)
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel
	
	\replacewith(beta::seqGet(seq, idx + from))
                     
      	\heuristics(simplify)
    };
    
    
    getOfSeqReverseEQ {
        \schemaVar \term Seq seq;
	\schemaVar \term int idx;        
	\schemaVar \term Seq EQ;        
   
        \assumes(seqReverse(seq) = EQ ==>)   
	\find(beta::seqGet(EQ, idx))
        \sameUpdateLevel	
	
	\replacewith(beta::seqGet(seq, seqLen(seq) - 1 - idx))
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqEmptyEQ {
	\schemaVar \term alpha x;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqEmpty = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel	
	
	\replacewith(0)

      	\heuristics(simplify)
    };    
    
    
    lenOfSeqSingletonEQ {
	\schemaVar \term alpha x;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqSingleton(x) = EQ ==>)   
	\find(seqLen(EQ))
        \sameUpdateLevel
	
	\replacewith(1)
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqConcatEQ {
	\schemaVar \term Seq seq, seq2;
	\schemaVar \term Seq EQ;	
   
        \assumes(seqConcat(seq, seq2) = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel
	
	\replacewith(seqLen(seq) + seqLen(seq2))
                     
      	\heuristics(simplify)
    };
    
    
    lenOfSeqSubEQ {
	\schemaVar \term Seq seq;
	\schemaVar \term int from, to;
	\schemaVar \term Seq EQ;
   
        \assumes(seqSub(seq, from, to) = EQ ==>)
	\find(seqLen(EQ))
        \sameUpdateLevel	
	
	\replacewith(to - from)
                     
      	\heuristics(simplify)
    };    
    
    
    
    //--------------------------------------------------------------------------
    //lemmata for seqEmpty
    //--------------------------------------------------------------------------
    
    concatWithEmpty1 {
        \schemaVar \term Seq seq;
        
        \find(seqConcat(seq, seqEmpty))
        
        \replacewith(seq)
        
        \heuristics(concrete)
    };
    
    
    concatWithEmpty2 {
        \schemaVar \term Seq seq;
        
        \find(seqConcat(seqEmpty, seq))
        
        \replacewith(seq)
        
        \heuristics(concrete)
    };
    
    
    
    //--------------------------------------------------------------------------
    //lemma for casts
    //--------------------------------------------------------------------------
    
    castedGetAny {
	\schemaVar \term Seq seq;    
	\schemaVar \term int idx;	
   
	\find((beta)any::seqGet(seq, idx))
	
	\replacewith(beta::seqGet(seq, idx))
                     
      	\heuristics(simplify)
    };    
}
