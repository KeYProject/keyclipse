<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
<comment>
  These properties define the help comments which are to be displayed
  in the taclet option dialog
</comment>
<entry key="assertions">Treatment of Java assertion statements

Java assertions can be handled in three different ways in KeY:

* If switched off, assert statements are skipped.

* If switched on, assertions are treated like Java would treat them:
  Asserted Statements are evaluated and an AssertionException is 
  raised if they turn out to be false.

* If set to safe, the following proof obligations have to be shown:
  - The program with assertions removed must fulfill the specification
  - The asserted conditions must hold (without throwing an exception,
    and with termination)
  - The assertions do not have side effects influencing the post
    conditions.
  Proofs with this option are typically harder.
</entry>

<entry key="JavaCard">
JavaCard is a dialect of Java designed for the use in SmartCards.  It
lacks floating point operations and concurrency, but provides stronger
object persistence guarantees.

There are two values for this option jcOn and jcOff. Switching
on or off all taclets axiomatising JavaCard specific features like transac-
tion.
</entry>

<entry key="initialisation">
Specifies whether static (class loading) initialization should be
taken in consideration.

Both specifications and proof obligations become significantly more
difficult since class loading may take place at many places.
</entry>

<entry key="intRules">
This option controls how integer numbers are modelled.

* Java semantics treat integers the same way java would treat them.
  The different integer types operate within their respective value
  ranges. The bitvector arithmetic is modelled in KeY using modulo
  expressions. This is sound and complete (TODO! IS IT??). Proof
  obligations tend to get more complex with this setting.

* Arithmetic without overflow checking treats integers as pure
  mathematical objects. The proof obligations are often easier to
  discharge. However, the model does not allow the verification of all
  properties which hold with Java semantics. Moreover, it allows the
  verification of properties which do not hold on Java's actual
  semantics.

* Arithmetic with overflow checking also treats integers as
  mathematical objects, but ensures that no overflow occurs.  While
  this model also has a completeness gap, it prevents the proof of
  incorrect properties.
</entry>

<entry key="programRules">
Rules dealing Java language constructs can be turned off by setting
this to None.
</entry>

<entry key="runtimeExceptions">Treatment of runtime exceptions

* If set to allow, runtime exceptions are treated as specified in the
  Java language specification.

* If set to ban, any occurrence of a runtime exception is considered
  an irrecoverable program failure.
</entry>

<entry key="modelFields">Rules for model field representation clauses

JML model fields are given a semantics by represents clauses. This
switch sets how the rules handle these clauses.

* If set to treatAsAxiom, the representation is seen as an axiom,
  satisfiability will not be checked. This may introduce inconsistent
  specifications, for example the following contradictory JML clause
  will not be rejected:
     //@ represents modelField == modelField + 1;
  
* If set to showSatisfiability, for every expansion of the represents
  clause, it must be shown that the definition is
  satisfiable. Cross-definition inconsistencies can still be
  formulated, however:
     //@ represents modelField1 == modelField2;
     //@ represents modelField2 == modelField1 + 1;
</entry>

<entry key="Strings">
Loading rules dealing with Strings (charLists) can be disabled.
</entry>

<entry key="bigint">
Loading program rules dealing with JML's \bigint datatype can be disabled.
</entry>

<entry key="sequences">
Loading rules dealing with sequences can be disabled.
</entry>

<entry key="reach">
Loading rules dealing with reachability can be disabled.
</entry>

<entry key="integerSimplificationRules">Loading less commonly used rules for (mathematical) integers, such as rules for bounded sums and products, modulo, or polynomials, can be disabled. If they are loaded, their application in the strategy can still be controlled as usual.

This option is experimental. Depending of your understanding of 'less common', you may experience incompleteness. Doing proofs with Java int semantics will not work, definitely.

Not to be confused with intRules, which controls the semantics of the Java type int.
</entry>

<entry key="optimisedSelectRules">
The optimised select rules can be turned off by setting this option to off.

The non-optimised rules use inplace rewriting for the evaluation of
select-terms. This may lead to heap-terms growing exponentielly in
the number of anons/stores to be evaluated. However, in some rar
cases the usage of the non-optimised rules may lead more
human-readable sequents.

The optimised rules pullout select-terms before they evaluate them.
Because other occurences of the same select-term are replaced by the
skolem constant introduced by the pullout-rule (application of
equalities), each select-term has to be evaluated only once.
Intelligent hiding of no longer needed auxiliary equations holds the
sequent human-readable and increases performance. The result of the
evaluation of a select-term is stored such that it can be reapplied
immediately if the same select-term occurs again.
</entry>

</properties>

