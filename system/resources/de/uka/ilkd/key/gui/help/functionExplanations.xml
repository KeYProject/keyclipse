<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    
<comment>
    Put descriptions for JavaDL function symbols in here.
</comment>

<entry key="field/arr">tbd</entry>
<entry key="field/java.lang.Object::&lt;transient&gt;">tbd</entry>
<entry key="field/java.lang.Object::&lt;transactionConditionallyUpdated&gt;">tbd</entry>
<entry key="field/java.lang.Object::&lt;created&gt;">tbd</entry>
<entry key="field/java.lang.Object::&lt;initialized&gt;">tbd</entry>
<entry key="field/alpha::&lt;classPrepared&gt;">tbd</entry>
<entry key="field/alpha::&lt;classInitialized&gt;">tbd</entry>
<entry key="field/alpha::&lt;classInitializationInProgress&gt;">tbd</entry>
<entry key="field/alpha::&lt;classErroneous&gt;">tbd</entry>

<entry key="heap">
This program variable holds to the current heap state. Its type is Heap.
</entry>

<entry key="heap/wellformed">
This predicate takes an argument of type Heap. It is true if the following conditions hold for its the argument:
1. Every location contains a reference to a created (in this heap) object or null.
2. Every location set stored on the heap contains only created objects.
3. Every location belonging to a declared Java field holds a value compatible with its type.
4. Only finitely many objects are created on the heap.
</entry>

<entry key="heap/store">tbd</entry>
<entry key="heap/create">tbd</entry>
<entry key="heap/anon">tbd</entry>
<entry key="heap/memset">tbd</entry>
    
<entry key="locset/empty">The unique location set, which does not contain any elements.</entry>
<entry key="locset/allLocs">The unique location set containing all locations, i.e. elementOf(o, f, allLocs) will always return true for arbitrary values f &#8712; Field and o &#8712; Object.</entry>
<entry key="locset/singleton">Converts a single location to a locations set with one element.</entry>
<entry key="locset/union">Union between location sets.</entry>
<entry key="locset/intersect">Intersection between location sets.</entry>
<entry key="locset/setMinus">Realizes relative complement between locations sets. It takes as arguments two location sets and returns another location set which contains all elements from the first argument except those that are elements of the second argument.</entry>
<entry key="locset/infiniteUnion">Takes as argument a term of type LocSet, which may contain a free variable. The term represents a family of locations sets, which is parameterized by the unbound variable. The returned location set is the union over all members of the parameterized family.</entry>
<entry key="locset/allFields">tbd</entry>
<entry key="locset/allObjects">tbd</entry>
<entry key="locset/arrayRange">tbd</entry>
<entry key="locset/freshLocs">tbd</entry>
<entry key="locset/allElementsOfArray">tbd</entry>
<entry key="locset/allElementsOfArrayLocsets">tbd</entry>
<entry key="locset/elementOf">tbd</entry>
<entry key="locset/subset">tbd</entry>
<entry key="locset/disjoint">tbd</entry>
<entry key="locset/createdInHeap">tbd</entry>

<entry key="map/mapGet">Retrieve the mapping value of a key.</entry>
<entry key="map/mapUndef">A unique value, which is returned by mapGet in case no mapping value is declared for the specified key.</entry>
<entry key="map/mapForeach">Generalized quantifier for maps. This is a generic constructor for maps.</entry>
<entry key="map/mapEmpty">The empty map, which does not contain any entries.</entry>
<entry key="map/mapSingleton">A map, which contains only one entry.</entry>
<entry key="map/mapOverride">Takes as arguments two maps and creates a new map from their entries. In case their domains overlap, the second map is favored over the first one for keys from the intersection.</entry>
<entry key="map/seq2map">Converts a sequence to a map. The map domain consists of exactly those integers, which are inside the sequence bounds.</entry>
<entry key="map/mapUpdate">Adds an entry to a map or overwrites an existing one.</entry>
<entry key="map/mapRemove">Removes an entry from a map.</entry>
<entry key="map/mapSize">Returns the number of entries of a map.</entry>
<entry key="map/isFinite">Returns true iff the specified map contains a finite amount of entries.</entry>
    
<entry key="seq/seqLen">Return the length of a sequence.</entry>
<entry key="seq/seqGet">Return the element at a position within a sequence. The type read from the sequence is part of the function name.</entry>
<entry key="seq/seqIndexOf">Return the first index in a sequence that holds a value.</entry>
<entry key="seq/seqGetOutside">The underspecified error value if a sequence is accessed outside its idnex range.</entry>
<entry key="seq/seqEmpty">The empty sequence.</entry>
<entry key="seq/seqSingleton">A singleton sequence that has the argument as only entry.</entry>
<entry key="seq/seqConcat">Concatenates two sequences.</entry>
<entry key="seq/seqSub">Takes a subsequence from a sequence. 
The first argument is the original sequence,
the second is the first index to consider (inclusive) and
the third is the last index to consider (!exclusive!).
</entry>
<entry key="seq/seqReverse">Reverses a sequence. The result has the same entries as the argument but in reverse order.</entry>
<entry key="seq/seqDef">This function binds an integer variable and evaluates an expression over this variable for a range of values to obtain the entries of a sequence.
    
The sequence 
  seqDef{int i;}(-2, 3, i*i)
has, for instance, the entries
  [ 4, 1, 0, 1, 4 ].

The first and second argument give the range over which the variable goes. Again, the right-hand bound is exclusive.

seqDef is related to the lambda operator in lambda calculus.
</entry>

<entry key="seq/seqSwap">Takes a sequence and two indices. The elements at the specified indices are exchanged in the resulting sequence. In case one of the indices is out of bounds, the sequence is left unchanged.</entry>
<entry key="seq/seqRemove">Takes a sequence and removes the element at the specified index. In case the index is out of bounds, the sequence is left unchanged.</entry>
<entry key="seq/seqNPermInv">Takes a sequence of naturals (zero included) and treats it as a permutation. The resulting sequence is the inverse permutation of the original one.</entry>
<entry key="seq/array2seq">Convert a Java array to a JavaDL sequence.</entry>

<entry key="pair/pair">Return the (unique) ordered pair of two specified elements.</entry>
<entry key="pair/first">Return the first element of an ordered pair.</entry>
<entry key="pair/second">Return the second element of an ordered pair.</entry>

<entry key="exactInstance">A boolean function which is true iff the dynamic type of its argument is precisely the type which is part of the function name.</entry>

<entry key="instance">A boolean function which is true iff the dynamic type of its argument is a subtype of the type which is part of the function name.</entry>

<entry key="cast">
cast
</entry>

<entry key="null">tbd</entry>

<entry key="TODO">dd
<![CDATA[TRUE
FALSE
    select/store
    alpha alpha::select(Heap, Object, Field);
    
    //array length
    int length(Object);

    arrayStoreValid(any, any);
    nonNull(Heap,Object,int);
                            java...
    inInt(int);
]]>

</entry>
</properties>

