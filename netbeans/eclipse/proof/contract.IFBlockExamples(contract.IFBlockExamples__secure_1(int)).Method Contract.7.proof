\settings {
"#Proof-Settings-Config-File
#Tue May 21 14:55:33 CEST 2013
[StrategyProperty]VBT_PHASE=VBT_SYM_EX
[SMTSettings]useUninterpretedMultiplication=true
[SMTSettings]SelectedTaclets=
[StrategyProperty]METHOD_OPTIONS_KEY=METHOD_CONTRACT
[StrategyProperty]USER_TACLETS_OPTIONS_KEY3=USER_TACLETS_OFF
[StrategyProperty]LOOP_OPTIONS_KEY=LOOP_INVARIANT
[StrategyProperty]USER_TACLETS_OPTIONS_KEY2=USER_TACLETS_OFF
[StrategyProperty]USER_TACLETS_OPTIONS_KEY1=USER_TACLETS_OFF
[StrategyProperty]QUANTIFIERS_OPTIONS_KEY=QUANTIFIERS_NON_SPLITTING_WITH_PROGS
[StrategyProperty]NON_LIN_ARITH_OPTIONS_KEY=NON_LIN_ARITH_NONE
[SMTSettings]instantiateHierarchyAssumptions=true
[StrategyProperty]AUTO_INDUCTION_OPTIONS_KEY=AUTO_INDUCTION_OFF
[StrategyProperty]RETREAT_MODE_OPTIONS_KEY=RETREAT_MODE_NONE
[StrategyProperty]DEP_OPTIONS_KEY=DEP_ON
[StrategyProperty]BLOCK_OPTIONS_KEY=BLOCK_CONTRACT
[StrategyProperty]QUERY_NEW_OPTIONS_KEY=QUERY_OFF
[Strategy]Timeout=-1
[Strategy]MaximumNumberOfAutomaticApplications=10000
[SMTSettings]integersMaximum=2147483645
[Choice]DefaultChoices=Strings-Strings\\:on , JavaCard-JavaCard\\:on , reach-reach\\:on , assertions-assertions\\:on , bigint-bigint\\:on , intRules-intRules\\:arithmeticSemanticsIgnoringOF , programRules-programRules\\:Java , initialisation-initialisation\\:disableStaticInitialisation , modelFields-modelFields\\:treatAsAxiom , sequences-sequences\\:on , runtimeExceptions-runtimeExceptions\\:allow , integerSimplificationRules-integerSimplificationRules\\:full
[SMTSettings]useConstantsForBigOrSmallIntegers=true
[StrategyProperty]STOPMODE_OPTIONS_KEY=STOPMODE_DEFAULT
[StrategyProperty]QUERYAXIOM_OPTIONS_KEY=QUERYAXIOM_ON
[StrategyProperty]INF_FLOW_CHECK_PROPERTY=INF_FLOW_CHECK_TRUE
[SMTSettings]maxGenericSorts=2
[SMTSettings]integersMinimum=-2147483645
[SMTSettings]UseBuiltUniqueness=false
[SMTSettings]explicitTypeHierarchy=false
[Strategy]ActiveStrategy=JavaCardDLStrategy
[StrategyProperty]SPLITTING_OPTIONS_KEY=SPLITTING_DELAYED
"
}

\javaSource "../../../examples/information_flow/collection";



\sorts{
LocSet;
numbers;
Update;
boolean;
Field;
Formula;
java.lang.Exception\extends java.lang.Throwable;
int;
contract.IFBlockExamples\extends java.lang.Object;
Heap;
}

\predicates{
EXECUTION_OF_BLOCK_at_line_17_in_secure_1_16885809_WITH_PRE(Heap,contract.IFBlockExamples,int,int,java.lang.Exception,Heap,contract.IFBlockExamples,int,int,java.lang.Exception);
RELATED_BY_BLOCK_at_line_17_in_secure_1_16885809(Heap,contract.IFBlockExamples,int,int,java.lang.Exception,Heap,contract.IFBlockExamples,int,int,java.lang.Exception);
EXECUTION_OF_secure_1_16885809_WITH_PRE(Heap,contract.IFBlockExamples,int,int,java.lang.Exception,int,Heap,contract.IFBlockExamples,int,int,java.lang.Exception,int);
}

\functions{
int anon_l1_B_0;
Heap heap_After_BLOCK_B_0;
Heap anon_heap_B_0;
int anon_l1_A_0;
Heap heap_After_BLOCK_A_0;
Heap anon(Heap,LocSet,Heap);
LocSet empty;
Heap store(Heap,java.lang.Object,Field,any);
Heap anon_heap_A_0;
int add(int,int);
numbers 1(numbers);
int Z(numbers);
numbers 8(numbers);
numbers #;
Heap heap_After_BLOCK;
Formula java.lang.Object::<inv>(Heap,java.lang.Object);
Formula wellFormed(Heap);
Formula inInt(int);
boolean contract.IFBlockExamples::exactInstance(any);
boolean TRUE;
boolean boolean::select(Heap,java.lang.Object,Field);
Field java.lang.Object::<created>;
Null null;
int int::select(Heap,java.lang.Object,Field);
Field contract.IFBlockExamples::$low;
int mbyAtPreAtPost_B_0;
int mbyAtPreAtPre_B_0;
int mbyAtPreAtPost_A_0;
int mbyAtPreAtPre_A_0;
}

\programVariables{
int l1_After_B_0;
java.lang.Exception exc_1_After_BLOCK_B_0;
int result_B_0;
int result_After_BLOCK_B_0;
contract.IFBlockExamples selfAtPre_0_After_BLOCK_B_0;
int l1_Before_B_0;
java.lang.Exception exc_1_B_0;
int l1_After_A_0;
java.lang.Exception exc_1_After_BLOCK_A_0;
int result_A_0;
int result_After_BLOCK_A_0;
contract.IFBlockExamples selfAtPre_0_After_BLOCK_A_0;
int l1_Before_A_0;
java.lang.Exception exc_1_A_0;
int l1_B_0;
int l2_B_0;
int l1_A_0;
int l2_A_0;
int l1;
java.lang.Exception exc_1_After_BLOCK_B;
int result_After_BLOCK_B;
int l1_After_B;
contract.IFBlockExamples selfAtPre_0_After_BLOCK_B;
Heap heap_After_BLOCK_B;
java.lang.Exception exc_1_B;
int result_B;
int l1_Before_B;
contract.IFBlockExamples selfAtPre_0_B_0;
Heap heap_Before_BLOCK_B;
java.lang.Exception exc_1_After_BLOCK_A;
int result_After_BLOCK_A;
int l1_After_A;
contract.IFBlockExamples selfAtPre_0_After_BLOCK_A;
Heap heap_After_BLOCK_A;
java.lang.Exception exc_1_A;
int result_A;
int l1_Before_A;
contract.IFBlockExamples selfAtPre_0_A_0;
Heap heap_Before_BLOCK_A;
java.lang.Exception exc_1_After_BLOCK;
int result_After_BLOCK;
int l1_After;
contract.IFBlockExamples selfAtPre_0_After_BLOCK;
java.lang.Exception exc_1;
int result;
int l1_Before;
Heap heap_Before_BLOCK;
Heap heapAtPost_0;
java.lang.Exception excAtPre_0;
java.lang.Exception excAtPost_0;
int resultAtPre;
int resultAtPost;
contract.IFBlockExamples selfAtPost_0;
int _lAtPre;
Heap heapAtPre_0;
int lAtPost;
int lAtPre;
Heap heap;
contract.IFBlockExamples selfAtPre_0;
java.lang.Exception excAtPost_0_B;
int resultAtPost_B;
int lAtPost_B;
contract.IFBlockExamples selfAtPost_0_B;
Heap heapAtPost_0_B;
java.lang.Exception excAtPre_0_B;
int resultAtPre_B;
int lAtPre_B;
contract.IFBlockExamples selfAtPre_0_B;
Heap heapAtPre_0_B;
java.lang.Exception excAtPost_0_A;
int resultAtPost_A;
int lAtPost_A;
contract.IFBlockExamples selfAtPost_0_A;
Heap heapAtPost_0_A;
java.lang.Exception excAtPre_0_A;
int resultAtPre_A;
int lAtPre_A;
contract.IFBlockExamples selfAtPre_0_A;
Heap heapAtPre_0_A;
}

\rules{

Class_invariant_axiom_for_contract_IFBlockExamples {
  \schemaVar \term contract.IFBlockExamples sv_self;
  \schemaVar \term Heap sv_heap;
  
  \assumes (contract.IFBlockExamples::exactInstance(sv_self) = TRUE ==>  )
  \find ( java.lang.Object::<inv>(sv_heap, sv_self) )
  \sameUpdateLevel
  \replacewith ( true )
  \heuristics ( classAxiom )
};

Split_post_0 {
  
  \find (
        int::select(heapAtPost_0_A,
                    selfAtPost_0_A,
                    contract.IFBlockExamples::$low)
      = int::select(heapAtPost_0_B,
                    selfAtPost_0_B,
                    contract.IFBlockExamples::$low)
    & resultAtPost_A = resultAtPost_B
  )
  \succedentPolarity
  \replacewith (
      int::select(heapAtPost_0_A,
                  selfAtPost_0_A,
                  contract.IFBlockExamples::$low)
    = int::select(heapAtPost_0_B,
                  selfAtPost_0_B,
                  contract.IFBlockExamples::$low)
  );
  \replacewith ( resultAtPost_A = resultAtPost_B )
  \heuristics ( information_flow_contract_appl )
};

Remove_post_0 {
  
  \find (
        int::select(heapAtPost_0_A,
                    selfAtPost_0_A,
                    contract.IFBlockExamples::$low)
      = int::select(heapAtPost_0_B,
                    selfAtPost_0_B,
                    contract.IFBlockExamples::$low)
    & resultAtPost_A = resultAtPost_B
  )
  \succedentPolarity
  \replacewith ( false )
  \heuristics ( information_flow_contract_appl )
};

Use_information_flow_contract_for_Block_Contract_17_secure_1_16885809 {
  \schemaVar \term contract.IFBlockExamples assumes_selfAtPre_0_After_BLOCK#11;
  \schemaVar \term contract.IFBlockExamples assumes_selfAtPre_0#10;
  \schemaVar \term Heap find_heap_Before_BLOCK#8;
  \schemaVar \term int assumes_l1_Before#12;
  \schemaVar \term Heap find_heap_After_BLOCK#9;
  \schemaVar \term contract.IFBlockExamples find_selfAtPre_0_After_BLOCK#1;
  \schemaVar \term Heap assumes_heap_Before_BLOCK#18;
  \schemaVar \term int assumes_result_After_BLOCK#15;
  \schemaVar \term java.lang.Exception assumes_exc_1#16;
  \schemaVar \term java.lang.Exception find_exc_1#6;
  \schemaVar \term Heap assumes_heap_After_BLOCK#19;
  \schemaVar \term java.lang.Exception find_exc_1_After_BLOCK#7;
  \schemaVar \term int find_result#4;
  \schemaVar \term contract.IFBlockExamples find_selfAtPre_0#0;
  \schemaVar \term int find_l1_After#3;
  \schemaVar \term java.lang.Exception assumes_exc_1_After_BLOCK#17;
  \schemaVar \term int assumes_result#14;
  \schemaVar \term int find_l1_Before#2;
  \schemaVar \term int assumes_l1_After#13;
  \schemaVar \term int find_result_After_BLOCK#5;
  
  \assumes ( RELATED_BY_BLOCK_at_line_17_in_secure_1_16885809(assumes_heap_Before_BLOCK#18,
                                                              assumes_selfAtPre_0#10,
                                                              assumes_l1_Before#12,
                                                              assumes_result#14,
                                                              assumes_exc_1#16,
                                                              assumes_heap_After_BLOCK#19,
                                                              assumes_selfAtPre_0_After_BLOCK#11,
                                                              assumes_l1_After#13,
                                                              assumes_result_After_BLOCK#15,
                                                              assumes_exc_1_After_BLOCK#17)
            ==>
             
  )
  \find (
    RELATED_BY_BLOCK_at_line_17_in_secure_1_16885809(find_heap_Before_BLOCK#8,
                                                     find_selfAtPre_0#0,
                                                     find_l1_Before#2,
                                                     find_result#4,
                                                     find_exc_1#6,
                                                     find_heap_After_BLOCK#9,
                                                     find_selfAtPre_0_After_BLOCK#1,
                                                     find_l1_After#3,
                                                     find_result_After_BLOCK#5,
                                                     find_exc_1_After_BLOCK#7)
  )
  \antecedentPolarity
  \replacewith (
    RELATED_BY_BLOCK_at_line_17_in_secure_1_16885809(find_heap_Before_BLOCK#8,
                                                     find_selfAtPre_0#0,
                                                     find_l1_Before#2,
                                                     find_result#4,
                                                     find_exc_1#6,
                                                     find_heap_After_BLOCK#9,
                                                     find_selfAtPre_0_After_BLOCK#1,
                                                     find_l1_After#3,
                                                     find_result_After_BLOCK#5,
                                                     find_exc_1_After_BLOCK#7)
  )
  \add (    find_l1_Before#2 = assumes_l1_Before#12
         -> find_l1_After#3 = assumes_l1_After#13
        ==>
         
  )
  \heuristics ( information_flow_contract_appl )
};

unfold_computed_formula_0_of_Block_Contract_17_secure_1_16885809 {
  
  \find (
      EXECUTION_OF_BLOCK_at_line_17_in_secure_1_16885809_WITH_PRE(heap_Before_BLOCK_A,
                                                                  selfAtPre_0_A_0,
                                                                  l1_Before_A,
                                                                  result_A,
                                                                  exc_1_A,
                                                                  heap_After_BLOCK_A,
                                                                  selfAtPre_0_After_BLOCK_A,
                                                                  l1_After_A,
                                                                  result_After_BLOCK_A,
                                                                  exc_1_After_BLOCK_A)
    & EXECUTION_OF_BLOCK_at_line_17_in_secure_1_16885809_WITH_PRE(heap_Before_BLOCK_B,
                                                                  selfAtPre_0_B_0,
                                                                  l1_Before_B,
                                                                  result_B,
                                                                  exc_1_B,
                                                                  heap_After_BLOCK_B,
                                                                  selfAtPre_0_After_BLOCK_B,
                                                                  l1_After_B,
                                                                  result_After_BLOCK_B,
                                                                  exc_1_After_BLOCK_B)
  )
  \antecedentPolarity
  \replacewith (
        {heap:=heap_Before_BLOCK_A}
          (  wellFormed(heap_Before_BLOCK_A)
           &   boolean::select(heap_Before_BLOCK_A,
                               selfAtPre_0_A_0,
                               java.lang.Object::<created>)
             = TRUE
           & contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE
           & !l2_A_0 = Z(8(#))
           & !{heap:=heap_Before_BLOCK_A || l1_A_0:=add(Z(1(#)), l1_Before_A)}
                !(  selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0
                  & l1_After_A = l1_A_0
                  & result_After_BLOCK_A = result_A
                  & exc_1_After_BLOCK_A = exc_1_A
                  & heap_After_BLOCK_A = heap)
           & !selfAtPre_0_A_0 = null)
      & {heap:=heap_Before_BLOCK_B}
          (  wellFormed(heap_Before_BLOCK_B)
           &   boolean::select(heap_Before_BLOCK_B,
                               selfAtPre_0_B_0,
                               java.lang.Object::<created>)
             = TRUE
           & contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE
           & !l2_B_0 = Z(8(#))
           & !{heap:=heap_Before_BLOCK_B || l1_B_0:=add(Z(1(#)), l1_Before_B)}
                !(  selfAtPre_0_After_BLOCK_B = selfAtPre_0_B_0
                  & l1_After_B = l1_B_0
                  & result_After_BLOCK_B = result_B
                  & exc_1_After_BLOCK_B = exc_1_B
                  & heap_After_BLOCK_B = heap)
           & !selfAtPre_0_B_0 = null)
    | {heap:=heap_Before_BLOCK_A}
        (  wellFormed(heap_Before_BLOCK_A)
         &   boolean::select(heap_Before_BLOCK_A,
                             selfAtPre_0_A_0,
                             java.lang.Object::<created>)
           = TRUE
         & contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE
         & !l2_A_0 = Z(8(#))
         & !{heap:=heap_Before_BLOCK_A || l1_A_0:=add(Z(1(#)), l1_Before_A)}
              !(  selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0
                & l1_After_A = l1_A_0
                & result_After_BLOCK_A = result_A
                & exc_1_After_BLOCK_A = exc_1_A
                & heap_After_BLOCK_A = heap)
         & !selfAtPre_0_A_0 = null)
    & {heap:=heap_Before_BLOCK_B}
        (  l2_B_0 = Z(8(#))
         & wellFormed(heap_Before_BLOCK_B)
         &   boolean::select(heap_Before_BLOCK_B,
                             selfAtPre_0_B_0,
                             java.lang.Object::<created>)
           = TRUE
         & contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE
         & !{heap:=heap_Before_BLOCK_B || l1_B_0:=add(Z(1(#)), l1_Before_B)}
              !(  selfAtPre_0_After_BLOCK_B = selfAtPre_0_B_0
                & l1_After_B = l1_B_0
                & result_After_BLOCK_B = result_B
                & exc_1_After_BLOCK_B = exc_1_B
                & heap_After_BLOCK_B = heap)
         & !selfAtPre_0_B_0 = null)
    | {heap:=heap_Before_BLOCK_A}
        (  l2_A_0 = Z(8(#))
         & wellFormed(heap_Before_BLOCK_A)
         &   boolean::select(heap_Before_BLOCK_A,
                             selfAtPre_0_A_0,
                             java.lang.Object::<created>)
           = TRUE
         & contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE
         & !{heap:=heap_Before_BLOCK_A || l1_A_0:=add(Z(1(#)), l1_Before_A)}
              !(  selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0
                & l1_After_A = l1_A_0
                & result_After_BLOCK_A = result_A
                & exc_1_After_BLOCK_A = exc_1_A
                & heap_After_BLOCK_A = heap)
         & !selfAtPre_0_A_0 = null)
    & {heap:=heap_Before_BLOCK_B}
        (  l2_B_0 = Z(8(#))
         & wellFormed(heap_Before_BLOCK_B)
         &   boolean::select(heap_Before_BLOCK_B,
                             selfAtPre_0_B_0,
                             java.lang.Object::<created>)
           = TRUE
         & contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE
         & !{heap:=heap_Before_BLOCK_B || l1_B_0:=add(Z(1(#)), l1_Before_B)}
              !(  selfAtPre_0_After_BLOCK_B = selfAtPre_0_B_0
                & l1_After_B = l1_B_0
                & result_After_BLOCK_B = result_B
                & exc_1_After_BLOCK_B = exc_1_B
                & heap_After_BLOCK_B = heap)
         & !selfAtPre_0_B_0 = null)
  )
  \heuristics ( concrete )
};

unfold_computed_formula_1_of_secure_1_16885809 {
  
  \find (
      EXECUTION_OF_secure_1_16885809_WITH_PRE(heapAtPre_0_A,
                                              selfAtPre_0_A,
                                              lAtPre_A,
                                              resultAtPre_A,
                                              excAtPre_0_A,
                                              mbyAtPreAtPre_A_0,
                                              heapAtPost_0_A,
                                              selfAtPost_0_A,
                                              lAtPost_A,
                                              resultAtPost_A,
                                              excAtPost_0_A,
                                              mbyAtPreAtPost_A_0)
    & EXECUTION_OF_secure_1_16885809_WITH_PRE(heapAtPre_0_B,
                                              selfAtPre_0_B,
                                              lAtPre_B,
                                              resultAtPre_B,
                                              excAtPre_0_B,
                                              mbyAtPreAtPre_B_0,
                                              heapAtPost_0_B,
                                              selfAtPost_0_B,
                                              lAtPost_B,
                                              resultAtPost_B,
                                              excAtPost_0_B,
                                              mbyAtPreAtPost_B_0)
  )
  \antecedentPolarity
  \replacewith (
      {heap:=heapAtPre_0_A}
        (  wellFormed(heap)
         & heapAtPre_0_A = heap
         &   boolean::select(heap, selfAtPre_0_A, java.lang.Object::<created>)
           = TRUE
         & contract.IFBlockExamples::exactInstance(selfAtPre_0_A) = TRUE
         & exc_1_A_0 = null
         & wellFormed(anon_heap_A_0)
         & lAtPre_A = l1_Before_A_0
         &   anon(store(heap,
                        selfAtPre_0_A,
                        contract.IFBlockExamples::$low,
                        add(Z(1(#)),
                            int::select(heap,
                                        selfAtPre_0_A,
                                        contract.IFBlockExamples::$low))),
                  empty,
                  anon_heap_A_0)
           = heap_After_BLOCK_A_0
         & selfAtPre_0_After_BLOCK_A_0 = selfAtPre_0_A
         & result_After_BLOCK_A_0 = result_A_0
         & exc_1_After_BLOCK_A_0 = null
         & l1_After_A_0 = anon_l1_A_0
         & RELATED_BY_BLOCK_at_line_17_in_secure_1_16885809(store(heap,
                                                                  selfAtPre_0_A,
                                                                  contract.IFBlockExamples::$low,
                                                                  add(Z(1(#)),
                                                                      int::select(heap,
                                                                                  selfAtPre_0_A,
                                                                                  contract.IFBlockExamples::$low))),
                                                            selfAtPre_0_A,
                                                            l1_Before_A_0,
                                                            result_A_0,
                                                            null,
                                                            heap_After_BLOCK_A_0,
                                                            selfAtPre_0_A,
                                                            anon_l1_A_0,
                                                            result_A_0,
                                                            null)
         & !selfAtPre_0_A = null
         & !{excAtPre_0_A:=null
             || heap:=heap_After_BLOCK_A_0
             || resultAtPre_A:=anon_l1_A_0}
              !(  selfAtPre_0_A = selfAtPost_0_A
                & resultAtPre_A = resultAtPost_A
                & excAtPre_0_A = excAtPost_0_A
                & heapAtPost_0_A = heap))
    & {heap:=heapAtPre_0_B}
        (  wellFormed(heap)
         & heapAtPre_0_B = heap
         &   boolean::select(heap, selfAtPre_0_B, java.lang.Object::<created>)
           = TRUE
         & contract.IFBlockExamples::exactInstance(selfAtPre_0_B) = TRUE
         & exc_1_B_0 = null
         & wellFormed(anon_heap_B_0)
         & lAtPre_B = l1_Before_B_0
         &   anon(store(heap,
                        selfAtPre_0_B,
                        contract.IFBlockExamples::$low,
                        add(Z(1(#)),
                            int::select(heap,
                                        selfAtPre_0_B,
                                        contract.IFBlockExamples::$low))),
                  empty,
                  anon_heap_B_0)
           = heap_After_BLOCK_B_0
         & selfAtPre_0_After_BLOCK_B_0 = selfAtPre_0_B
         & result_After_BLOCK_B_0 = result_B_0
         & exc_1_After_BLOCK_B_0 = null
         & l1_After_B_0 = anon_l1_B_0
         & RELATED_BY_BLOCK_at_line_17_in_secure_1_16885809(store(heap,
                                                                  selfAtPre_0_B,
                                                                  contract.IFBlockExamples::$low,
                                                                  add(Z(1(#)),
                                                                      int::select(heap,
                                                                                  selfAtPre_0_B,
                                                                                  contract.IFBlockExamples::$low))),
                                                            selfAtPre_0_B,
                                                            l1_Before_B_0,
                                                            result_B_0,
                                                            null,
                                                            heap_After_BLOCK_B_0,
                                                            selfAtPre_0_B,
                                                            anon_l1_B_0,
                                                            result_B_0,
                                                            null)
         & !selfAtPre_0_B = null
         & !{excAtPre_0_B:=null
             || heap:=heap_After_BLOCK_B_0
             || resultAtPre_B:=anon_l1_B_0}
              !(  selfAtPre_0_B = selfAtPost_0_B
                & resultAtPre_B = resultAtPost_B
                & excAtPre_0_B = excAtPost_0_B
                & heapAtPost_0_B = heap))
  )
  \heuristics ( concrete )
};
}

\problem {
!(  wellFormed(heapAtPre_0)
  & heap = heapAtPre_0
  & !selfAtPre_0 = null
  &   boolean::select(heap,
                      selfAtPre_0,
                      java.lang.Object::<created>)
    = TRUE
  &   contract.IFBlockExamples::exactInstance(selfAtPre_0)
    = TRUE
  & (inInt(lAtPre) & inInt(lAtPost))
  & java.lang.Object::<inv>(heapAtPre_0, selfAtPre_0)
  & {_lAtPre:=lAtPre}
      \[{
          excAtPre_0=null;try {resultAtPre=selfAtPre_0.secure_1(_lAtPre)@contract.IFBlockExamples;
          }catch (java.lang.Exception e) {
            excAtPre_0=e;
          }
        }\] (  selfAtPost_0 = selfAtPre_0
             & resultAtPost = resultAtPre
             & excAtPost_0 = excAtPre_0
             & heapAtPost_0 = heap))

}

\proof {
(keyLog "0" (keyUser "christoph" ) (keyVersion "90bb886cd7b78027c8f6703803461f09e5699bb9"))

(autoModeTime "474")

(branch "dummy ID"
(rule "boxToDiamond" (formula "1") (term "1,1,0") (userinteraction))
(builtin "One Step Simplification" (formula "1"))
(rule "notRight" (formula "1"))
(rule "andLeft" (formula "1"))
(rule "andLeft" (formula "1"))
(rule "notLeft" (formula "3"))
(rule "andLeft" (formula "1"))
(rule "andLeft" (formula "1"))
(rule "andLeft" (formula "1"))
(rule "notLeft" (formula "2"))
(rule "andLeft" (formula "1"))
(rule "assignment" (formula "7") (term "1"))
(builtin "One Step Simplification" (formula "7"))
(rule "eqSymm" (formula "2"))
(rule "eqSymm" (formula "7") (term "0,0,0,0,0,1"))
(rule "eqSymm" (formula "7") (term "1,0,0,0,1"))
(rule "eqSymm" (formula "7") (term "1,0,0,0,0,1"))
(rule "applyEq" (formula "5") (term "0") (ifseqformula "2"))
(rule "applyEq" (formula "1") (term "0") (ifseqformula "2"))
(rule "Class_invariant_axiom_for_contract_IFBlockExamples" (formula "5") (ifseqformula "4"))
(rule "true_left" (formula "5"))
(rule "methodBodyExpand" (formula "6") (term "1") (newnames "heapBefore_secure_1"))
(builtin "One Step Simplification" (formula "6"))
(rule "variableDeclarationAssign" (formula "6") (term "1"))
(rule "variableDeclaration" (formula "6") (term "1") (newnames "l1"))
(rule "assignment" (formula "6") (term "1"))
(builtin "One Step Simplification" (formula "6"))
(rule "postincrement" (formula "6") (term "1"))
(rule "compound_int_cast_expression" (formula "6") (term "1") (inst "#v=x"))
(rule "variableDeclarationAssign" (formula "6") (term "1"))
(rule "variableDeclaration" (formula "6") (term "1") (newnames "x"))
(rule "remove_parentheses_right" (formula "6") (term "1"))
(rule "assignmentAdditionInt" (formula "6") (term "1"))
(builtin "One Step Simplification" (formula "6"))
(rule "translateJavaAddInt" (formula "6") (term "0,1,0"))
(rule "polySimp_addComm0" (formula "6") (term "0,1,0"))
(rule "widening_identity_cast_5" (formula "6") (term "1"))
(rule "assignment" (formula "6") (term "1"))
(builtin "One Step Simplification" (formula "6"))
(rule "variableDeclarationAssign" (formula "6") (term "1"))
(rule "variableDeclaration" (formula "6") (term "1") (newnames "l2"))
(rule "assignment" (formula "6") (term "1"))
(builtin "One Step Simplification" (formula "6"))
(rule "variableDeclarationAssign" (formula "6") (term "1"))
(rule "variableDeclaration" (formula "6") (term "1") (newnames "l3"))
(rule "assignment" (formula "6") (term "1"))
(builtin "One Step Simplification" (formula "6"))
(builtin "Block Contract" (formula "6") (newnames "anon_heap,result,exc_1,heap_Before_BLOCK,savedHeap_Before_BLOCK,l1_Before_BLOCK,o,f,anon_l1,heap_After_BLOCK,selfAtPre_0_After_BLOCK,l1_Before,l1_After,result_After_BLOCK,exc_1_After_BLOCK,selfAtPre_0_A_0,l1_Before_A,result_A,exc_1_A,heap_Before_BLOCK_A,selfAtPre_0_After_BLOCK_A,l1_After_A,result_After_BLOCK_A,exc_1_After_BLOCK_A,heap_After_BLOCK_A,selfAtPre_0_B_0,l1_Before_B,result_B,exc_1_B,heap_Before_BLOCK_B,selfAtPre_0_After_BLOCK_B,l1_After_B,result_After_BLOCK_B,exc_1_After_BLOCK_B,heap_After_BLOCK_B"))
(branch "Information Flow Validity"
   (rule "unfold_computed_formula_0_of_Block_Contract_17_secure_1_16885809" (formula "1") (term "0"))
   (builtin "One Step Simplification" (formula "1"))
   (rule "impRight" (formula "1"))
   (rule "impRight" (formula "2"))
   (rule "eqSymm" (formula "2") (term "1,0,0,1,0,1,0,0"))
   (rule "eqSymm" (formula "2") (term "1,1,0,0,1,0"))
   (rule "eqSymm" (formula "2") (term "1,1,0,1,0,0"))
   (rule "eqSymm" (formula "2") (term "1,1,0,1,1,0"))
   (rule "eqSymm" (formula "2") (term "1,0,1,0,1,1,0"))
   (rule "eqSymm" (formula "2") (term "0,0,0,0,1,0,1,1,0"))
   (rule "eqSymm" (formula "2") (term "1,0,1,0,1,0,0"))
   (rule "eqSymm" (formula "2") (term "0,0,0,0,1,0,1,0,0"))
   (rule "eqSymm" (formula "2") (term "1,1,0,0,1"))
   (rule "eqSymm" (formula "2") (term "1,1,0,0,0,0"))
   (rule "eqSymm" (formula "2") (term "1,1,0,1,1"))
   (rule "eqSymm" (formula "2") (term "1,0,1,0,1,1"))
   (rule "eqSymm" (formula "2") (term "1,0,0,1,0,1,1,0"))
   (rule "eqSymm" (formula "2") (term "1,0,0,1,0,1,1"))
   (rule "eqSymm" (formula "2") (term "0,0,0,0,1,0,1,1"))
   (rule "eqSymm" (formula "3"))
   (rule "eqSymm" (formula "1"))
   (rule "polySimp_homoEq" (formula "2") (term "1,0,0,0,1,0,0,1"))
   (rule "polySimp_homoEq" (formula "2") (term "1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_homoEq" (formula "2") (term "1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_homoEq" (formula "2") (term "1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_homoEq" (formula "2") (term "1,0,0,0,1,0,1,0,0"))
   (rule "polySimp_homoEq" (formula "2") (term "1,0,0,0,1,0,1,1"))
   (rule "polySimp_addComm1" (formula "2") (term "0,1,0,0,0,1,0,0,1"))
   (rule "polySimp_addComm1" (formula "2") (term "0,1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_addComm1" (formula "2") (term "0,1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_addComm1" (formula "2") (term "0,1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_addComm1" (formula "2") (term "0,1,0,0,0,1,0,1,0,0"))
   (rule "polySimp_addComm1" (formula "2") (term "0,1,0,0,0,1,0,1,1"))
   (rule "applyEq" (formula "2") (term "1,0,1,0,0,0,1,0,1,1,0") (ifseqformula "1"))
   (rule "applyEq" (formula "2") (term "1,0,1,0,0,0,1,0,1,1") (ifseqformula "1"))
   (rule "applyEq" (formula "2") (term "1,0,1,0,0,0,1,0,1,0,0") (ifseqformula "1"))
   (rule "polySimp_sepPosMonomial" (formula "2") (term "1,0,0,0,1,0,0,1"))
   (rule "polySimp_mulComm0" (formula "2") (term "1,1,0,0,0,1,0,0,1"))
   (rule "polySimp_rightDist" (formula "2") (term "1,1,0,0,0,1,0,0,1"))
   (rule "polySimp_mulLiterals" (formula "2") (term "1,1,1,0,0,0,1,0,0,1"))
   (rule "mul_literals" (formula "2") (term "0,1,1,0,0,0,1,0,0,1"))
   (rule "polySimp_elimOne" (formula "2") (term "1,1,1,0,0,0,1,0,0,1"))
   (rule "polySimp_sepPosMonomial" (formula "2") (term "1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_mulComm0" (formula "2") (term "1,1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_rightDist" (formula "2") (term "1,1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_mulLiterals" (formula "2") (term "1,1,1,0,0,0,1,0,0,0,0"))
   (rule "mul_literals" (formula "2") (term "0,1,1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_elimOne" (formula "2") (term "1,1,1,0,0,0,1,0,0,0,0"))
   (rule "polySimp_sepPosMonomial" (formula "2") (term "1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_mulComm0" (formula "2") (term "1,1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_rightDist" (formula "2") (term "1,1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_mulLiterals" (formula "2") (term "1,1,1,0,0,0,1,0,0,1,0"))
   (rule "mul_literals" (formula "2") (term "0,1,1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_elimOne" (formula "2") (term "1,1,1,0,0,0,1,0,0,1,0"))
   (rule "polySimp_sepPosMonomial" (formula "2") (term "1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_mulComm0" (formula "2") (term "1,1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_rightDist" (formula "2") (term "1,1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_mulLiterals" (formula "2") (term "1,1,1,0,0,0,1,0,1,1,0"))
   (rule "mul_literals" (formula "2") (term "0,1,1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_elimOne" (formula "2") (term "1,1,1,0,0,0,1,0,1,1,0"))
   (rule "polySimp_sepPosMonomial" (formula "2") (term "1,0,0,0,1,0,1,1"))
   (rule "polySimp_mulComm0" (formula "2") (term "1,1,0,0,0,1,0,1,1"))
   (rule "polySimp_rightDist" (formula "2") (term "1,1,0,0,0,1,0,1,1"))
   (rule "polySimp_mulLiterals" (formula "2") (term "1,1,1,0,0,0,1,0,1,1"))
   (rule "mul_literals" (formula "2") (term "0,1,1,0,0,0,1,0,1,1"))
   (rule "polySimp_elimOne" (formula "2") (term "1,1,1,0,0,0,1,0,1,1"))
   (rule "polySimp_sepPosMonomial" (formula "2") (term "1,0,0,0,1,0,1,0,0"))
   (rule "polySimp_mulComm0" (formula "2") (term "1,1,0,0,0,1,0,1,0,0"))
   (rule "polySimp_rightDist" (formula "2") (term "1,1,0,0,0,1,0,1,0,0"))
   (rule "polySimp_mulLiterals" (formula "2") (term "1,1,1,0,0,0,1,0,1,0,0"))
   (rule "mul_literals" (formula "2") (term "0,1,1,0,0,0,1,0,1,0,0"))
   (rule "polySimp_elimOne" (formula "2") (term "1,1,1,0,0,0,1,0,1,0,0"))
   (rule "orLeft" (formula "2"))
   (branch " wellFormed(heap_Before_BLOCK_A) ∧ heap_Before_BLOCK_A[selfAtPre_0_A_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE ∧ ¬l2_A_0 = 8 ∧ ( selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0 ∧ l1_Before_A = -1 + l1_After_A ∧ result_After_BLOCK_A = result_A ∧ exc_1_After_BLOCK_A = exc_1_A ∧ heap_Before_BLOCK_A = heap_After_BLOCK_A) ∧ ¬selfAtPre_0_A_0 = null ∧ ( wellFormed(heap_Before_BLOCK_B) ∧ heap_Before_BLOCK_B[selfAtPre_0_B_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE ∧ ¬l2_B_0 = 8 ∧ ( selfAtPre_0_B_0 = selfAtPre_0_After_BLOCK_B ∧ l1_Before_A = -1 + l1_After_B ∧ result_B = result_After_BLOCK_B ∧ exc_1_B = exc_1_After_BLOCK_B ∧ heap_Before_BLOCK_B = heap_After_BLOCK_B) ∧ ¬selfAtPre_0_B_0 = null) ∨ wellFormed(heap_Before_BLOCK_A) ∧ heap_Before_BLOCK_A[selfAtPre_0_A_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE ∧ ¬l2_A_0 = 8 ∧ ( selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0 ∧ l1_Before_A = -1 + l1_After_A ∧ result_After_BLOCK_A = result_A ∧ exc_1_After_BLOCK_A = exc_1_A ∧ heap_Before_BLOCK_A = heap_After_BLOCK_A) ∧ ¬selfAtPre_0_A_0 = null ∧ ( l2_B_0 = 8 ∧ wellFormed(heap_Before_BLOCK_B) ∧ heap_Before_BLOCK_B[selfAtPre_0_B_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE ∧ ( selfAtPre_0_B_0 = selfAtPre_0_After_BLOCK_B ∧ l1_Before_A = -1 + l1_After_B ∧ result_B = result_After_BLOCK_B ∧ exc_1_B = exc_1_After_BLOCK_B ∧ heap_Before_BLOCK_B = heap_After_BLOCK_B) ∧ ¬selfAtPre_0_B_0 = null)"
      (rule "orLeft" (formula "2"))
      (branch " wellFormed(heap_Before_BLOCK_A) ∧ heap_Before_BLOCK_A[selfAtPre_0_A_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE ∧ ¬l2_A_0 = 8 ∧ ( selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0 ∧ l1_Before_A = -1 + l1_After_A ∧ result_After_BLOCK_A = result_A ∧ exc_1_After_BLOCK_A = exc_1_A ∧ heap_Before_BLOCK_A = heap_After_BLOCK_A) ∧ ¬selfAtPre_0_A_0 = null ∧ ( wellFormed(heap_Before_BLOCK_B) ∧ heap_Before_BLOCK_B[selfAtPre_0_B_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE ∧ ¬l2_B_0 = 8 ∧ ( selfAtPre_0_B_0 = selfAtPre_0_After_BLOCK_B ∧ l1_Before_A = -1 + l1_After_B ∧ result_B = result_After_BLOCK_B ∧ exc_1_B = exc_1_After_BLOCK_B ∧ heap_Before_BLOCK_B = heap_After_BLOCK_B) ∧ ¬selfAtPre_0_B_0 = null)"
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "4"))
         (rule "andLeft" (formula "2"))
         (rule "notLeft" (formula "4"))
         (rule "andLeft" (formula "4"))
         (rule "notLeft" (formula "6"))
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "4"))
         (rule "andLeft" (formula "6"))
         (rule "andLeft" (formula "8"))
         (rule "andLeft" (formula "2"))
         (rule "notLeft" (formula "4"))
         (rule "andLeft" (formula "4"))
         (rule "andLeft" (formula "7"))
         (rule "notLeft" (formula "9"))
         (rule "andLeft" (formula "9"))
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "5"))
         (rule "andLeft" (formula "9"))
         (rule "andLeft" (formula "12"))
         (rule "andLeft" (formula "5"))
         (rule "andLeft" (formula "13"))
         (rule "applyEq" (formula "20") (term "0") (ifseqformula "13"))
         (rule "applyEq" (formula "12") (term "0,0") (ifseqformula "13"))
         (rule "applyEq" (formula "3") (term "0,0") (ifseqformula "9"))
         (rule "applyEq" (formula "2") (term "0") (ifseqformula "9"))
         (rule "applyEq" (formula "10") (term "0") (ifseqformula "17"))
         (rule "applyEq" (formula "11") (term "1,0") (ifseqformula "13"))
         (rule "applyEq" (formula "6") (term "0") (ifseqformula "14"))
         (rule "polySimp_homoEq" (formula "6"))
         (rule "polySimp_mulComm0" (formula "6") (term "1,0"))
         (rule "polySimp_rightDist" (formula "6") (term "1,0"))
         (rule "mul_literals" (formula "6") (term "0,1,0"))
         (rule "polySimp_addAssoc" (formula "6") (term "0"))
         (rule "polySimp_addComm1" (formula "6") (term "0,0"))
         (rule "add_literals" (formula "6") (term "0,0,0"))
         (rule "add_zero_left" (formula "6") (term "0,0"))
         (rule "applyEq" (formula "11") (term "0,0") (ifseqformula "17"))
         (rule "applyEq" (formula "1") (term "1") (ifseqformula "14"))
         (rule "polySimp_sepNegMonomial" (formula "6"))
         (rule "polySimp_mulLiterals" (formula "6") (term "0"))
         (rule "polySimp_elimOne" (formula "6") (term "0"))
         (rule "close" (formula "22") (ifseqformula "6"))
      )
      (branch " wellFormed(heap_Before_BLOCK_A) ∧ heap_Before_BLOCK_A[selfAtPre_0_A_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE ∧ ¬l2_A_0 = 8 ∧ ( selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0 ∧ l1_Before_A = -1 + l1_After_A ∧ result_After_BLOCK_A = result_A ∧ exc_1_After_BLOCK_A = exc_1_A ∧ heap_Before_BLOCK_A = heap_After_BLOCK_A) ∧ ¬selfAtPre_0_A_0 = null ∧ ( l2_B_0 = 8 ∧ wellFormed(heap_Before_BLOCK_B) ∧ heap_Before_BLOCK_B[selfAtPre_0_B_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE ∧ ( selfAtPre_0_B_0 = selfAtPre_0_After_BLOCK_B ∧ l1_Before_A = -1 + l1_After_B ∧ result_B = result_After_BLOCK_B ∧ exc_1_B = exc_1_After_BLOCK_B ∧ heap_Before_BLOCK_B = heap_After_BLOCK_B) ∧ ¬selfAtPre_0_B_0 = null)"
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "4"))
         (rule "andLeft" (formula "2"))
         (rule "notLeft" (formula "4"))
         (rule "andLeft" (formula "4"))
         (rule "notLeft" (formula "6"))
         (rule "andLeft" (formula "3"))
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "7"))
         (rule "andLeft" (formula "6"))
         (rule "andLeft" (formula "4"))
         (rule "andLeft" (formula "2"))
         (rule "notLeft" (formula "4"))
         (rule "andLeft" (formula "9"))
         (rule "andLeft" (formula "7"))
         (rule "andLeft" (formula "4"))
         (rule "andLeft" (formula "2"))
         (rule "andLeft" (formula "12"))
         (rule "andLeft" (formula "9"))
         (rule "andLeft" (formula "5"))
         (rule "andLeft" (formula "14"))
         (rule "applyEq" (formula "6") (term "0") (ifseqformula "15"))
         (rule "polySimp_homoEq" (formula "6"))
         (rule "polySimp_mulComm0" (formula "6") (term "1,0"))
         (rule "polySimp_rightDist" (formula "6") (term "1,0"))
         (rule "mul_literals" (formula "6") (term "0,1,0"))
         (rule "polySimp_addAssoc" (formula "6") (term "0"))
         (rule "polySimp_addComm1" (formula "6") (term "0,0"))
         (rule "add_literals" (formula "6") (term "0,0,0"))
         (rule "add_zero_left" (formula "6") (term "0,0"))
         (rule "applyEq" (formula "3") (term "0,0") (ifseqformula "9"))
         (rule "applyEq" (formula "20") (term "0") (ifseqformula "14"))
         (rule "applyEq" (formula "12") (term "1,0") (ifseqformula "14"))
         (rule "applyEq" (formula "2") (term "0") (ifseqformula "9"))
         (rule "applyEq" (formula "13") (term "0,0") (ifseqformula "14"))
         (rule "applyEq" (formula "12") (term "0,0") (ifseqformula "18"))
         (rule "applyEq" (formula "11") (term "0") (ifseqformula "18"))
         (rule "applyEq" (formula "1") (term "1") (ifseqformula "15"))
         (rule "polySimp_sepNegMonomial" (formula "6"))
         (rule "polySimp_mulLiterals" (formula "6") (term "0"))
         (rule "polySimp_elimOne" (formula "6") (term "0"))
         (rule "close" (formula "22") (ifseqformula "6"))
      )
   )
   (branch " l2_A_0 = 8 ∧ wellFormed(heap_Before_BLOCK_A) ∧ heap_Before_BLOCK_A[selfAtPre_0_A_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_A_0) = TRUE ∧ ( selfAtPre_0_After_BLOCK_A = selfAtPre_0_A_0 ∧ l1_Before_A = -1 + l1_After_A ∧ result_After_BLOCK_A = result_A ∧ exc_1_After_BLOCK_A = exc_1_A ∧ heap_Before_BLOCK_A = heap_After_BLOCK_A) ∧ ¬selfAtPre_0_A_0 = null ∧ ( l2_B_0 = 8 ∧ wellFormed(heap_Before_BLOCK_B) ∧ heap_Before_BLOCK_B[selfAtPre_0_B_0.<created>] = TRUE ∧ contract.IFBlockExamples::exactInstance(selfAtPre_0_B_0) = TRUE ∧ ( selfAtPre_0_B_0 = selfAtPre_0_After_BLOCK_B ∧ l1_Before_A = -1 + l1_After_B ∧ result_B = result_After_BLOCK_B ∧ exc_1_B = exc_1_After_BLOCK_B ∧ heap_Before_BLOCK_B = heap_After_BLOCK_B) ∧ ¬selfAtPre_0_B_0 = null)"
      (rule "andLeft" (formula "2"))
      (rule "andLeft" (formula "3"))
      (rule "andLeft" (formula "2"))
      (rule "notLeft" (formula "5"))
      (rule "andLeft" (formula "4"))
      (rule "andLeft" (formula "2"))
      (rule "notLeft" (formula "4"))
      (rule "andLeft" (formula "5"))
      (rule "andLeft" (formula "4"))
      (rule "andLeft" (formula "2"))
      (rule "andLeft" (formula "4"))
      (rule "andLeft" (formula "8"))
      (rule "andLeft" (formula "6"))
      (rule "andLeft" (formula "2"))
      (rule "andLeft" (formula "5"))
      (rule "andLeft" (formula "11"))
      (rule "andLeft" (formula "8"))
      (rule "andLeft" (formula "2"))
      (rule "andLeft" (formula "6"))
      (rule "andLeft" (formula "14"))
      (rule "andLeft" (formula "6"))
      (rule "applyEq" (formula "13") (term "0,0") (ifseqformula "19"))
      (rule "applyEq" (formula "13") (term "1,0") (ifseqformula "15"))
      (rule "applyEq" (formula "4") (term "0,0") (ifseqformula "10"))
      (rule "applyEq" (formula "14") (term "0,0") (ifseqformula "15"))
      (rule "applyEq" (formula "12") (term "0") (ifseqformula "19"))
      (rule "applyEq" (formula "3") (term "0") (ifseqformula "10"))
      (rule "applyEq" (formula "21") (term "0") (ifseqformula "15"))
      (rule "applyEq" (formula "16") (term "0") (ifseqformula "7"))
      (rule "polySimp_homoEq" (formula "16"))
      (rule "polySimp_mulComm0" (formula "16") (term "1,0"))
      (rule "polySimp_rightDist" (formula "16") (term "1,0"))
      (rule "mul_literals" (formula "16") (term "0,1,0"))
      (rule "polySimp_addComm1" (formula "16") (term "0"))
      (rule "polySimp_addAssoc" (formula "16") (term "0,0"))
      (rule "add_literals" (formula "16") (term "0,0,0"))
      (rule "add_zero_left" (formula "16") (term "0,0"))
      (rule "applyEq" (formula "1") (term "1") (ifseqformula "7"))
      (rule "polySimp_sepPosMonomial" (formula "16"))
      (rule "polySimp_mulLiterals" (formula "16") (term "1"))
      (rule "polySimp_elimOne" (formula "16") (term "1"))
      (rule "close" (formula "22") (ifseqformula "16"))
   )
)
(branch "Precondition"
   (builtin "One Step Simplification" (formula "6"))
   (rule "wellFormedStorePrimitive" (formula "6"))
   (rule "close" (formula "6") (ifseqformula "1"))
)
(branch "Usage"
   (builtin "One Step Simplification" (formula "7"))
   (builtin "One Step Simplification" (formula "5"))
   (rule "andLeft" (formula "5"))
   (rule "andLeft" (formula "5"))
   (rule "andLeft" (formula "7"))
   (rule "andLeft" (formula "5"))
   (rule "andLeft" (formula "9"))
   (rule "andLeft" (formula "9"))
   (rule "andLeft" (formula "9"))
   (rule "andLeft" (formula "9"))
   (rule "andLeft" (formula "9"))
   (rule "eqSymm" (formula "8"))
   (rule "eqSymm" (formula "9"))
   (rule "replace_known_left" (formula "7") (term "1") (ifseqformula "5"))
   (builtin "One Step Simplification" (formula "7"))
   (rule "true_left" (formula "7"))
   (rule "applyEq" (formula "11") (term "1") (ifseqformula "5"))
   (rule "applyEq" (formula "13") (term "8") (ifseqformula "10"))
   (rule "applyEq" (formula "13") (term "7") (ifseqformula "12"))
   (rule "applyEq" (formula "13") (term "4") (ifseqformula "5"))
   (rule "applyEq" (formula "13") (term "6") (ifseqformula "9"))
   (rule "applyEq" (formula "15") (term "0,1,1,0") (ifseqformula "8"))
   (rule "applyEq" (formula "13") (term "9") (ifseqformula "11"))
   (rule "ifUnfold" (formula "15") (term "1") (inst "#boolv=x"))
   (rule "variableDeclaration" (formula "15") (term "1") (newnames "x_1"))
   (rule "inequality_comparison_simple" (formula "15") (term "1"))
   (builtin "One Step Simplification" (formula "15"))
   (rule "replace_known_left" (formula "15") (term "0,0,1,0") (ifseqformula "5"))
   (builtin "One Step Simplification" (formula "15"))
   (rule "if" (formula "15") (term "1"))
   (builtin "One Step Simplification" (formula "15"))
   (rule "blockEmpty" (formula "15") (term "1"))
   (rule "methodCallReturn" (formula "15") (term "1"))
   (rule "assignment" (formula "15") (term "1"))
   (builtin "One Step Simplification" (formula "15"))
   (rule "methodCallEmpty" (formula "15") (term "1"))
   (rule "tryEmpty" (formula "15") (term "1"))
   (rule "emptyModality" (formula "15") (term "1"))
   (opengoal "!(  wellFormed(heapAtPre_0)   & heap = heapAtPre_0   & !selfAtPre_0 = null   &   boolean::select(heap,                       selfAtPre_0,                       java.lang.Object::<created>)     = TRUE   &   contract.IFBlockExamples::exactInstance(selfAtPre_0)     = TRUE   & (inInt(lAtPre) & inInt(lAtPost))   & java.lang.Object::<inv>(heapAtPre_0, selfAtPre_0)   & {_lAtPre:=lAtPre}       \\[{           excAtPre_0=null;try {resultAtPre=selfAtPre_0.secure_1(_lAtPre)@contract.IFBlockExamples;           }catch (java.lang.Exception e) {             excAtPre_0=e;           }         }\\] (  selfAtPost_0 = selfAtPre_0              & resultAtPost = resultAtPre              & excAtPost_0 = excAtPre_0              & heapAtPost_0 = heap)) ")
)
)

}
